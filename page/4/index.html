<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="The Best or Nothing">
<meta property="og:type" content="website">
<meta property="og:title" content="xuwei'blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="xuwei'blog">
<meta property="og:description" content="The Best or Nothing">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xuwei'blog">
<meta name="twitter:description" content="The Best or Nothing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title> xuwei'blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">xuwei'blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/31/《Java编程思想》学习笔记之RTTI与反射/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/31/《Java编程思想》学习笔记之RTTI与反射/" itemprop="url">
                  《Java编程思想》学习笔记之RTTI与反射
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-31T10:59:42+08:00">
                2016-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/12/31/《Java编程思想》学习笔记之RTTI与反射/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之RTTI与反射">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　Java程序能够在运行时识别对象和类的信息，主要是通过两种方式来实现的。一种是RTTI(Run-Time Type Information)，它假定我们在编译阶段就已经知道了所有的类型；另一种就是Java的反射机制，它允许我们在运行时就发现和使用类的信息。<br>  　　本章学习要点：</p>
<ul>
<li>RTTI的三种方式</li>
<li>反射</li>
<li>动态代理</li>
<li>总结<h2 id="1-RTTI的三种方式"><a href="#1-RTTI的三种方式" class="headerlink" title="1.RTTI的三种方式"></a><strong>1.RTTI的三种方式</strong></h2>　　RTTI的含义为：在运行时，识别一个对象的类型。在Java中，主要有三种RTTI的实现方式，分别是传统的类型转换，代表对象的类型的Class对象和instanceof<h4 id="1-1-传统的类型转换"><a href="#1-1-传统的类型转换" class="headerlink" title="1.1 传统的类型转换"></a><strong>1.1 传统的类型转换</strong></h4>　　在之前的学习中，接触过多态，对于RTTI传统的类型转换，也与多态有一些联系。就像如下的代码：<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">   void method()&#123;</div><div class="line">    System.out.println("A-method()");</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B extends A&#123;</div><div class="line">     public void method()&#123;</div><div class="line">     System.out.println("B-method()");</div><div class="line">&#125;</div><div class="line">public static void main (String[] args)&#123;</div><div class="line">    //多态</div><div class="line">    A a1 = new B();</div><div class="line">    a1.method();</div><div class="line">    </div><div class="line">    //传统的类型转换</div><div class="line">    A a2 = new B();</div><div class="line">    B b = (B)a2;</div><div class="line">    b.method();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">B-method</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">B-method</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>　　对于传统的类型转换而言，是把父类的引用a2强转为子类的对象b。在运行时，类型转换操作确保了这一点，然后再进行B类的method()方法的调用。<br>  　　而对于多态而言，个人理解的是它内部实现了RTTI机制，所以能够以更简单的代码来完成同样的功能。这样的设计也更容易实现、理解和改变。所以说，<strong>“多态”是面向对象编程的基本目标</strong>。</p>
<h4 id="1-2-Class对象"><a href="#1-2-Class对象" class="headerlink" title="1.2.Class对象"></a><strong>1.2.Class对象</strong></h4><p>　　Java也能够通过查询Class对象来获取运行时所需要的信息。类是程序的一部分，每个类都有一个Class对象。一旦某个类的Class对象被载入内存，它就能够用来创建这个类的所有对象。获取Class对象也有三个方式，分别是forName()方法、getClass方法()和类字面常量.Class。</p>
<h4 id="1-2-1-forName-方法"><a href="#1-2-1-forName-方法" class="headerlink" title="1.2.1 forName()方法"></a><strong>1.2.1 forName()方法</strong></h4><p>　　forName()是取得Class对象的引用的一种方法。它用一个包含目标类的文本名的String作为输入参数，返回的是一个Class对象的引用。如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">class Apple1&#123;</div><div class="line">	static&#123;System.out.println("Loading Apple");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Orange1&#123;</div><div class="line">	static&#123;System.out.println("Loading Orange1");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class RTTItest1 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println("inside main");</div><div class="line">		new Apple1();</div><div class="line">		try &#123;</div><div class="line">			Class.forName("test2.Orange1");</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inside main</div><div class="line">Loading Apple</div><div class="line">Loading Orange1</div></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>不需要持有对象，就可以通过forName()来获得对象的引用</li>
<li>forName()里面的类名字符串，必须使用全限定名（包含包名）<h4 id="1-2-2-getClass-方法"><a href="#1-2-2-getClass-方法" class="headerlink" title="1.2.2 getClass()方法"></a><strong>1.2.2 getClass()方法</strong></h4>如果已经拥有了类的对象，可以通过getClass()来获取Class引用。如下所示：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">class Apple1&#123;</div><div class="line">	static&#123;System.out.println("Loading Apple");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Orange1&#123;</div><div class="line">	static&#123;System.out.println("Loading Orange1");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class RTTItest1 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println("inside main");</div><div class="line">		new Apple1();</div><div class="line">		Class c = null;</div><div class="line">		try &#123;</div><div class="line">			c = Class.forName("test2.Orange1");</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		Object obj= null;</div><div class="line">		try &#123;</div><div class="line">			obj= c.newInstance();</div><div class="line">		&#125; catch (InstantiationException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; catch (IllegalAccessException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		Class b = obj.getClass();</div><div class="line">		System.out.println(b.getName());</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">inside main</div><div class="line">Loading Apple</div><div class="line">Loading Orange1</div><div class="line">test2.Orange1</div></pre></td></tr></table></figure>
<p>　　示例中，前面一段程序和上个知识点的一致，那就是通过forName获得类的引用。通过类的引用和newInstance()方法获得了Orange1类的一个示例。之后的程序就是展示getClass()的作用了。通过getClass再次获得类的引用，然后通过getName方法显示除了类的信息。<br>  　　需要注意的点：</p>
<ul>
<li>newInstance()方法是实现“虚拟构造方法”的一种途径。通过这个方法创造示例时，得到的是Object引用，这个引用指向实际类型的对象。</li>
<li>使用newInstance()来创建的类，必须带有默认的构造方法。</li>
<li>除了getName()方法，还有辅助的getSimpleName()、getCanonicalName(),getInterface()都需要关注。</li>
<li>getSuperclass()可以直接查询基类。<h4 id="1-2-3-类字面常量-Class"><a href="#1-2-3-类字面常量-Class" class="headerlink" title="1.2.3 类字面常量.Class"></a><strong>1.2.3 类字面常量.Class</strong></h4>　　Java提供了第三种方法来生成对Class对象的引用，那就是类字面常量。使用类字面常量更安全，因为它在编译时就会受到检查，因此不需要置于try语句中，如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">class Apple1&#123;</div><div class="line">	static&#123;System.out.println("Loading Apple");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Orange1&#123;</div><div class="line">	static final int X =1;</div><div class="line">	static int Y=2;</div><div class="line">	</div><div class="line">	static&#123;System.out.println("Loading Orange1");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class RTTItest1 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println("inside main");</div><div class="line">		new Apple1();</div><div class="line">		Class or = Orange1.class;</div><div class="line">		System.out.println(Orange1.X);</div><div class="line">		System.out.println(Orange1.Y);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">inside main</div><div class="line">Loading Apple</div><div class="line"><span class="number">1</span></div><div class="line">Loading Orange1</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>　　需要注意的是：</p>
<ul>
<li>使用.class语法来获得对类的引用不会引发初始化，而Class.forName()产生Class引用后，就立即的进行了初始化</li>
<li>如果一“static final“值是编译器常量，那么这个值不需要对类进行初始化就可以被读取，而一个值是static而不是final的，那么对它进行访问时，首先要进行链接和初始化分配空间。<h4 id="1-3-关键字instanceof"><a href="#1-3-关键字instanceof" class="headerlink" title="1.3.关键字instanceof"></a><strong>1.3.关键字instanceof</strong></h4>　　RTTI在Java中的第三个形式就是instanceof，它返回一个布尔值，告诉我们对象是不是某个特定类型的实例。如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line">class A&#123;</div><div class="line">	   void method()&#123;</div><div class="line">	    System.out.println("A-method()");</div><div class="line">	&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">public class B extends A&#123;</div><div class="line">    public void method()&#123;</div><div class="line">        System.out.println("B-method()");</div><div class="line">   &#125;</div><div class="line">    public void method1()&#123;</div><div class="line">        System.out.println("B-method1()");</div><div class="line">   &#125;</div><div class="line">   public static void main (String[] args)&#123;</div><div class="line">       A a = new B();</div><div class="line">       if(a instanceof B)</div><div class="line">       ((B)a).method1();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">B-method1</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>注意，instanceof有比较严格的限制，只能够将它与命名类型相比较，而不能与Class对象做比较。</p>
<p>小知识点：instanceof和equals的区别</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">class AAA&#123;&#125;</div><div class="line">class BBB extends AAA&#123;&#125;</div><div class="line"></div><div class="line">public class ClassTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		BBB b = new BBB();</div><div class="line">		</div><div class="line">		System.out.println(b instanceof BBB);</div><div class="line">		System.out.println(b.getClass().equals(BBB.class));</div><div class="line">		</div><div class="line">		System.out.println(b instanceof AAA);</div><div class="line">		System.out.println(b.getClass().equals( AAA.class));</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line">false</div></pre></td></tr></table></figure>
<p>　　可以看出，instanceof的测试结果考虑了继承，指的是是这个类或者这个类的子类时，均返回真。而equals比较的是实际的Class对象，并未没有考虑继承。</p>
<h2 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a><strong>2.反射</strong></h2><p>　　RTTI与反射之间的真正的区别只在于，对于RTTI而言，编译器在编译时打开和检查.class对象，即我们可以用普通的方式调用对象的所有方法；而对于反射机制而言，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。<br>　　在Java  API中，主要有java.lang.reflect类库和Class类对反射提供了支持。该类库有三个主要的类，分别是Field、Method和Constructor类，每个类都实现了Member接口。</p>
<h4 id="2-1-反射中的Constructor"><a href="#2-1-反射中的Constructor" class="headerlink" title="2.1 反射中的Constructor()"></a><strong>2.1 反射中的Constructor()</strong></h4><p>　　之前学习过一个知识点，那就是利用newInstance()方法来创建类的实例，但是使用仅限于类有无参的构造方法。如果需要创建对象的类没有无参的构造方法，就不能使用newInstance进行类的创建，而可以调用Class类的getConstructor(String.class,int.class)方法获取一个指定的构造函数然后再调用Constructor类的newInstance(Object… initargs)方法创建对象。示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line">public class Person &#123;</div><div class="line">    String name ;</div><div class="line">    int age;</div><div class="line">   public Person(String name,int age)&#123;</div><div class="line">	   this.name = name;</div><div class="line">	   this.age = age;</div><div class="line">   &#125;</div><div class="line">   public String toString()&#123;</div><div class="line">	   return "name ="+name+"   "+"age = "+age;</div><div class="line">   &#125;   </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">package com.reflect;</div><div class="line"></div><div class="line">import java.lang.reflect.Constructor;</div><div class="line">import test.Person;</div><div class="line"></div><div class="line">public class ReflectTest1 &#123;</div><div class="line">	public static void main(String[] args) throws Exception&#123;</div><div class="line">			</div><div class="line">			Constructor constructor = Person.class.getConstructor(String.class,int.class);</div><div class="line">		    Person p = (Person)constructor.newInstance("张三",25);</div><div class="line">		    System.out.println(p);		    </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name =张三   age = <span class="number">25</span></div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>不同包的Person类的有参构造方法必须是public修饰，否则会报java.lang.NoSuchMethodException错误。</li>
<li>.Class可以和forName()替换，两者的效果一致，但是.Class更加简洁。<h4 id="2-2-反射中的Field"><a href="#2-2-反射中的Field" class="headerlink" title="2.2 反射中的Field"></a><strong>2.2 反射中的Field</strong></h4>　　获取类的字节码文件之后，通过类的反射机制，可以获得类的成员变量。当成员变量为共有时，通过getField()方法就可行。当成员变量为私有时，也可以通过反射获取成员变量，方法为getDeclaredField()来实现。获取到成员变量之后，也可以通过set()来修改字段。<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line">import java.lang.reflect.*;</div><div class="line"></div><div class="line">class reflectField&#123;</div><div class="line">	public  int i =47;</div><div class="line">	private String s = "abc";</div><div class="line">	public String toString()&#123;</div><div class="line">		return "i="+i+"   "+"s="+s;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class reflectFieldTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws Exception &#123;</div><div class="line">		Class c1 = Class.forName("test2.reflectField");</div><div class="line">		reflectField rf = (reflectField)c1.newInstance();</div><div class="line">		Field f1 = c1.getField("i");</div><div class="line">		System.out.println(f1.getInt(rf));</div><div class="line">		f1.setInt(rf, 2017);</div><div class="line">		System.out.println(f1.getInt(rf));</div><div class="line">		</div><div class="line">		Field f2 = c1.getDeclaredField("s");</div><div class="line">		f2.setAccessible(true);</div><div class="line">		System.out.println(f2.get(rf));</div><div class="line">		f2.set(rf,"edf");</div><div class="line">		System.out.println(f2.get(rf));		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">47</span></div><div class="line"><span class="number">2017</span></div><div class="line">abc</div><div class="line">edf</div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>private表示不允许外界进行访问，但是反射可以越过这些权限直接访问，可以解决一些特定问题，后续需要再学习<h4 id="2-3-反射中的Method"><a href="#2-3-反射中的Method" class="headerlink" title="2.3 反射中的Method()"></a><strong>2.3 反射中的Method()</strong></h4>　　当获得某一个类的字节码文件之后，就可以通过Class.getMethod(String, Class…) 和 Class.getDeclaredMethod(String, Class…)方法获取类中的指定方法,调用invoke(Object, Object…)可以调用该方法。<br>如下所示：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line">public class Person &#123;</div><div class="line">    String name ;</div><div class="line">    int age;</div><div class="line">   public Person()&#123;&#125;;</div><div class="line">   public Person(String name,int age)&#123;</div><div class="line">	   this.name = name;</div><div class="line">	   this.age = age;</div><div class="line">   &#125;</div><div class="line">   public String toString()&#123;</div><div class="line">	   return "name ="+name+"   "+"age = "+age;</div><div class="line">   &#125;   </div><div class="line">   public void method1()&#123;System.out.println("method_1 run");&#125; </div><div class="line">   private void method2()&#123;System.out.println("method_2 run");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">package com.reflect;</div><div class="line">import java.lang.reflect.*;</div><div class="line"></div><div class="line">import test.Person;</div><div class="line"></div><div class="line">public class ReflectTest2 &#123;</div><div class="line">	public static void main(String[] args) throws Exception&#123;</div><div class="line">		</div><div class="line">    Person p = new Person();</div><div class="line">    Method m1 = p.getClass().getMethod("method1");</div><div class="line">    m1.invoke(p);</div><div class="line">    </div><div class="line">    Method m2 = p.getClass().getDeclaredMethod("method2");</div><div class="line">    m2.setAccessible(true);</div><div class="line">    m2.invoke(p);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">method_1 run</div><div class="line">method_2 run</div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>Person类中的method2属于私有方法，在外界是不可访问的，通过反射可以进行访问，调用方法getDeclaredMethod()并设置setAccessible为true。</li>
</ul>
<p>　　Class类中还提供了getMethods()方法和getConstructors()方法，它们能够分别返回Method对象的数组和Constructor对象的数组。这两个类都提供了深层方法，用来解析对象所代表的方法，并获取名字、输入参数和返回值。</p>
<h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3.动态代理"></a><strong>3.动态代理</strong></h2><p>　　当创建好了一个类之后，又想在对类的方法进行调用，并且在原来的方法上增加功能，而不想去修改原有类的源码，就可以通过代理来实现。在Java中，动态代理是通过java.lang.reflect包下提供的一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。<br>如下示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">//接口</div><div class="line">package com.reflect;</div><div class="line"></div><div class="line">public interface Interface &#123;</div><div class="line">	public void say();</div><div class="line">	public void eat();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//接口实现类</div><div class="line">package com.reflect;</div><div class="line"></div><div class="line">class Child implements Interface&#123;</div><div class="line">	public void say() &#123;</div><div class="line">		System.out.println("开始说话");</div><div class="line">		&#125;</div><div class="line">	public void eat() &#123;</div><div class="line">		System.out.println("开始吃饭");</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//代理类</div><div class="line">package com.reflect;</div><div class="line"></div><div class="line">import java.lang.reflect.*;</div><div class="line"></div><div class="line">public class DynamicProxyHandler implements InvocationHandler&#123;</div><div class="line"></div><div class="line">	private Object proxied;</div><div class="line">	public DynamicProxyHandler(Object proxied)&#123;</div><div class="line">		this.proxied=proxied;</div><div class="line">	&#125;</div><div class="line">	public Object invoke(Object proxy, Method method, Object[] args)</div><div class="line">			throws Throwable &#123;</div><div class="line">		System.out.println("新加入的语句");</div><div class="line">		return method.invoke(proxied, args);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//测试类</div><div class="line">package com.reflect;</div><div class="line"></div><div class="line">import java.lang.reflect.Proxy;</div><div class="line"></div><div class="line">public class ReflectTest3 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Child c = new Child();</div><div class="line">		Interface p = (Interface)Proxy.newProxyInstance(c.getClass().getClassLoader(), c.getClass().getInterfaces(), new DynamicProxyHandler(c));	</div><div class="line">		p.eat();</div><div class="line">		p.say();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">新加入的语句</div><div class="line">开始吃饭</div><div class="line">新加入的语句</div><div class="line">开始说话</div></pre></td></tr></table></figure>
<p>　　示例程序中，Child类实现了接口，也可以在测试类中直接进行方法的调用。但是，如果要在原有的方法中加入一些语句，而不能修改源码。则可以创建一个代理类，对方法进行代理。代理类有较强的灵活性，除了代理该类，通过改变参数，也可以代理其他的类。<br>  需要注意的点：</p>
<ul>
<li>.newProxyInstance()后面的三个参数模式是固定的，其中第一个参数为类加载器，通过对象反射获取字节码文件，再进行调用；第二个参数为类中的接口，通过反射获取字节码文件，再进行接口的调用；第三个参数是把实现类的对象传入代理类的构造方法中，作为代理类的一个实例对象。</li>
<li>.newProxyInstance()返回的是一个Object类型，需要用接口类型进行强转，并且用接口类型进行接收。之后再用接口类型进行方法的调用。</li>
<li>代理类中，Method.invoke()方法将请求转发给被代理对象，并且传入必需的参数。<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a><strong>4.总结</strong></h2></li>
<li>RTTI与多态。<br>在我们通过继承拓展程序时，父类可能没有包含子类的方法，这时就需要通过RTTI的强制类型转换来进行类型的检查。一般来说，面向对象语言的目地是再能够使用的地方尽量使用多态，只在必需的时候采用RTTI，这样能够简化代码，提高代码的效率。</li>
<li>反射是一种更加动态的编程风格。通过反射和动态代理，能够更好的拓展代码的功能和规模。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/26/《Java编程思想》学习笔记之正则表达式/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/26/《Java编程思想》学习笔记之正则表达式/" itemprop="url">
                  《Java编程思想》学习笔记之正则表达式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-26T23:17:03+08:00">
                2016-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/12/26/《Java编程思想》学习笔记之正则表达式/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之正则表达式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　<strong>字符串操作是计算机程序设计中最常见的行为</strong>。<br>  　　较早之前，Java对字符串的操作主要集中在String、StringBuffer和StringTokenizer中。在JDk1.4版本之后，Java引入了regex工具类，开始提供更为强大功能的正则表达式。<br>    　　<strong>正则表达式是一种强大而灵活的文本处理工具</strong>，它提供了一种完全通用的方式，能够解决各种字符串处理相关的问题，如匹配、选择、编辑和验证。<br>      　　本章要点：</p>
<ul>
<li>正则表达式的基础知识</li>
<li>regex工具类与Pattern、Match</li>
<li>Pattern和Matcher类的常用方法</li>
<li>正则表达式与Scanner</li>
<li>总结<h2 id="1-正则表达式的基础知识"><a href="#1-正则表达式的基础知识" class="headerlink" title="1.正则表达式的基础知识"></a><strong>1.正则表达式的基础知识</strong></h2>　　正则表达式就是一种模糊匹配的原则。比如，我们需要表示“一个负号，后面跟着以为或多位数字”，可以用 “-\d+”表示。在Java中，\表示转义字符，\d表示0到9的数字，+则表示一个或多个前面的值。<br>　　对于Java而言，其正则表达式的语法是构建正则表达式的基础，在这里做一个总结。</li>
</ul>
<p><strong>字符表</strong><br>| 字符代码   |    含义 |<br>| — | — |<br>|  B   |  指定字符B   |<br>|   \xhh  |   十六进制值为oxhh的字符  |<br>|  \t   |  制表符Tab   |<br>|  \n   | 换行符    |<br>|  \r   | 回车    |<br>|  \f   | 换页    |<br>|  \e   | 转义    |<br><strong>字符类表</strong></p>
<table>
<thead>
<tr>
<th>字符代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任意字符</td>
</tr>
<tr>
<td>[abc]</td>
<td>包含a、b、c的任何字符</td>
</tr>
<tr>
<td>[^abc]</td>
<td>除了a、b、c之外的任何字符（否定）</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>除了a到z或A到Z的任何字符</td>
</tr>
<tr>
<td>[abc[hij]]</td>
<td>任意a、b、c、h、i、j字符（合并）</td>
</tr>
<tr>
<td>[abc&amp;&amp;[hij]</td>
<td>任意h、i、j(交集)</td>
</tr>
<tr>
<td>\s</td>
<td>空白符（空格、制表、换行、换页和回车）</td>
</tr>
<tr>
<td>\S</td>
<td>非空白符</td>
</tr>
<tr>
<td>\d</td>
<td>数字【0-9】</td>
</tr>
<tr>
<td>\D</td>
<td>非数字【0-9】</td>
</tr>
<tr>
<td>\w</td>
<td>词字符[a-zA-Z0-9]</td>
</tr>
<tr>
<td>\W</td>
<td>非词字符</td>
</tr>
</tbody>
</table>
<p><strong>逻辑操作符表</strong></p>
<table>
<thead>
<tr>
<th>逻辑符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>XY</td>
<td>Y跟在X后面</td>
</tr>
<tr>
<td>X</td>
<td>Y</td>
<td>X或Y</td>
</tr>
<tr>
<td>（X）</td>
<td>捕获组</td>
</tr>
</tbody>
</table>
<p><strong>边界匹配符表</strong></p>
<table>
<thead>
<tr>
<th>边界符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>一行的开始</td>
</tr>
<tr>
<td>$</td>
<td>一行的结束</td>
</tr>
<tr>
<td>\b</td>
<td>词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>非词的边界</td>
</tr>
<tr>
<td>\G</td>
<td>前一个匹配符的结束</td>
</tr>
</tbody>
</table>
<p><strong>量词表</strong></p>
<table>
<thead>
<tr>
<th>量词</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>X？</td>
<td>一个或零个X</td>
</tr>
<tr>
<td>X</td>
<td>零个或多个X</td>
</tr>
<tr>
<td>X+</td>
<td>一个或多个X</td>
</tr>
<tr>
<td>X{n}</td>
<td>恰好n次X</td>
</tr>
<tr>
<td>X{n,}</td>
<td>至少n次X</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X至少n次，但是不超过m次</td>
</tr>
</tbody>
</table>
<p><strong>细节注意</strong>：<br>在其他语言中，\\表示在正则表达式中插入一个普通的（字面意思）的反斜线。而在Java中，\\表示插入一个正则表达式的反斜线，让他后面的字符具有特殊的意义。比如，如果想要表示一个数字，正则表达式为\\d，如果想要插入一个普通的反斜线，则需要表示为\\\\</p>
<h2 id="2-regex工具类与Pattern、Matcher"><a href="#2-regex工具类与Pattern、Matcher" class="headerlink" title="2.regex工具类与Pattern、Matcher"></a><strong>2.regex工具类与Pattern、Matcher</strong></h2><p>　　Java中，正则表达式是在JDK1.4之后，通过导入regex工具包来实现的。java.util.regex是用于匹配字符序列与正则表达式指定模式的类。它提供了两个主要的类，分别是Pattern和matcher.<br>　　<strong>Pattern</strong>:<strong>正则表达式的编译表示形式</strong>。指定为字符串的正则表达式必须首先被编译为此类的实例。然后，可将得到的模式用于创建 Matcher 对象，依照正则表达式，该对象可以与任意字符序列匹配。执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式。<br>  　　<strong>Matcher</strong>:<strong>通过解释 Pattern 对字符串执行匹配操作的引擎</strong>。通过调用模式的 matcher 方法从模式创建匹配器。创建匹配器后，执行匹配操作。<br>    　　两者的主要用法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pattern p = Pattern.compile("a*b");</div><div class="line">Matcher m = p.matcher("aaaaab");</div><div class="line">boolean b = m.matches();</div></pre></td></tr></table></figure>
<p>　　比如，我们需要匹配电话号码，第一位数字是1，第二位是3或5或8，第三位是5或者8，后四位是6665，则可以将正则表达式表示为”1[358][58][0-9]{4}1665”，对已知的电话号码进行匹配，示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">import java.util.regex.*;</div><div class="line"></div><div class="line">public class RegexTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String[] s =&#123;"15510631665","138736321665","15838381667","1583281665"&#125;;</div><div class="line">		String regex = "1[358][58][0-9]&#123;4&#125;1665";</div><div class="line">        Pattern p = Pattern.compile(regex);</div><div class="line">        for(int i =0;i&lt;s.length;i++)&#123;</div><div class="line">        	Matcher m = p.matcher(s[i]);</div><div class="line">        	System.out.println(s[i]+"    "+m.matches());</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">15510631665</span>    true</div><div class="line"><span class="number">138736321665</span>    false</div><div class="line"><span class="number">15838381667</span>    false</div><div class="line"><span class="number">1583281665</span>    false</div></pre></td></tr></table></figure>
<h2 id="3-Pattern和Matcher类的常用方法"><a href="#3-Pattern和Matcher类的常用方法" class="headerlink" title="3.Pattern和Matcher类的常用方法"></a><strong>3.Pattern和Matcher类的常用方法</strong></h2><p>　　当按顺序调用Pattern和Matcher之后，生成的Matcher实例拥有很多方法，通过这些方法，可以对字符串进行更好的操作。<br>  　　首先是matches()方法，lookingAt()方法和find()方法，这三个方法均是用来判断字符串与正则表达式的匹配是否成功，返回的都是Boolean值。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>方法作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>matches()</td>
<td>用来判断整个输入字符串是否匹配正则表达式模式</td>
</tr>
<tr>
<td>lookingAt()</td>
<td>用来判断该字符串的开始部分是否能够匹配模式</td>
</tr>
<tr>
<td>find()</td>
<td>用来在字符串中查找多个匹配项目</td>
</tr>
</tbody>
</table>
<p>　　matches()方法在上一小节中已有接触，find()方法在实际中应用更为广泛。比如，我们要在一个长字符串里面找出有几个和正则表达式匹配的区域，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">import java.util.regex.*;</div><div class="line"></div><div class="line">public class RegexTest2 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String s = "abdskjsaabdjskabdsakabdsjab";</div><div class="line">		int i =0;</div><div class="line">		String regex = "ab";</div><div class="line">		Pattern p = Pattern.compile(regex);</div><div class="line">		Matcher m = p.matcher(s);</div><div class="line">		while(m.find())&#123;</div><div class="line">			System.out.println(m.group());</div><div class="line">			i++;&#125;</div><div class="line">		System.out.println("一共有"+i+"处符合条件的");</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ab</div><div class="line">ab</div><div class="line">ab</div><div class="line">ab</div><div class="line">ab</div><div class="line">一共有<span class="number">5</span>处符合条件的</div></pre></td></tr></table></figure>
<p>lookingAt()用来判断该字符串的开始部分是否能够匹配模式 ,如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">import java.util.regex.*;</div><div class="line"></div><div class="line">public class RegexTest3 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String s1 = "abdskjsaabdjskabdsakabdsjab";</div><div class="line">		String s2 = "acdskjsaabdjskabdsakabdsjab";</div><div class="line">		String regex = "ab";</div><div class="line">		Pattern p = Pattern.compile(regex);</div><div class="line">		Matcher m1 = p.matcher(s1);</div><div class="line">		Matcher m2 = p.matcher(s2);</div><div class="line">		System.out.println(m1.lookingAt());</div><div class="line">		System.out.println(m2.lookingAt());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">false</div></pre></td></tr></table></figure>
<p>　　在Java中，一个重要的概念就是组。组是用括号划分的正则表达式，可以根据组的编号来引用某个组。组号0表示整个表达式，组号1表示被第一队括号括起来的组，比如，对于A（B（C））D而言，组号0就是ABCD，组号1是BC，组号2是C。如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">import java.util.regex.*;</div><div class="line"></div><div class="line">public class RegexTest4 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String s = "abdskjsaabdjskabdsakabdsjab";</div><div class="line">		String regex = "(a(b))d";</div><div class="line">		Pattern p = Pattern.compile(regex);</div><div class="line">		Matcher m = p.matcher(s);</div><div class="line">		while(m.find())</div><div class="line">			System.out.println(m.group(0)+","+m.group(1)+","+m.group(2));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">abd,ab,<span class="selector-tag">b</span></div><div class="line">abd,ab,<span class="selector-tag">b</span></div><div class="line">abd,ab,<span class="selector-tag">b</span></div><div class="line">abd,ab,b</div></pre></td></tr></table></figure>
<p>　　Matcher中，有两个方法可以返回匹配位置的索引值，分别是start()和end()，简单的用法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">import java.util.regex.*;</div><div class="line"></div><div class="line">public class RegexTest5 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String s = "abdskjsaabdjskabdsakabdsjab";</div><div class="line">		int i =0;</div><div class="line">		String regex = "ab";</div><div class="line">		Pattern p = Pattern.compile(regex);</div><div class="line">		Matcher m = p.matcher(s);</div><div class="line">		while(m.find())</div><div class="line">			System.out.println("find  '"+m.group()+"'   start="+m.start()+"   end="+m.end());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">find  'ab'   start=0   end=2</div><div class="line">find  'ab'   start=8   end=10</div><div class="line">find  'ab'   start=14   end=16</div><div class="line">find  'ab'   start=20   end=22</div><div class="line">find  'ab'   start=25   end=27</div></pre></td></tr></table></figure>
<p>　　在Pattern类中，有几个标记方法十分有用，分别如下：</p>
<table>
<thead>
<tr>
<th>编译标记</th>
<th>表示效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pattern.CASE_INSENSITIVE(?i)</td>
<td>这个标记允许模式匹配不考虑大小写</td>
</tr>
<tr>
<td>Pattern.COMMENTS(?x)</td>
<td>这个标记表示忽略空格符</td>
</tr>
<tr>
<td>Pattern.DOTALL(?s)</td>
<td>在该模式下，“.”匹配包括行终结符在内的所有字符</td>
</tr>
<tr>
<td>Pattern.MULTILINE(?m)</td>
<td>多行模式，^和＄表示匹配一行的开始和结束</td>
</tr>
</tbody>
</table>
<p>使用方式可以为如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pattern p = Pattern.compile("(?i)XuWei");</div></pre></td></tr></table></figure>
<p>也可以如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pattern p = Pattern.compile("XuWei"，Pattern.CASE_INSENSITIVE);</div></pre></td></tr></table></figure>
<p>　　可以通过正则表达式对将输入字符串断开为字符串对象数组，方法为split(),两种使用方式如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] split(CharSequence input)</div><div class="line">String[] split(CharSequence <span class="selector-tag">input</span>,int limit)</div></pre></td></tr></table></figure>
<p>　　替换操作也是正则表达式的一个非常重要的功能，主要的方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>replaceFirst(String replacement)</td>
<td>替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td>
</tr>
<tr>
<td>replaceAll(String replacement)</td>
<td>替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td>
</tr>
<tr>
<td>appendReplacement(StringBuffer sb, String replacement)</td>
<td>实现非终端添加和替换步骤。</td>
</tr>
<tr>
<td>appendTail(StringBuffer sb)</td>
<td>实现终端添加和替换步骤。</td>
</tr>
</tbody>
</table>
<p>replaceFirst()和replaceAll()是String类自带的方法，一般是直接使用，而不是将它编译为Pattern，这样也能节省开销。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">public class RegexTest6 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String s = "abdskjsaabdjskabdsakabdsjab";</div><div class="line">		s=s.replaceFirst("ab", "AB");</div><div class="line">		System.out.println(s);</div><div class="line">		</div><div class="line">		s=s.replaceAll("ab","CD");</div><div class="line">		System.out.println(s);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ABdskjsaabdjskabdsakabdsjab</div><div class="line">ABdskjsaCDdjskCDdsakCDdsjCD</div></pre></td></tr></table></figure>
<p>　　replaceFirst()和replaceAll()只能对普通的字符串进行替换，如果想要对替换的字符串进行特殊操作，就必须使用appendReplacement()方法。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">import java.util.regex.*;</div><div class="line"></div><div class="line">public class RegexTest7 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String s = "abdskjsaabdjskabdsakabdsjab";</div><div class="line">		String regex = "ab";</div><div class="line">		StringBuffer sbuf = new StringBuffer();</div><div class="line">		Pattern p = Pattern.compile(regex);</div><div class="line">		Matcher m = p.matcher(s);</div><div class="line">		while(m.find())</div><div class="line">			m.appendReplacement(sbuf, m.group().toUpperCase());</div><div class="line">		m.appendTail(sbuf);</div><div class="line">		System.out.println(sbuf);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ABdskjsaABdjskABdsakABdsjAB</div></pre></td></tr></table></figure>
<p>　　先构造sbuf用来保存最终结果，然后选择目标字符串的一个组，对他进行处理（小写转大写），然后调用appendTail()方法，将剩余未处理的部分存入sbuf,然后再进行输出。<br>  　　reset()方法也是常用的一个方法，能够重置匹配器。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">import java.util.regex.*;</div><div class="line"></div><div class="line">public class RegexTest8 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String s = &quot;there is a dog&quot;;</div><div class="line">		String regex = &quot;[dsp][iou][gs]&quot;;</div><div class="line">		Pattern p = Pattern.compile(regex);</div><div class="line">		Matcher m = p.matcher(s);</div><div class="line">		while(m.find())</div><div class="line">			System.out.println(m.group());</div><div class="line">		m.reset(&quot;there is a pig&quot;);</div><div class="line">		while(m.find())</div><div class="line">			System.out.println(m.group());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dog</div><div class="line">pig</div></pre></td></tr></table></figure>
<p>　　此例中，使用的是带有参数的reset()方法，将现有的Matcher对象应用于一个新的字符序列。如果不带参数，则是将Matcher对象重新设置到当前字符序列的起始位置。</p>
<h2 id="4-正则表达式与Scanner"><a href="#4-正则表达式与Scanner" class="headerlink" title="4.正则表达式与Scanner"></a><strong>4.正则表达式与Scanner</strong></h2><p>　　Scanner是一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。 Scanner 使用分隔符模式将其输入分解为标记，<strong>默认情况下该分隔符模式与空白匹配，我们也可以指定正则表达式为分解标记</strong>。然后可以使用不同的 next 方法将得到的标记转换为不同类型的值。<br> 　　 它主要有两个常用的方法，分别是hasNext()和next().其中，hasNext()返回的是布尔值，next()返回的是字符串。如下唉，对一组数据进行识别，利用Scanner进行扫描出满足条件的网址和时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line">import java.util.regex.MatchResult;</div><div class="line"></div><div class="line">public class RegexTest9 &#123;</div><div class="line">	static String data=&quot;58.27.42.161@02/10/2016\n&quot;+&quot;58.23.42.161@03/10/2016\n&quot;+&quot;58.24.42.161@05/10/2016\n&quot;;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Scanner scanner = new Scanner(data);</div><div class="line">		String pattern = &quot;(\\d+[.]\\d+[.]\\d+[.]\\d+)@&quot;+&quot;(\\d&#123;2&#125;/\\d&#123;2&#125;/\\d&#123;4&#125;)&quot;;</div><div class="line">		while(scanner.hasNext(pattern))</div><div class="line">			&#123;</div><div class="line">			scanner.next(pattern);</div><div class="line">		MatchResult match = scanner.match();</div><div class="line">		String ip = match.group(1);</div><div class="line">		String date = match.group(2);</div><div class="line">		System.out.println(&quot;数据的网址为：&quot;+ip+&quot;   &quot;+&quot;数据的时间为：&quot;+date);</div><div class="line">	&#125;	</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">数据的网址为：<span class="number">58.27</span>.<span class="number">42.161</span>   数据的时间为：<span class="number">02</span>/<span class="number">10</span>/<span class="number">2016</span></div><div class="line">数据的网址为：<span class="number">58.23</span>.<span class="number">42.161</span>   数据的时间为：<span class="number">03</span>/<span class="number">10</span>/<span class="number">2016</span></div><div class="line">数据的网址为：<span class="number">58.24</span>.<span class="number">42.161</span>   数据的时间为：<span class="number">05</span>/<span class="number">10</span>/<span class="number">2016</span></div></pre></td></tr></table></figure>
<p>利用Scanner的hasNext()和Next()方法，结合正则表达式，就能够对自己需要的内容进行快速的匹配，按照自己的要求进行输出。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a><strong>5.总结</strong></h2><ul>
<li>正则表达式在JDK1.4之后被引入，是对字符串进行操作的强大工具；</li>
<li>将某字符串指定为正则表达式时，需要先将字符串编译为Pattern类的实例，然后再进行匹配；</li>
<li>regex工具包中只有Pattern和Matcher两个类，正则操作的方式都是基于这两个类的方法，可以通过查询API进行学习；</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/22/《Java编程思想》学习笔记之异常处理/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/22/《Java编程思想》学习笔记之异常处理/" itemprop="url">
                  《Java编程思想》学习笔记之异常处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-22T21:40:39+08:00">
                2016-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/12/22/《Java编程思想》学习笔记之异常处理/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之异常处理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　Java的异常处理机制把“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离，并且采用规定的形式来消除错误过程中随心所欲的因素，增强了代码的健壮性和可阅读性。<br>  　  　本章主要对Java处理方法和常用的方式进行学习，要点如下：</p>
<ul>
<li>Java异常体系与自定义异常</li>
<li>异常捕获的方式</li>
<li>构造方法中的异常处理问题</li>
<li>接口、继承中的异常问题</li>
<li>总结<h2 id="1-Java异常体系与自定义异常"><a href="#1-Java异常体系与自定义异常" class="headerlink" title="1.Java异常体系与自定义异常"></a><strong>1.Java异常体系与自定义异常</strong></h2><h3 id="1-1-Java异常的分类"><a href="#1-1-Java异常的分类" class="headerlink" title="1.1 Java异常的分类"></a><strong>1.1 Java异常的分类</strong></h3>　　在Java中，异常是作为对象来进行处理的。在异常体系中，Throwable是所有异常对象的父类。它有两种继承子类，分别为：</li>
<li><strong>Error</strong>，表示编译时和系统错误，是程序员无法控制的错误，不用进行处理。</li>
<li><strong>Exception</strong>，是可抛出的类型。在程序中定义的方法以及程序运行时都有可能抛出这种异常。这也是Java异常机制主要解决的问题。<br>　　对于Exception而言，它有很多子类，按照特点可以分为两种，分别是<strong>被检查的异常</strong>和<strong>不受检查的异常</strong>。其中，不受检查的异常是RuntimeException，也被称为运行时异常。<br>　　被检查的异常的处理是由编译器强制实施的，当程序出现这样一种类型的异常，只能选择处理或者抛给调用者进行处理，否则，编译过程无法通过。<br> 　　RuntimeException异常有很多子类，如ArithmeticException，NullPointerException，IndexOutOfBoundsException等等。这类异常代表的是编程错误，可以在代码中忽略，不进行异常处理。这是因为他可能代表无法预料的错误，比如从控制范围之外传递进来的null引用；其次，它也可能是程序员应该在代码中进行检查的错误，比如IndexOutOfBoundsException，代表角标越界，需要我们自己检查一下程序数组的大小。<h3 id="1-2-自定义异常"><a href="#1-2-自定义异常" class="headerlink" title="1.2 自定义异常"></a><strong>1.2 自定义异常</strong></h3>　　对于Java异常体系而言，它不可能预测到所有的异常情况，用户可以通过自定义异常来表示程序中可能遇到的特定的问题。只需要继承自一个已有的异常类就行。，如下：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class MyException extends Exception&#123;&#125;</div></pre></td></tr></table></figure>
<p>　　如果我们知道自定义的异常与哪个现有异常更加接近，则可以继承自该异常类，这样可以使异常定位更加精确，如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class MyException extends RuntimeException&#123;&#125;</div></pre></td></tr></table></figure>
<p>　　这样则代表MyException也属于运行时异常的一个子类。<br>　　当自定义的异常继承自已有的异常类时，它会自动调用父类的默认构造方法。当需要把相关信息作为参数传递到构造方法时，就需要用super关键字显式的进行调用，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class MyExcepion extends Exception&#123;</div><div class="line">public MyException ()&#123;&#125;</div><div class="line">public MyException(String msg)&#123;super(msg)&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-异常捕获的方式"><a href="#2-异常捕获的方式" class="headerlink" title="2.异常捕获的方式"></a><strong>2.异常捕获的方式</strong></h2><p>　　异常情形是指阻止当前方法或者作用域继续执行的问题。在当前环境下无法获得必要的信息解决异常情形时，就需要从当前环境跳出，并且把问题抛给上一级环境。<br>  　　当抛出异常之后，将使用new关键字在堆上创建异常对象，随后，正常的程序执行路径终止，异常处理机制接管对象，在异常处理程序中进行异常的处理。<br>   　　 Java中，与异常有关的关键字有try,catch,finally,throw和throws几种。</p>
<h3 id="2-1-throw与throws"><a href="#2-1-throw与throws" class="headerlink" title="2.1 throw与throws"></a><strong>2.1 throw与throws</strong></h3><p>   　　throw关键字用于方法体内部，它用于抛出一个Throwable类型的异常。当一个方法内部使用throw关键字抛出了一个异常之后，方法外部必须进行声明。如果该异常属于被检查的异常，当外部程序调用该方法的时候，就必须对该异常进行处理。要么进行try-catch处理，要么再抛给上层的调用者。一步一步的外抛后，将会由JVM进行处理。<br>     　　throws关键字用于方法体外部，主要用于申明该方法可能抛出的异常。当程序调用该方法时，通过看该方法有无throws关键字抛出的异常，就能够判断是否要对它进行异常处理。两种的使用具体如下的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void method() throws Exception&#123;</div><div class="line">throw new Exception();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-try-catch语句的使用"><a href="#2-2-try-catch语句的使用" class="headerlink" title="2.2 try -catch语句的使用"></a><strong>2.2 try -catch语句的使用</strong></h3><p>　　当我们调用某个方法可能抛出异常时，可以设置一个特殊的块把它包括进去，从而进行异常捕获。因为在这个块里面尝试各种方法调用，因此被称为try块。如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line"><span class="comment">//可能产生异常的方法的调用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　用try块把异常捕获之后，就进行异常的抛出或者处理。当通过异常处理程序对异常进行处理时，用catch关键字来囊括处理程序。如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line"><span class="comment">//可能产生异常的方法的调用</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">catch</span><span class="params">(Exception e)</span></span>&#123;</div><div class="line"><span class="comment">//异常处理程序</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　当try块中可能抛出多个异常对象时，就要用多个catch块进行匹配。catch会找到匹配的异常对象来进行异常的处理。需要注意的是，如果没有找到最匹配的异常类，会自动匹配该异常类的父类来进行异常的处理。如果catch块中有捕获异常的父类Exception时，需要把它放在处理程序列表的末尾。因为如果把捕获父类的catch语句放在最前面，就会把子类的异常给“屏蔽”掉，编译器也会提示报错。<br>  　　当一个异常对象被捕获之后，可以将它再次抛出或者抛出另一种异常，再次捕获时，需要捕获新的异常，程序示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">   package test2;</div><div class="line"></div><div class="line">class Exception1 extends Exception&#123;</div><div class="line">	public Exception1(String s)&#123;super(s);&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Exception2 extends Exception&#123;</div><div class="line">	public Exception2(String s)&#123;super(s);&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Exception3 extends Exception&#123;</div><div class="line">	public Exception3(String s)&#123;super(s);&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A&#123;</div><div class="line">	public static void method1() throws Exception1&#123;</div><div class="line">		throw new Exception1(&quot;throw from method1()&quot;);</div><div class="line">	&#125;</div><div class="line">	public static void method2() throws Exception2&#123;</div><div class="line">		throw new Exception2(&quot;throw from method2()&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class CatchTest &#123;</div><div class="line">	public static void main(String[] args) throws Exception1,Exception3&#123;</div><div class="line">		try&#123;</div><div class="line">			A.method1();	</div><div class="line">		&#125;</div><div class="line">		catch(Exception1 e1)&#123;</div><div class="line">			throw new Exception1(&quot;throw from method1() again&quot;);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		try&#123;</div><div class="line">			A.method2();	</div><div class="line">		&#125;</div><div class="line">		catch(Exception2 e2)&#123;</div><div class="line">			throw new Exception3(&quot;throw from method3() again&quot;);</div><div class="line">		&#125;		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-finally关键字的使用"><a href="#2-3-finally关键字的使用" class="headerlink" title="2.3 finally关键字的使用"></a><strong>2.3 finally关键字的使用</strong></h3><p>　　对于程序中的某些代码，无论是否抛出异常，都希望它们能够被执行，这些代码通常用于关闭资源。通过使用finally关键字，能够达到这一目的，所以完整的异常处理程序通常如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line"><span class="comment">//可能抛出异常A，B，C</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">catch</span><span class="params">(A a)</span></span>&#123;</div><div class="line"><span class="comment">//处理A异常</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">catch</span><span class="params">(B b)</span></span>&#123;</div><div class="line"><span class="comment">//处理B异常</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">catch</span><span class="params">(C c)</span></span>&#123;</div><div class="line"><span class="comment">//处理C异常</span></div><div class="line">&#125;</div><div class="line">finally&#123;</div><div class="line"><span class="comment">//关闭资源</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<strong>当把出内存以外的资源恢复到它们的初始状态的时候，就要用到finally语句。这些资源通常包括：已经打开的文件或者网络连接，在屏幕上画的图形，甚至可能是外界某个开关。</strong><br>  <strong>returned与finally</strong><br>  由于finally语句总是会执行的，所以在一个方法里，能够有多个return返回点，并且可以保证清理工作总是被执行。</p>
<p>  使用finally时，有两种情况会导致异常的丢失。<br>1）finally里面调用的i方法产生的异常覆盖掉了前面一个异常，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Exception1 extends Exception&#123;</div><div class="line">  pubic String toString()&#123;</div><div class="line">  return "Exception1";</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">class Exception2 extends Exception&#123;</div><div class="line">  pubic String toString()&#123;</div><div class="line">  return "Exception2";</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class test&#123;</div><div class="line">  void f() throws Exception1&#123;</div><div class="line">  throw new Exception1();</div><div class="line">&#125;</div><div class="line">void g() throws Exception2&#123;</div><div class="line">  throw new Exception2();</div><div class="line">&#125;</div><div class="line">public static void main(String[] args)&#123;</div><div class="line">  try&#123;</div><div class="line">    Test t = new Test();</div><div class="line">  try&#123;</div><div class="line">    t.f();</div><div class="line">&#125;  fianlly&#123;</div><div class="line">    t.g();</div><div class="line">&#125;</div><div class="line">&#125;  catch(Exception e)&#123;</div><div class="line">       System.out.println(e);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Exception1会被finally里面的Exception2所取代，造成异常i信息的丢失。<br>2）另外一种方法也会造成异常丢失，那就是在finally语句里面使用返回return</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Test3&#123;</div><div class="line">   public static void main(String[] args)&#123;</div><div class="line">      try&#123;</div><div class="line">           throw new RuntimeException;</div><div class="line">      &#125;  finally&#123;</div><div class="line">             return;</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="2-4-异常处理语句的组合方式"><a href="#2-4-异常处理语句的组合方式" class="headerlink" title="2.4 异常处理语句的组合方式"></a><strong>2.4 异常处理语句的组合方式</strong></h3><p>异常处理程序一共有三种组合方式，分别是</p>
<ul>
<li><strong>try{}    catch(){}</strong><br>运行流程是：try块中可能抛出异常，由catch语句进行捕获。<ul>
<li><strong>try{}    catch(){}  finally{}</strong><br>运行流程是：运行到try块中，如果有异常抛出，则转到catch块,catch块执行完毕后，执行finally块的代码，再执行finally块后面的代码。如果没有异常抛出，也会正常执行finally块的代码，再执行finally块后面的代码。</li>
<li><strong>try{}   finally{}</strong><br>运行流程是：程序没有捕获异常，就必须在调用方法处采用throws关键字进行声明。运行到try块中,如果有异常抛出的话，程序转向执行finally块的代码。finally块后面的代码不会被执行。程序以异常机制终止。<h2 id="3-构造方法中的异常处理问题"><a href="#3-构造方法中的异常处理问题" class="headerlink" title="3.构造方法中的异常处理问题"></a><strong>3.构造方法中的异常处理问题</strong></h2>　　异常限制对于构造方法不起作用，也就是说子类的构造方法可以抛出任何异常，而不必在意父类构造方法中是否抛出了这个异常，但是子类的构造方法所抛出的异常必须包含父类构造方法所声明的异常。<br>　　子类的构造方法不能捕获父类构造方法中抛出来的异常。<h2 id="4-接口、继承中的异常问题"><a href="#4-接口、继承中的异常问题" class="headerlink" title="4.接口、继承中的异常问题"></a><strong>4.接口、继承中的异常问题</strong></h2>　　当子类继承父类并覆盖父类的方法时，只能抛出在父类方法的异常说明里列出的那些异常，也可以不抛出异常。这样的限制，使得父类使用的代码应用到其子类对象时，一样可以进行工作。<br>　　需要注意的是，异常说明本身并不属于方法类型的一部分，方法类型是由方法名和参数列表组成的。所以不能基于异常说明和重载方法。<br>　　如果一个类同时继承了一个父类和实现了一个接口，且父类和接口中有相同的方法，那么接口里面的方法就不能改变在父类中同名方法的一场接口。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package test2;</div><div class="line">class ExceptionA extends Exception&#123;&#125;</div><div class="line">class ExceptionB extends Exception&#123;&#125;</div><div class="line"></div><div class="line">abstract class Inning&#123;</div><div class="line">	public Inning() throws ExceptionA&#123;&#125;</div><div class="line">	public void method() throws ExceptionA&#123;&#125;</div><div class="line">&#125;</div><div class="line">interface Storm&#123;</div><div class="line">	public void method() throws ExceptionB;</div><div class="line">	public void say() throws ExceptionB;</div><div class="line">&#125;</div><div class="line">public class StormyInning extends Inning implements Storm&#123;</div><div class="line">     public void method() throws ExceptionB&#123;&#125;</div><div class="line">     	public void say() throws ExceptionB&#123;&#125;;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>　　如上，如果抽象类Inning的method()方法抛出的是ExceptionA，而接口Storm中method()方法抛出的是ExceptionB，那么当StormyInning类继承Inning类并实现Storm接口时，编译器就会报错。如果接口中的方法不存在与父类中，如say()方法，那么该方法可以抛出任意的异常。<br>　　在继承和覆盖过程中，某个特定方法的异常说明不是变大了，而是变小了，这和继承时的情形相反。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a><strong>5.总结</strong></h2><ul>
<li>Java的异常处理机制把程序运行代码和异常处理代码分离，使得程序员可以集中精力处理要解决的问题</li>
<li>Java异常中我们主要处理的是受检查的异常，当调用含有异常的方法时，要么处理，要么再次抛出</li>
<li>try-catch-finally是异常处理的基本语句，需要根据需要进行选择使用</li>
<li>构造方法中的异常覆盖问题同基本方法的异常覆盖问题不一样，作为构造方法，子类抛出的异常必须是父类抛出异常的超集　　</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/20/《Java编程思想》学习笔记之容器基础/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/20/《Java编程思想》学习笔记之容器基础/" itemprop="url">
                  《Java编程思想》学习笔记之容器基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-20T22:34:52+08:00">
                2016-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/12/20/《Java编程思想》学习笔记之容器基础/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之容器基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　容器，顾名思义，就是用来存放东西的。<strong>在Java语言中，容器里面存放的是具体的对象</strong>。我们知道，数组也能够存放对象和基本类型的数据，它是一种很有效的存放方式。但是，数组具有固定的尺寸，而在通常情况下，我们写程序时并不知道需要多少个对象以及如何存储这些对象。为了解决这个问题，Java提供了一套完整的容器类来存储对象。<br>  　　<strong>本篇文章主要概述Java中常用的容器类，并对他们的特点和适用场合做介绍</strong>。<br>    本章要点：</p>
<ul>
<li>容器类的大家庭</li>
<li>容器工具类Arrays和Collections</li>
<li>List接口及其子类</li>
<li>set接口及其子类</li>
<li>map接口及其子类</li>
<li>迭代器iterator</li>
<li>总结<h2 id="1-容器的大家庭"><a href="#1-容器的大家庭" class="headerlink" title="1.容器的大家庭"></a><strong>1.容器的大家庭</strong></h2><img src="./images/rongqi.png" alt="容器" title="rongqi.png"><br>　　如上图所示，容器主要有List，Set，Queue和Map四大类，它们各自又有两到三个实现版本。List，Set，Queue同属Collection接口，它指的是保存单一的元素，而Map指的是保存相关联的键值对。Java集合中还有两个工具类，分别是Arrays和Collections.<h2 id="2-容器工具类Arrays和Collections"><a href="#2-容器工具类Arrays和Collections" class="headerlink" title="2. 容器工具类Arrays和Collections"></a><strong>2. 容器工具类Arrays和Collections</strong></h2>　 Arrays和Collections都是java.util包下面的工具类，两者都能在Collection中添加一组元素。<br>　 Arrays.asList()方法接收一个数组或者是一个用逗号分隔的元素列表，并将它转换为List对象；<br>　Collections.addAll()方法接收一个Collection对象，一个数组，或者是一个用逗号分隔的列表，将元素添加到Collection中。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package CollectionTest;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class AddingGroups &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//Arrays.asList()方法接收元素列表，并转成List</div><div class="line">		//collection的子类ArrayList的构造器，可以接收另一个Collection用来初始化自己。</div><div class="line">		Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;(Arrays.asList(1,2,3,4,5));</div><div class="line">		</div><div class="line">		//Arrays.asList()方法接收一个数组，并转成List</div><div class="line">		//Collections.addAll()接受一个Collection对象</div><div class="line">		Integer[] moreInts = &#123;6,7,8,9,10&#125;;</div><div class="line">		Collections.addAll(Arrays.asList(moreInts));</div><div class="line">		</div><div class="line">		//Collections.addAll()接受一个元素列表，并将它添加到Collection中；</div><div class="line">		Collections.addAll(collection,11,12,13,14,15);</div><div class="line">		</div><div class="line">		//Collections.addAll()接受一个数组，并将它添加到Collection中；</div><div class="line">		Collections.addAll(collection,moreInts);</div><div class="line">		</div><div class="line">		//Arrays.asList()方法接收元素列表,将它直接当成List,不装入Collection容器</div><div class="line">		List&lt;Integer&gt; list = Arrays.asList(16,17,18,19,20);</div><div class="line">		list.set(1, 32);</div><div class="line">		list.add(47);//运行时报错</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　需要注意的地方：<br>  　　a.可以直接使用Arrays.List()方法的输出当成List。但是，这种情况下的底层是数组，不能够调整尺寸如果尝试增加或者删除元素，就会在运行时报错；<br>　　b.Arrays.List()方法有一个限制，那就是它对所产生的List类型做了理想的假设，有时会造成错误。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Fu&#123;&#125;</div><div class="line">class Zi1 extends Fu&#123;&#125;</div><div class="line">class Sun1 extends Zi1&#123;&#125;</div><div class="line">class Sun2 extends Zi1&#123;&#125;</div><div class="line">class Zi2 extends Fu&#123;&#125;</div><div class="line">class  Zi3 extends Fu&#123;&#125;</div><div class="line"></div><div class="line">public class AsListDemo &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		List&lt;Fu&gt; fu1 = Arrays.asList(new Zi1(),new Zi2(),new Zi3());</div><div class="line">		</div><div class="line">		//Type mismatch: cannot convert from List&lt;Zi1&gt; to List&lt;Fu&gt;</div><div class="line">		List&lt;Fu&gt; fu2 = Arrays.asList(new Sun1(),new Sun2());</div><div class="line">		</div><div class="line">		List&lt;Fu&gt; fu3 = new ArrayList&lt;Fu&gt;();</div><div class="line">		Collections.addAll(fu3,new Sun1(),new Sun2());</div><div class="line">        </div><div class="line">		//显式类型参数说明</div><div class="line">		List&lt;Fu&gt; fu4 = Arrays.&lt;Fu&gt;asList(new Sun1(),new Sun2());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　创建Fu2时，Arrays.asList()中只有Zi1类型，因此它会创建List&lt; Zi1&gt;，而与设定的List&lt; Fu&gt;不匹配。</p>
<h2 id="3-List接口及其子类"><a href="#3-List接口及其子类" class="headerlink" title="3. List接口及其子类"></a><strong>3. List接口及其子类</strong></h2><p>　<strong>List是有序的Collection</strong>，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组，<strong>List允许有相同的元素</strong>。<br> 　<strong>List继承自Collection，并添加了额外的功能，它主要有两种实现类，分别是ArrayList和LinkedList</strong>。它们主要有以下几点不同。<br>  　1.ArrayList底层的数据结构是动态数组，而LinkedList底层的数据结构是链表。<br>  　2.当在列表的元素中间频繁的进行插入和删除操作时，LinkedList效率比ArrayList效率高。<br>  　　这是由它们底层的数据结构决定的。当进行插入或者删除操作时，对于ArrayList而言，找到对应位置进行插入或删除时，其后面的元素都要进行位置的改变，消耗的时间较长；对于LinkedList而言，由于是链表结构，在进行插入或删除时，找到目标位置后，只需要把前后两个元素的节点指向进行调整，不需要改变其他元素的位置。<br>   　3.当对列表元素进行随机访问时，ArrayList的效率要比LinkedList高。<br>   　　这是因为ArrayList的底层结构是数组，给到需要访问的位置值后，就能够直接快速的定位到指定位置。而LinkedList的底层结构是链表，每个元素只有相邻两个位置的内存信息，当我们进行访问时，就需要传递式的访问，速度较慢。</p>
<h2 id="4-set接口及其子类"><a href="#4-set接口及其子类" class="headerlink" title="4.set接口及其子类"></a><strong>4.set接口及其子类</strong></h2><p>　<strong>Set是一种不包含重复的元素的Collection</strong>，它会组织我们将相同对象的多个实例加入其中。利用Set能够很容易的测试某个对象是否存在其中，这是是它最常被用到的地方。<br> 　Set与Collection有相同的接口,只是行为不一致。它有两个主要的实现类，分别是HashSet和TreeSet。<br>  　关于HashSet和TreeSet，通过下面的两个例子进行解释。</p>
<p>HashSet存储<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package CollectionTest;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class HashSetTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Random rand = new Random(47);</div><div class="line">		Set&lt;Integer&gt; intset= new HashSet&lt;Integer&gt;();</div><div class="line">		for(int i = 0;i&lt;1000;i++)</div><div class="line">			intset.add(rand.nextInt(30));</div><div class="line">		System.out.print(intset);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">24</span>, <span class="number">27</span>, <span class="number">26</span>, <span class="number">29</span>, <span class="number">28</span>]</div></pre></td></tr></table></figure>
<p>TreeSet存储：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package CollectionTest;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class TreeSetTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Random rand = new Random(47);</div><div class="line">		Set&lt;Integer&gt; intset= new TreeSet&lt;Integer&gt;();</div><div class="line">		for(int i = 0;i&lt;1000;i++)</div><div class="line">			intset.add(rand.nextInt(30));</div><div class="line">		System.out.print(intset);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>]</div></pre></td></tr></table></figure>
<p>　　从程序运行结果可以看出，作为Set集合的子类，HashSet和TreeSet中是不允许有重复元素的。其次，HashSet输出的顺序没有规律可循，而TreeSet的输出则是按照从小到大的顺序来排列的。<br>　　HashSet存储数据的方式是散列函数，而TreeSet存储数据的方式是红黑树。这也是他们输出元素顺序不同的原因。</p>
<h2 id="5-Map接口及其子类"><a href="#5-Map接口及其子类" class="headerlink" title="5.Map接口及其子类"></a><strong>5.Map接口及其子类</strong></h2><p>　Collection保存单一的元素，而Map则是保存相关联的键值对。Map是一种将对象与对象相关联的设计。它的子类HashMap主要设计用来实现快速访问的；TreeMap则是保持键始终处于排序状态；LinkedHashMap保持元素插入的顺序，但是也通过散列函数提供了快速访问的能力。<br> 可以通过示例进行比较。如下：<br> 用HashMap进行存储</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package CollectionTest;</div><div class="line">import java.util.*;</div><div class="line">public class MapTest &#123;</div><div class="line">  </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Random rand = new Random(47);</div><div class="line">		Map&lt;Integer,Integer&gt; m = new HashMap&lt;Integer,Integer&gt;();</div><div class="line">		for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			int key = rand.nextInt(20);</div><div class="line">			Integer value=m.get(key);</div><div class="line">			m.put(key, value==null?1:value+1);	</div><div class="line">		&#125;</div><div class="line">		System.out.println(m);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="number">0</span>=<span class="number">42</span>, <span class="number">1</span>=<span class="number">44</span>, <span class="number">2</span>=<span class="number">53</span>, <span class="number">3</span>=<span class="number">43</span>, <span class="number">4</span>=<span class="number">44</span>, <span class="number">5</span>=<span class="number">53</span>, <span class="number">6</span>=<span class="number">42</span>, <span class="number">7</span>=<span class="number">53</span>, <span class="number">8</span>=<span class="number">46</span>, <span class="number">9</span>=<span class="number">56</span>, <span class="number">10</span>=<span class="number">58</span>, <span class="number">11</span>=<span class="number">55</span>, <span class="number">12</span>=<span class="number">48</span>, <span class="number">13</span>=<span class="number">55</span>, <span class="number">14</span>=<span class="number">52</span>, <span class="number">15</span>=<span class="number">50</span>, <span class="number">17</span>=<span class="number">50</span>, <span class="number">16</span>=<span class="number">53</span>, <span class="number">19</span>=<span class="number">52</span>, <span class="number">18</span>=<span class="number">51</span>&#125;</div></pre></td></tr></table></figure>
<p>用TreeMap进行存储</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package CollectionTest;</div><div class="line">import java.util.*;</div><div class="line">public class MapTest &#123;</div><div class="line">  </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Random rand = new Random(47);</div><div class="line">		Map&lt;Integer,Integer&gt; m = new TreeMap&lt;Integer,Integer&gt;();</div><div class="line">		for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			int key = rand.nextInt(20);</div><div class="line">			Integer value=m.get(key);</div><div class="line">			m.put(key, value==null?1:value+1);	</div><div class="line">		&#125;</div><div class="line">		System.out.println(m);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="number">0</span>=<span class="number">42</span>, <span class="number">1</span>=<span class="number">44</span>, <span class="number">2</span>=<span class="number">53</span>, <span class="number">3</span>=<span class="number">43</span>, <span class="number">4</span>=<span class="number">44</span>, <span class="number">5</span>=<span class="number">53</span>, <span class="number">6</span>=<span class="number">42</span>, <span class="number">7</span>=<span class="number">53</span>, <span class="number">8</span>=<span class="number">46</span>, <span class="number">9</span>=<span class="number">56</span>, <span class="number">10</span>=<span class="number">58</span>, <span class="number">11</span>=<span class="number">55</span>, <span class="number">12</span>=<span class="number">48</span>, <span class="number">13</span>=<span class="number">55</span>, <span class="number">14</span>=<span class="number">52</span>, <span class="number">15</span>=<span class="number">50</span>, <span class="number">16</span>=<span class="number">53</span>, <span class="number">17</span>=<span class="number">50</span>, <span class="number">18</span>=<span class="number">51</span>, <span class="number">19</span>=<span class="number">52</span>&#125;</div></pre></td></tr></table></figure>
<p>用LinkedHashSet存储：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package CollectionTest;</div><div class="line">import java.util.*;</div><div class="line">public class MapTest &#123;</div><div class="line">  </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Random rand = new Random(47);</div><div class="line">		Map&lt;Integer,Integer&gt; m = new LinkedHashMap&lt;Integer,Integer&gt;();</div><div class="line">		for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			int key = rand.nextInt(20);</div><div class="line">			Integer value=m.get(key);</div><div class="line">			m.put(key, value==null?1:value+1);	</div><div class="line">		&#125;</div><div class="line">		System.out.println(m);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="number">18</span>=<span class="number">51</span>, <span class="number">15</span>=<span class="number">50</span>, <span class="number">13</span>=<span class="number">55</span>, <span class="number">1</span>=<span class="number">44</span>, <span class="number">9</span>=<span class="number">56</span>, <span class="number">8</span>=<span class="number">46</span>, <span class="number">0</span>=<span class="number">42</span>, <span class="number">2</span>=<span class="number">53</span>, <span class="number">7</span>=<span class="number">53</span>, <span class="number">11</span>=<span class="number">55</span>, <span class="number">16</span>=<span class="number">53</span>, <span class="number">4</span>=<span class="number">44</span>, <span class="number">3</span>=<span class="number">43</span>, <span class="number">6</span>=<span class="number">42</span>, <span class="number">10</span>=<span class="number">58</span>, <span class="number">14</span>=<span class="number">52</span>, <span class="number">12</span>=<span class="number">48</span>, <span class="number">5</span>=<span class="number">53</span>, <span class="number">17</span>=<span class="number">50</span>, <span class="number">19</span>=<span class="number">52</span>&#125;</div></pre></td></tr></table></figure>
<p>可以看出来，三者的共性是：<br>1）输出形式都是“Key=Value”，且结果用大括号｛｝包起来<br>2）输出的键值对的键值是没有重复的<br>不同点是：<br>1）HashSet输出的方式是无顺序的，TreeMap则是按照键值从小到大排序，而LinkedHashMap则是按照元素插入的顺序进行输出的。</p>
<p>　　Map键值对的值总是与键绑定在一起的，如果把键值对看作一个整体，那么Map映射就与Set集合一样了。事实上，Set的底层实现是Map,Map是要存放两个值，key和value，key不能重复，而Set的实现是存放Map的key，所以Set的值也不能重复。</p>
<h2 id="6-迭代器iterator"><a href="#6-迭代器iterator" class="headerlink" title="6. 迭代器iterator"></a><strong>6. 迭代器iterator</strong></h2><p>　　对于容器而言，最基本的方法有插入元素和取出元素。但是，对于不同的容器类型而言，其操作元素的方式不一样。比如，取出List中的元素，就可以通过get(int index)方法来进行。然而，对于Set和Map而言，它们并没有可供查找的索引值。因此，程序的健壮性和可拓展性就不是很好。<br>  　　为了解决这个问题，Java提供了迭代器来获取集合元素。迭代器是一个对象，他的工作就是遍历并选择序列中的对象，而客户端程序员不必知道该序列底层的数据结构。<br>    iterator的使用主要有以下几点注意<br>    1）<strong>iterator只能够单向移动</strong><br>    2）使用iterator()要求容器返回一个iterator，它将准备好返回序列的第一个元素。<br>    3）使用迭代器的next()方法能够获得集合中的下一个元素。<br>    4）使用hasNext()检查集合中是否还有元素，返回的是布尔值。<br>    5）<strong>使用removed()将迭代器新近返回的元素删除，在调用remove()之前必须要先调用next()</strong>。如果连续两次调用remove()方法，就会报错。<br>    如下示例用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package CollectionTest;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class iteratorTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">		list.add(&quot;aaa&quot;);</div><div class="line">		list.add(&quot;bbb&quot;);</div><div class="line">		list.add(&quot;ccc&quot;);</div><div class="line">		list.add(&quot;ddd&quot;);</div><div class="line">		list.add(&quot;eee&quot;);</div><div class="line">		list.add(&quot;fff&quot;);</div><div class="line"></div><div class="line">       Iterator&lt;String&gt; its=list.iterator();</div><div class="line">       while(its.hasNext())&#123;</div><div class="line">    	   String it=its.next();</div><div class="line">    	   System.out.print(it+&quot;   &quot;);</div><div class="line">       &#125;</div><div class="line">       its=list.iterator();</div><div class="line">       for(int i=0;i&lt;3;i++)&#123;</div><div class="line">    	   its.next();</div><div class="line">    	   its.remove();</div><div class="line">       &#125;</div><div class="line">	   System.out.print(&quot;删除后的集合为&quot;+list);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aaa   bbb   ccc   ddd   eee   fff   删除后的集合为[ddd, eee, fff]</div></pre></td></tr></table></figure>
<p>另外需要注意的是，对于Map映射集而言，不能直接用迭代器。必须首先将其转换为Set集，然后才能再用迭代器。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package CollectionTest;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class MapIteratorTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;();</div><div class="line">		map.put("1", "zhangsan");</div><div class="line">		map.put("2", "lisi");</div><div class="line">		map.put("3", "wangwu");</div><div class="line"></div><div class="line">		Iterator&lt;Map.Entry&lt;String, String&gt;&gt; its=map.entrySet().iterator();</div><div class="line">		</div><div class="line">	   while(its.hasNext())&#123;</div><div class="line">		  Map.Entry&lt;String, String&gt; it= its.next();</div><div class="line">		  System.out.println("键为"+it.getKey()+" "+"值为"+it.getValue());</div><div class="line">	   &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">键为<span class="number">3</span> 值为wangwu</div><div class="line">键为<span class="number">2</span> 值为lisi</div><div class="line">键为<span class="number">1</span> 值为zhangsan</div></pre></td></tr></table></figure>
<p><strong>关于foreach和iterator</strong><br>foreach语法主要用于数组，但是它也可以用在Collection中，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package CollectionTest;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class iteratorTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">		list.add("aaa");</div><div class="line">		list.add("bbb");</div><div class="line">		list.add("ccc");</div><div class="line">		list.add("ddd");</div><div class="line">		list.add("eee");</div><div class="line">		list.add("fff");</div><div class="line"></div><div class="line">       for(String l:list)</div><div class="line">	   System.out.println(l);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这是因为在Java SE5之后引入了Iterable接口，它被foreach用来在序列中移动，它包含产生iterator的iterator()方法。如果创建了实现Iterable接口的类，都可以用foreach语法，所有的Collection类都实现了这个接口。<br>　　Map集合没有实现Iterable，所以不能直接使用foreach方法。必须通过entrySet()产生一个由Map.Entry的元素构成的Set，Set是一个Iterable，因此可以用于foreach循环。foreach在设计模式中的适配器方法中也有应用，以后学习设计模式的时候再学习。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a><strong>7.总结</strong></h2><ul>
<li>数组可以保存对象和基本类型数据，但是一旦生成，容量不可变。而容器很好的解决了这一问题，它为对象的存储提供了统一的模式。</li>
<li>迭代器将遍历操作同底层结构相分离，统一了对容器访问的方式。</li>
<li>尽管容器种类多种多样，经常使用的只有ArrayList，HashSet和HashMap几类，需要根据应用场所进行选用。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/16/《Java编程思想》之内部类/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/16/《Java编程思想》之内部类/" itemprop="url">
                  《Java编程思想》学习笔记之内部类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-16T23:50:45+08:00">
                2016-12-16
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/12/16/《Java编程思想》之内部类/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之内部类">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　<strong>可以将一个类的定义放在另一个类的定义内部，这就是内部类。</strong><br>  　　一个类的内部可以有成员变量和成员方法，根据内部类定义的位置以及用法不同，可以分为四种，即成员内部类，静态内部类，局部内部类以及匿名内部类。每一种内部类都有各自的特点并且在实际的用途。<br>    本章要点：</p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
<li>为什么要使用内部类</li>
<li>内部类的继承和覆盖问题<h2 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a><strong>1.成员内部类</strong></h2>成员内部类的基本使用和方法如下示例：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Outer&#123;</div><div class="line">	private int i =4;</div><div class="line">	class Inner&#123;</div><div class="line">		Inner()&#123;</div><div class="line">			System.out.println("值为"+(++i));</div><div class="line">		&#125;</div><div class="line">		void say()&#123;</div><div class="line">			System.out.println("Hello Word");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public Inner method()&#123;</div><div class="line">		return new Inner();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test_neibu &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">        Outer o = new Outer();</div><div class="line">        o.method().say();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">值为<span class="number">5</span></div><div class="line">Hello Word</div></pre></td></tr></table></figure>
<p>如上所示，在Outer类的内部定义了一个内部类Inner，并在外部类中建立了method方法返回内部类的对象实例，通过该对象完成了对内部类方法的调用。通过这个示例，可以看出来几点：</p>
<ol>
<li>i是Outer类的私有值，内部类可以直接进行访问。这是因为当我们创建内部类对象时，它就会自动捕获一个指向外围对象的引用。</li>
<li>当我们需要调用成员内部类Inner的内部方法时，<strong>首先需要创建外部类的对象，再通过外部类的对象来创建内部类的对象。</strong><br>上述主函数中调用语句也可以书写如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Outer.Inner oi = new Outer().new Inner();</div><div class="line">oi.say();</div></pre></td></tr></table></figure>
<p>得到的结果是一致的。<br>书写格式为：<strong>外部类.内部类  对象名 =  外部对象.内部对象</strong></p>
<p>另外，如果我们需要<strong>在内部类中生成对外部类对象的引用，则可以使用：外部类.this 格式。</strong></p>
<p>在上述示例中，可以将内部类用private修饰（一般的类只有包权限和public权限两种），因为不能访问其名字，那么可以隐藏实现的细节。通过在外部类中建立公共的访问方法，可以实现对私有化内部类的操作，如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Outer&#123;</div><div class="line">	private int i =4;</div><div class="line">	private class Inner&#123;</div><div class="line">		Inner()&#123;</div><div class="line">			System.out.println("值为"+(++i));</div><div class="line">		&#125;</div><div class="line">		void say()&#123;</div><div class="line">			System.out.println("Hello Word");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void method()&#123;</div><div class="line">		Inner in = new Inner();</div><div class="line">		in.say();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test_neibu &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">        Outer o = new Outer();</div><div class="line">        o.method();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2.静态内部类"></a><strong>2.静态内部类</strong></h2><p>静态内部类也是成员内部类的一种，只不过多了关键字static。在普通的成员内部类中，隐式的存在了一个指向外部类的引用。而当内部类为static时，就没有了该引用。静态内部类也就有了如下的两个特点：</p>
<ol>
<li><strong>创建静态内部类的对象，不需要首先创建外部类的对象</strong>。因为此时内部类对象和外部类对象没有联系。类似于类中的静态方法，静态方法属于类方法，调用时不需要创建类的对象来调用。</li>
<li><strong>不能从静态内部类的对象中访问非静态的外部类对象</strong>。这和加载机制有关，静态的加载总是早于实例对象的。<br>示例代码如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Outer&#123;</div><div class="line">	static int i =4;</div><div class="line">	static class Inner&#123;</div><div class="line">		Inner()&#123;</div><div class="line">			System.out.println("值为"+(++i));</div><div class="line">		&#125;</div><div class="line">		static void say()&#123;</div><div class="line">			System.out.println("Hello Word");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void method()&#123;</div><div class="line">		Inner.say();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test_neibu &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">       Outer.method();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello Word</div></pre></td></tr></table></figure>
<p>可以看出，Method（）方法中是直接对内部类进行调用的，没有创建对象。另一个证明就是，构造方法并没有执行，直接执行的是静态方法。<br>静态内部类里面只允许调用外部类静态成员，尽管构造方法中的i没有被执行，但是如果不把i设置成静态，会有如下的错误提示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cannot make <span class="selector-tag">a</span> static reference to the non-static field i</div></pre></td></tr></table></figure>
<h2 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3. 局部内部类"></a><strong>3. 局部内部类</strong></h2><p>　　可以在方法里面或者任意的作用域里面定义内部类，这种就被称作局部内部类。<br>  如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//定义一个接口</div><div class="line">interface OI&#123;</div><div class="line">	void method();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Outer2&#123;</div><div class="line">	//创建一个方法，返回值为OI类型</div><div class="line">	public OI say()&#123;</div><div class="line">		 //定义一个实现了OI接口的内部类</div><div class="line">		 class Inner2 implements OI&#123;</div><div class="line">			public void method()&#123;System.out.println("Hello World");&#125;</div><div class="line">		&#125;</div><div class="line">	//返回内部类的实例	 </div><div class="line">	return new Inner2();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test_Inner &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Outer2 ot = new Outer2();</div><div class="line">		OI in = ot.say();</div><div class="line">		in.method();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>Inner2类是say()方法里面的一部分，其作用范围仅仅在方法类，在方法之外无法访问这个类。注意，在say()方法里面定义了内部类Inner2()，但是方法执行完毕之后，内部类仍旧可用。<br>内部类还可以嵌入在方法的任意地方，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Outer3&#123;</div><div class="line">	private void Track(boolean f)&#123;</div><div class="line">		if(f)&#123;</div><div class="line">			class Inner3&#123;</div><div class="line">				private String d;</div><div class="line">				Inner3(String s)&#123;</div><div class="line">					d = s;</div><div class="line">				&#125;</div><div class="line">				String getString()&#123;return d;&#125;</div><div class="line">			&#125;</div><div class="line">			Inner3 in = new Inner3("Hello");</div><div class="line">			String ss=in.getString();</div><div class="line">			System.out.println(ss);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void method()&#123;Track(true);&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestInner2 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Outer3 ot = new Outer3();</div><div class="line">		ot.method();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello</div></pre></td></tr></table></figure>
<p>示例中的内部类Inner3就是嵌入在Track（）方法的if语句中的，在这个语句之外，它是不可用的。</p>
<h2 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4.匿名内部类"></a><strong>4.匿名内部类</strong></h2><p>　　上述几个内部类都是有显式的名称的，而匿名内部类则是应用在方法内部，没有名称的内部类。它可以是对类的继承，也可以是对接口的实现。<br>　　当我们在类中定义普通的成员内部类时，我们一般这样写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Outer4&#123;</div><div class="line">	class Inner4 implements OI&#123;</div><div class="line">		private int i=3;</div><div class="line">		public void method()&#123;System.out.println("i="+i);&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public OI say()&#123;return new Inner4();&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestInner4 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	   Outer4 ot = new Outer4();</div><div class="line">	   OI oi =ot.say();</div><div class="line">	   oi.method();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们把say()方法中返回值的生成和表示返回值的内部类的定义结合在一起，就可以简化成如下的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">class Outer4&#123;</div><div class="line">	public OI say()&#123;</div><div class="line">		return new OI()&#123;</div><div class="line">			private int i=3;</div><div class="line">			public void method()&#123;System.out.println("i="+i);&#125;	</div><div class="line">		&#125;;	</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestInner4 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	   Outer4 ot = new Outer4();</div><div class="line">	   OI oi =ot.say();</div><div class="line">	   oi.method();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　上面两个代码的功能是一样的，简化之后，内部类的名称被省略了，所以也被称为匿名内部类，它是对OI接口的实现，通过new表达式返回的是向上转型后的IO的实现。<br>  <strong>匿名内部类的一般格式为：   new 普通类或抽象类或接口（）{ }；</strong><br>  　　由于匿名内部类没有名称，因此也就没有可用的构造方法，上述示例中是调用了默认的无参的构造方法。如果需要一个有参的构造方法，需要通过实例初始化的方式：如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">abstract class Base&#123;</div><div class="line">	public Base(int i)&#123;</div><div class="line">		System.out.println(&quot;Base Constructor,i=&quot;+i);</div><div class="line">	&#125;</div><div class="line">	abstract void method();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Outer5&#123;</div><div class="line">	public static Base getBase(int i)&#123;</div><div class="line">		return new Base(i)&#123;</div><div class="line">			&#123;System.out.println(&quot;Inner constractor&quot;);&#125;</div><div class="line">			void method()&#123;</div><div class="line">				System.out.println(&quot;Inside method&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestInner5 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	 Base bs = Outer5.getBase(23);</div><div class="line">	 bs.method();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Base Constructor,i=<span class="number">23</span></div><div class="line">Inner constractor</div><div class="line">Inside method</div></pre></td></tr></table></figure>
<p>在这个示例中，i不要求为final，因为它是被传递到了Base类的构造方法中。</p>
<h2 id="5-为什么要使用内部类"><a href="#5-为什么要使用内部类" class="headerlink" title="5.为什么要使用内部类"></a><strong>5.为什么要使用内部类</strong></h2><p>使用内部类能够有以下的一些好处：<br>1）<strong>实现“多重继承”。</strong><br>每个内部类都能独立的继承自一个类或者实现一个接口，所以无论外围内是否已经继承了某个类或者实现了某个接口，对内部类都没有影响。尤其是对抽象类或者具体的类而言，只有内部类才能实现多重继承，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class A&#123;&#125;</div><div class="line">abstract class B&#123;&#125;</div><div class="line">class C extends A&#123;</div><div class="line">B makeB()&#123;</div><div class="line">return new B()&#123;&#125;;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类C继承了A，再通过匿名内部类继承了抽象类B。<br>2）<strong>内部类可以有多个实例，</strong>每个实例都有自己的状态信息，并且与外围类的对象的状态信息相独立。<br>3）在单个外围类中，可以让多个内部类以不同的方式实现同一个接口或者实现一个类。<br>如下示例所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">interface Animal&#123;</div><div class="line">	void run();</div><div class="line">	void fly();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Outer6&#123;</div><div class="line">    class Dog implements Animal&#123;</div><div class="line">		public void run()&#123;System.out.println("用狗的方式跑步");&#125;</div><div class="line">		public void fly()&#123;System.out.println("用狗的方式飞行");&#125;</div><div class="line">	&#125;</div><div class="line">	class Pig implements Animal&#123;</div><div class="line">		public void run()&#123;System.out.println("用猪的方式跑步");&#125;</div><div class="line">		public void fly()&#123;System.out.println("用猪的方式飞行");&#125;</div><div class="line">	&#125;</div><div class="line">	public Animal makedog()&#123;</div><div class="line">		return new Dog();</div><div class="line">	&#125;</div><div class="line">	public Animal makepig()&#123;</div><div class="line">		return new Pig();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class TestInner6 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Outer6 ot = new Outer6();</div><div class="line">		Animal d = ot.makedog();</div><div class="line">		Animal p = ot.makepig();</div><div class="line">		d.run();</div><div class="line">		p.run();	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">用狗的方式跑步</div><div class="line">用猪的方式跑步</div></pre></td></tr></table></figure>
<p>上面的示例中，两个内部类采用不同的方式实现了同一个接口，如果不采用内部类，那么就只能用同一种方式实现接口，内部类有了更大的灵活性。<br>4）创建内部类对象的时刻并不依赖于外围内对象的创建，对于静态内部类而言是如此。</p>
<h2 id="6-内部类的继承和覆盖问题"><a href="#6-内部类的继承和覆盖问题" class="headerlink" title="6.内部类的继承和覆盖问题"></a><strong>6.内部类的继承和覆盖问题</strong></h2><p><strong>6.1 内部类的继承</strong><br>　　由于内部类的构造方法必须连接到指向其外部类的引用，所以在继承内部类的时候，指向外部类的引用必须被初始化，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Outer&#123;</div><div class="line">   class Inner&#123;&#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public class InheritInner extends Outer.Inner&#123;</div><div class="line">   InheritInner(Outer ot)&#123;</div><div class="line">   ot.super();</div><div class="line">   &#125;</div><div class="line">   public static void main (String[] args)&#123;</div><div class="line">   Outer ot = new Outer();</div><div class="line">   InheritInner ii = new InheritInner(ot);</div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="6-2-内部类的覆盖"><a href="#6-2-内部类的覆盖" class="headerlink" title="6.2 内部类的覆盖"></a><strong>6.2 内部类的覆盖</strong></h2><p>内部类是可以继承的，但是必须要明确的继承哪个内部类，即Outer.Inner。如果不明确的继承，是不能够覆盖原有内部类的方法的。因为那样内部类是两个完全独立的实体，各自在自己的命名空间类。</p>
<p><strong>总结：</strong></p>
<ol>
<li>接口和内部类解决了Java中“多重继承”的问题。</li>
<li>四种内部类有自己各自的用法，匿名内部类语法较为特殊，在设计模式中也有用到，需要重点掌握。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/15/《Java编程思想》学习笔记之接口/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/15/《Java编程思想》学习笔记之接口/" itemprop="url">
                  《java编程思想》学习笔记之接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-15T01:19:04+08:00">
                2016-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/12/15/《Java编程思想》学习笔记之接口/" class="leancloud_visitors" data-flag-title="《java编程思想》学习笔记之接口">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　在现实生活中，我们经常听说接口这个词语。直观的理解就是给外界提供的方法，接口能够提供一种规范。比如，计算机通信中，只要满足通信接口的协议，就可以实现不同机器间的通信。对于程序中的接口来说，也是如此。<br>　　接口比类更加抽象，在介于接口和普通类之间，还有一种抽象类。<br>  　　本章要点：</p>
<ul>
<li>抽象类和抽象方法</li>
<li>接口及接口中的方法和成员变量</li>
<li>java的多继承与多实现</li>
<li>接口的工厂方法<h2 id="1-抽象类和抽象方法"><a href="#1-抽象类和抽象方法" class="headerlink" title="1.抽象类和抽象方法"></a><strong>1.抽象类和抽象方法</strong></h2>当一个方法只有声明而没有方法体的时候，我们就称这种方法为抽象方法，并且用关键字abstract修饰，如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">abstract void method();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　抽象方法没有方法体，以分号结束。包含一个或者多个抽象方法的类就称之为抽象类。<br>  　　抽象类有未实现的抽象方法，不能被实例化，因为所创建出来的对象也无法完成方法的调用。所以当我们尝试进行实例化时，编译系统就会报错。<br>    　　通过继承抽象类，并覆写其中所有的抽象方法，我们就可以创建子类对象了。如果有一个或者多个抽象方法没有被覆写，那么该子类也是抽象类。</p>
<h2 id="2-接口及接口中的方法和成员变量"><a href="#2-接口及接口中的方法和成员变量" class="headerlink" title="2.接口及接口中的方法和成员变量"></a><strong>2.接口及接口中的方法和成员变量</strong></h2><p>　　抽象类中允许有非抽象方法的存在，而接口则是其中的方法全部是抽象的。接口用关键字interface表示，而不是类class。<strong>接口可以表示实现了该特定接口的类看起来都像这样。</strong>但是，具体怎么做，需要其他的类进行实现。<br>  　　如果让一个类遵循某一个接口或者某一组接口，用关键字implements表示，类似于继承中的extends。<br>    如下所示;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">interface dianqi&#123;</div><div class="line">public void start();</div><div class="line">public void stop();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TV implements dianqi&#123;</div><div class="line">public void start()&#123;</div><div class="line">System.out.println(&quot;用遥控器打开电视&quot;);&#125;</div><div class="line">public void stop()&#123;</div><div class="line">System.out.println(&quot;用遥控器关电视&quot;);&#125;</div><div class="line">public static void main(String[] args)&#123;</div><div class="line">TV tv = new TV();</div><div class="line">tv.start();</div><div class="line">tv.stop();&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">用遥控器打开电视</div><div class="line">用遥控器关电视</div></pre></td></tr></table></figure>
<p>接口中的方法都必须拥有最大的权限，所以需要用public修饰，当我们省略了public时，系统也会自动more加上public的。<br>接口中的成员变量也都是默认static和final的，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">interface Circle&#123;</div><div class="line">	double Pi = 3.14;</div><div class="line">&#125;</div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println("圆周率是"+Circle.Pi);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口的成员变量在类第一次加载时就被初始化，成员变量的值储存在接口的静态存储区域内，可以直接通过接口名进行调用。</p>
<h2 id="3-Java的多继承与多实现"><a href="#3-Java的多继承与多实现" class="headerlink" title="3.Java的多继承与多实现"></a><strong>3.Java的多继承与多实现</strong></h2><p><strong>3.1 多继承</strong><br>在学习继承的时候，可以知道Java是只支持单继承的面向对象设计语言。但是，在接口中，是可以实现接口的多继承的。<br>如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">interface A1&#123;</div><div class="line">	void method1();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface B1&#123;</div><div class="line">	void method2();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface C1 extends A1,B1&#123;</div><div class="line">	void method3();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class D implements C1&#123;</div><div class="line">	public void method1()&#123;System.out.println("方法1执行了");&#125;;</div><div class="line">	public void method2()&#123;System.out.println("方法2执行了");&#125;;</div><div class="line">	public void method3()&#123;System.out.println("方法3执行了");&#125;;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public class Test2 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		D d = new D();</div><div class="line">		d.method1();</div><div class="line">		d.method2();</div><div class="line">		d.method3();</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">方法<span class="number">1</span>执行了</div><div class="line">方法<span class="number">2</span>执行了</div><div class="line">方法<span class="number">3</span>执行了</div></pre></td></tr></table></figure>
<p>可以看出，interface C1 extends A1,B1语句能够成功通过编译。并且，继承了A1接口和B1接口之后，C1接口也就自动获得了它们的抽象方法。在这一点上，接口的继承和类的继承比较一致，可以通过继承来进行接口的拓展。<br><strong>3.2多实现</strong><br>一个类只能继承一个类，但是却可以实现多个接口。如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">interface A1&#123;</div><div class="line">	void method1();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface B1&#123;</div><div class="line">	void method2();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class D implements A1,B1&#123;</div><div class="line">	public void method1()&#123;System.out.println("方法1执行了");&#125;;</div><div class="line">	public void method2()&#123;System.out.println("方法2执行了");&#125;;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test2 &#123;</div><div class="line">    public static void a1(A1 a)&#123;a.method1();&#125;</div><div class="line">    public static void b1(B1 b)&#123;b.method2();&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		D d = new D();</div><div class="line">		a1(d);</div><div class="line">		b1(d);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">方法<span class="number">1</span>执行了</div><div class="line">方法<span class="number">2</span>执行了</div></pre></td></tr></table></figure>
<p>　　可以看出，类D实现了两个接口，分别是A1和B2，并覆写了它们的抽象方法。在main函数中，d分别向上转型为A1，B1，实现了功能的复用性。<br>　　通过这个例子，也可以看出使用接口的核心原因：<br>1.能够向上转型为多个父类型，极大的增强了编程的灵活性；<br>2.与抽象类一样，可以防止客户端创建接口的对象。<br><strong>3.3 实现与继承的结合</strong><br>　　还可以通过继承一个具体类和实现多个接口组合在一起，组成一个新的类。有一点原则就是这个具体类必须放在前面，接口放在后面，用逗号隔开，否则，编译会报错。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class A extends B implements C,D&#123;&#125;</div></pre></td></tr></table></figure>
<p><strong>4.接口的工厂方法</strong><br>接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂方法设计模型，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">interface Cycle1&#123;</div><div class="line">	void ride();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface CycleFactory&#123;</div><div class="line">	Cycle1 getCycle();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class UniCycle1 implements Cycle1&#123;</div><div class="line">	public void ride()&#123;System.out.println("UniCycle ride()");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class UniCycleFactory implements CycleFactory&#123;</div><div class="line">	public Cycle1 getCycle()&#123;</div><div class="line">		return new UniCycle1();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BiCycle1 implements Cycle1&#123;</div><div class="line">	public void ride()&#123;System.out.println("BiCycle ride()");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BiCycleFactory implements CycleFactory&#123;</div><div class="line">	public Cycle1 getCycle()&#123;</div><div class="line">		return new BiCycle1();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TriCycle1 implements Cycle1&#123;</div><div class="line">	public void ride()&#123;System.out.println("TriCycle ride()");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TriCycleFactory implements CycleFactory&#123;</div><div class="line">	public Cycle1 getCycle()&#123;</div><div class="line">		return new TriCycle1();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class FactoryTest &#123;</div><div class="line">    public static void run(CycleFactory c)&#123;</div><div class="line">    	Cycle1 cle=c.getCycle();</div><div class="line">    	cle.ride();</div><div class="line">    &#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	 run(new UniCycleFactory());</div><div class="line">	 run(new BiCycleFactory());</div><div class="line">	 run(new TriCycleFactory());</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UniCycle ride()</div><div class="line">BiCycle ride()</div><div class="line">TriCycle ride()</div></pre></td></tr></table></figure>
<p>在工厂对象上调用创建方法，在工厂对象上生成接口的某个实现的对象，通过这种方式可以把代码和接口的实现相分离。</p>
<p><strong>总结：</strong></p>
<ol>
<li>抽象类可以含有非抽象方法，但至少含有一个抽象方法</li>
<li>接口中的方法全部是抽象的，它只提供做什么，具体怎么做需要具体的类去实现</li>
<li>多继承和多实现能够有效的增强代码的拓展性</li>
<li>任何抽象都是基于实际的需求的，可以根据需要构建工厂方法。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/14/《Java编程思想》学习笔记之多态/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/14/《Java编程思想》学习笔记之多态/" itemprop="url">
                  《Java编程思想》学习笔记之多态
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-14T12:31:50+08:00">
                2016-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/12/14/《Java编程思想》学习笔记之多态/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之多态">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　封装，继承，多态是面向对象语言的三个基本特征。封装是通过抽象事物的特征和行为来创建新的数据类型。继承则允许子类对象视为自身类型或者父类型来进行处理。而多态则在继承的基础之上，分离做什么和怎么做，发给父类引用的消息可以由子类对象进行响应。<br>  　　这一章的主要内容：</p>
<ul>
<li>多态的基本使用</li>
<li>有关动态绑定</li>
<li>多态中构造方法的初始化</li>
<li>向上转型与向下转型</li>
<li><p>多态中需要注意的细节</p>
<h2 id="1-多态的基本使用"><a href="#1-多态的基本使用" class="headerlink" title="1.多态的基本使用"></a><strong>1.多态的基本使用</strong></h2><p>　假设有一个Cycle类，它有三个子类，分别是Unicycle,Bicycle和Tricycle，它们都有ride()方法，编写如下的示例：</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">class Cycle&#123;</div><div class="line">	public void ride()&#123;</div><div class="line">		System.out.println("Cycle ride");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Unicycle extends Cycle&#123;</div><div class="line">	public void ride()&#123;</div><div class="line">	System.out.println("Unicycle ride");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bicycle extends Cycle&#123;</div><div class="line">	public void ride()&#123;</div><div class="line">	System.out.println("Bicycle ride");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Tricycle extends Cycle&#123;</div><div class="line">	public void ride()&#123;</div><div class="line">	System.out.println("Tricycle ride");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class PolymorphismTest1 &#123;</div><div class="line">    public static void method(Cycle c)&#123;</div><div class="line">    	c.ride();</div><div class="line">    &#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Cycle c1 = new Unicycle();</div><div class="line">		Cycle c2 = new Bicycle();</div><div class="line">		Cycle c3 = new Tricycle();</div><div class="line">		PolymorphismTest1.method(c1);</div><div class="line">		PolymorphismTest1.method(c2);</div><div class="line">		PolymorphismTest1.method(c3);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Unicycle ride</div><div class="line">Bicycle ride</div><div class="line">Tricycle ride</div></pre></td></tr></table></figure>
<p>　　示例中，静态方法method()接受的是父类Cycle的引用，c1,c2,c3分别指向的是子类的对象，这个三个引用都可以被method ()方法接收。因此，我们只需要在主函数中写一个方法，接收父类引用为参数，而不用单独为子类编写方法，有效的简化了代码。而且如果后续还有子类加入时，主程序不需要做更改，可以直接使用。</p>
<h2 id="2-有关动态绑定"><a href="#2-有关动态绑定" class="headerlink" title="2.有关动态绑定"></a><strong>2.有关动态绑定</strong></h2><p>　　<strong>绑定的定义是将方法调用同方法主体相关联的过程。</strong><br>  　　如果在程序运行前进行绑定就成为前期绑定或者静态绑定，如果在运行时根据对象的类型进行绑定，则称之为后期绑定或者动态绑定。<br>   　　 java中，当方法被static或者final(private属于final)修饰时，则这些方法是静态绑定，否则就是动态绑定。<br>     　　在上述示例中，编译之前，method()方法能够接收父类的引用c1,c2和c3，但是无法确定运行哪一个ride()方法。当程序运行起来时，这三个引用分别绑定各自对应的对象，从而调用各自对象的ride()方法。<br>       　　动态绑定是实现多态的重要基础，它可以<strong>将改变的事物与不变的事物分离开来</strong>。不变的是父类的引用，改变的是子类对象。</p>
<h2 id="3-多态中构造方法的初始化"><a href="#3-多态中构造方法的初始化" class="headerlink" title="3.多态中构造方法的初始化"></a><strong>3.多态中构造方法的初始化</strong></h2><p> 构造方法不同于普通方法，它是隐式static的，它也不具备多态性。构造方法的初始化在继承章节已有讲述，补充的初始化顺序如下：<br> 1）按声明顺序调用静态成员的初始化方法<br> 2）调用父类构造方法，直到最底层<br> 3）按声明顺序调用非静态成员的初始化方法<br> 4）调用子类构造方法的主体<br> 具体的演示代码如下;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">class Meal&#123;</div><div class="line">	Meal()&#123;</div><div class="line">		System.out.println("Meal()");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bread&#123;</div><div class="line">	Bread()&#123;</div><div class="line">		System.out.println("Bread()");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cheese&#123;</div><div class="line">	Cheese()&#123;</div><div class="line">		System.out.println("Cheese()");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Lettuce&#123;</div><div class="line">	Lettuce()&#123;</div><div class="line">		System.out.println("Lettuce()");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Lunch extends Meal&#123;</div><div class="line">	Lunch()&#123;</div><div class="line">		System.out.println("Lunch()");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class PortableLunch extends Lunch&#123;</div><div class="line">	PortableLunch()&#123;</div><div class="line">		System.out.println("PortableLunch()");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class Sandeich extends PortableLunch&#123;</div><div class="line">    private Bread b = new Bread();</div><div class="line">    private Cheese c = new Cheese();</div><div class="line">    private static Lettuce l = new Lettuce();</div><div class="line">    public Sandeich()&#123;		</div><div class="line">    	System.out.println("Sandeich()");</div><div class="line">&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">             new Sandeich();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">Lettuce</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">Meal</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">Lunch</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">PortableLunch</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">Bread</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">Cheese</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">Sandeich</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>　　在继承时，我们已经知道父类的一切要素，这就要求在子类进行初始化时，就必须假定所有父类的成员是有效的。构造方法初始化时，对类中成员的初始化要求也是这样的。</p>
<p>  在构造方法初始化时，有一种比较特殊的情况，那就是在一个构造方法的内部调用正在构造的对象的动态绑定方法。这种情况下，当前构造方法在被调用时，构造方法内部的方法所从属的类是还没有被初始化的，这样可能会导致一些错误。<br>  如下的示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">class Glyph&#123;</div><div class="line">	void draw()&#123;</div><div class="line">		System.out.println("Gltph draw(");</div><div class="line">	&#125;</div><div class="line">	Glyph()&#123;</div><div class="line">		System.out.println("Gltph() befor draw()");</div><div class="line">		draw();</div><div class="line">		System.out.println("Gltph() after draw()");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class RoundGlyph extends Glyph&#123;</div><div class="line">	private int r=1;</div><div class="line">	RoundGlyph(int r)&#123;</div><div class="line">		this.r=r;</div><div class="line">		System.out.println("RoundGlyph.RoundGlyph(),r="+r);</div><div class="line">	&#125;</div><div class="line">	void draw()&#123;</div><div class="line">		System.out.println("RoundGlyph.draw(),r="+r);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class PolyConstructors &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">          new RoundGlyph(3);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行的结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">Gltph</span><span class="params">()</span></span> befor draw()</div><div class="line">RoundGlyph.draw(),r=<span class="number">0</span></div><div class="line"><span class="function"><span class="title">Gltph</span><span class="params">()</span></span> after draw()</div><div class="line">RoundGlyph.RoundGlyph(),r=<span class="number">3</span></div></pre></td></tr></table></figure>
<p>　　程序中，子类覆写了父类的draw()方法。进行初始化的时候，首先调用的是父类的构造方法，父类构造方法中此时的draw()是被覆写后的draw()。但是调用是，r=0，而不是默认值1。<br>　　由此，可以看出，在所有初始化动作开始之前，将分配给对象的存储空间初始化为二进制的0。<br> 　　这种错误，编译器不会报错，但是在实际使用中数据已经不可靠，是比较大的隐患。<br>   因此，尽可能的使用简单的方法是对象完成初始化，避免在构造方法中调用其他方法，如果需要调用，也最好是final方法或者private方法，这些方法不会被覆盖。</p>
<h2 id="4-向上转型与向下转型"><a href="#4-向上转型与向下转型" class="headerlink" title="4.向上转型与向下转型"></a><strong>4.向上转型与向下转型</strong></h2><p> 我们在使用多态时，也就已经使用了向上转型。子类继承自父类，子类拥有父类全部的接口，因此，向上转型总是安全的，但是也会丢失部分信息。通过向下转型，能够或许具体的类的信息，但是也需要注意一些问题。如以下的示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">class AA&#123;</div><div class="line">	public void method_1()&#123;System.out.println("A-1");&#125;</div><div class="line">	public void method_2()&#123;System.out.println("A-2");&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class BB extends AA&#123;</div><div class="line">	public void method_1()&#123;System.out.println("B-1");&#125;</div><div class="line">	public void method_2()&#123;System.out.println("B-2");&#125;	</div><div class="line">	public void method_3()&#123;System.out.println("B-3");&#125;</div><div class="line">	public void method_4()&#123;System.out.println("B-4");&#125;</div><div class="line">&#125;</div><div class="line">public class PolymorphismTest2 &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">      AA a = new AA();</div><div class="line">      AA b = new BB();</div><div class="line">      a.method_1();</div><div class="line">      b.method_2();</div><div class="line">      a.method_3();//1.The method method_3() is undefined for the type A</div><div class="line">      ((BB)b).method_3();//2.向下转型，可行</div><div class="line">      ((BB)a).method_3();//3.test.AA cannot be cast to test.BB</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从程序中可以学习到，第1处无法编译通过，原因是父类中没有method_3()方法，也就无法进行调用。可以通过向下转型进行调用，如第2处所示。a指向的是AA对象，b指向的是BB对象。AA对象无法转为BB对象去调用BB的方法，所以会抛出类型转换异常。</p>
<h2 id="5-多态中需要注意的细节"><a href="#5-多态中需要注意的细节" class="headerlink" title="5. 多态中需要注意的细节"></a><strong>5. 多态中需要注意的细节</strong></h2><p><strong>5.1 假象的覆盖私有方法。</strong><br>如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">private void method()&#123;</div><div class="line">System.out.println("A-method()");</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B extends A&#123;</div><div class="line">public void method()&#123;</div><div class="line">System.out.println("B-method()");</div><div class="line">&#125;</div><div class="line">public static void main (String[] args)&#123;</div><div class="line">A a = new B();</div><div class="line">a.method();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行后，会报如下错误：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The method method() from the type A is not visible</div></pre></td></tr></table></figure>
<p>从示例中可以看出，我们期待的是输出B-method(),但是程序并没有正确运行。这是因为，被private修饰的方法在子类中是不可见的，所以子类和父类名称一样但并不是覆写，对于子类而言，method()是一个新的方法。这就等同于4中的第1处错误。<br><strong>5.2多态中的成员变量和静态方法</strong><br>在类中，成员变量是不具备多态性的，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">int i=0</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class B extends A&#123;</div><div class="line">int i=1</div><div class="line">public static void main(String[] args)&#123;</div><div class="line">A a = new B();</div><div class="line">System.out.println("i="+a.i);</div><div class="line">B b= new B();</div><div class="line">System.out.println("i="+b.i);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i=<span class="number">0</span></div><div class="line">i=<span class="number">1</span></div></pre></td></tr></table></figure>
<p>这说明，成员变量不是多态的，值与对象引用相关。<br>对于静态方法而言，同样如此，因为静态方法是与类相关联的，与对象无关，因此也不具备多态性。</p>
<p>总结：</p>
<ul>
<li>多态的要素是继承，方法的覆写以及父类的引用指向子类的对象，缺一不可</li>
<li>当方法被static和final修饰时，就不具备动态绑定特性，也就不具备动态特性</li>
<li>继承和多态存在时，需要留意初始化顺序，谨慎在构造方法中进行其他方法的调用</li>
<li>向下转型需要注意的问题</li>
<li>类的成员变量和静态方法不具备多态性，与对象引用相关。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/14/《Java编程思想》学习笔记之final关键字概述/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/14/《Java编程思想》学习笔记之final关键字概述/" itemprop="url">
                  《Java编程思想》学习笔记之final关键字概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-14T12:28:41+08:00">
                2016-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/12/14/《Java编程思想》学习笔记之final关键字概述/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之final关键字概述">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　学完继承之后，也把final关键字的使用方法学习了一下，在这里进行一个总结。<br>  　　对于一个自定义的类而言，我们需要定义它的成员数据和方法。那么，final关键字也就可以修饰成员数据，方法和类本身。<br>    要点：</p>
<ul>
<li>final数据</li>
<li>final方法</li>
<li>final类</li>
</ul>
<h2 id="1-final数据"><a href="#1-final数据" class="headerlink" title="1.final数据"></a><strong>1.final数据</strong></h2><p>　　final修饰数据时又分为两种情况，即修饰基本类型数据和修饰类的对象引用。<br>　　当用final修饰基本类型数据时，那就表示该数据是恒定不变的，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final int i=5;</div></pre></td></tr></table></figure>
<p>　　如果在程序中，我们再次尝试向i赋值，那么就会报错。<br>　　对于一个基本类型数据，还可以同时用static和final修饰，这与单独的final修饰还是有一点不同的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final int i = new Random().nextInt(20);</div><div class="line">static final int j = new Random().nextInt(20);</div></pre></td></tr></table></figure>
<p>　　对于i而言，每次创建对象时，都会被初始化，随后在该对象中，这个值是不变的。但是，当我们再次创建一个新的对象后，又会初始化一次，该值对于该对象而言也是不变的。<br>  　　对于j而言，在类加载的时候已经被初始化，而不是每次创建对象时初始化，所以它的值是不会随着对象的创建而改变的。<br>  　　  final修饰对象应用时，它值的是该对象引用是指向某一个确定对象的，无法改变引用的指向。但是，该对象里面的值是可以变化的。<br>     　　在用final修饰数据时，可以不在定义处进行初始化，即空白final，我们可以在构造器中进行初始化。这样，可以保证一个final字段根据对象而有所不同。</p>
<h2 id="2-final方法"><a href="#2-final方法" class="headerlink" title="2.final方法"></a><strong>2.final方法</strong></h2><p>　　在继承中，如果我们不希望父类的方法被子类覆盖时，可以将该方法用final关键字修饰，这样可以做到方法行为保持不变。当我们尝试对这类方法进行覆盖时，系统就会提示编译错误。<br>  　　<strong>关于private和final。</strong><br>  　　  “覆盖”只有在某方法是父类的接口的一部分时才会出现。<br>    　　当一个方法被private修饰之后，即对外界不可见。那么就无法取用private方法，所以也就谈不上方法的覆盖。所以对于这类方法，是默认final的。<br>      　　两者的区别是，仅仅被final修饰的方法，在子类中是可见的，能够被调用，但是不能够覆盖。而仅仅被private修饰的方法，在子类中不可见，也不能够被调用。</p>
<h2 id="3-final类"><a href="#3-final类" class="headerlink" title="3.final类"></a><strong>3.final类</strong></h2><p>  当用final修饰类时，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final class A&#123;</div><div class="line">int i =4;</div><div class="line">void method()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么就表明，类A不允许被继承，也就是说，这个类不能够有子类。<br>对于final类中的字段，可以根据需要选择是否被final修饰。但是，对于final类中的方法，由于不能够被覆盖，所以是默认为被final修饰的。</p>
<p><strong>总结：</strong></p>
<ul>
<li>在设计类时，我们可以根据实际情况的需要来将类，数据和方法指明为final.</li>
<li>对于方法而言，需要谨慎使用final，因为遇见一个类如何被复用是困难的，尤其是对于通用的类库而言。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/14/《java编程思想》学习笔记之复用类/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/14/《java编程思想》学习笔记之复用类/" itemprop="url">
                  《Java编程思想》学习笔记之复用类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-14T12:26:11+08:00">
                2016-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/12/14/《java编程思想》学习笔记之复用类/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之复用类">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　复用代码是Java众多引人注目的功能之一。可以通过创建新类来复用代码，而不用编写重复的代码。<br>  　　实现这一目的可以有两种方式，一种是组合，既在新类中产生现有类的对象；二是继承，不改变现有类的形式，采用现有类的形式，并向其中添加新代码。<br>    　　本章要点：</p>
<ul>
<li>组合</li>
<li>继承</li>
<li>final关键字</li>
</ul>
<h2 id="1-组合"><a href="#1-组合" class="headerlink" title="1.组合"></a><strong>1.组合</strong></h2><p>　　程序的设计都是基于现实世界的反映，对于面向对象语言来说，这一点尤其的突出。举例来说，一辆汽车有发动机，轮子，门组成，这就是现实中的一种组合关系，反映到代码中，可以表示如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Engine&#123;</div><div class="line">   public void start()&#123;&#125;</div><div class="line">   public void stop()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Wheel&#123;</div><div class="line">   public void run()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Door&#123;</div><div class="line">   public void open()&#123;&#125;</div><div class="line">   public void close()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Car&#123;</div><div class="line">   public Engine e = new Engine();//汽车有一台发动机</div><div class="line">   public Wheel[] w = new Wheel[4];//汽车有四个轮子</div><div class="line">   public Door left = new Door();//左边的门</div><div class="line">   public Door right = new Door();//右边的门</div><div class="line">   public car()&#123;</div><div class="line">     for(int i=0;i&lt;4;i++)</div><div class="line">      wheel[i] = new Wheel();//在构造器中造轮子</div><div class="line"> &#125;</div><div class="line"> public static void main(String[] args)&#123;</div><div class="line">    Car car = new Car();</div><div class="line">    car.left.open();</div><div class="line">    car.e.start();&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　如上所示，在汽车类Car中，我们把组件（发动机，车轮和门）的引用作为类的成员变量置于其中。汽车启动时，只需调用对象对应的方法就行，省去了重复代码。</p>
<p>　　在组合中，我们引入的是对象的引用。当我们不对引用进行任何操作时，引用默认初始化为null,一把情况下，我们需要对这些引用进行初始化，初始化的位置有三个：</p>
<ul>
<li>在定义对象的地方，能够保证在构造方法被调用之前完成初始化；</li>
<li>在类的构造方法中；</li>
<li>在使用对象之前（？？？）<br>在上面的例子中已经得到体现，发动机和车门在被定义的时候就完成了初始化，而轮子是在Car类的构造方法中进行初始化的。</li>
</ul>
<h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a><strong>2.继承</strong></h2><p>2.1 <strong>继承的语义</strong><br>　　继承是所有面向对象语言重要的组成部分，它能够实现代码的复用，同时也是面向对象语言的多态特性的基础。<br>  　　在现实世界中，当某一类对象属于另一类对象时，可以看作是继承关系。例如，小米手机，华为手机都属于手机，它们都继承自手机类，拥有手机类的共同特点。用代码可以进行表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class Phone&#123;</div><div class="line">  double size;</div><div class="line">  String color;</div><div class="line">  public void call()&#123;</div><div class="line">  System.out.println(&quot;能够打电话&quot;);&#125;</div><div class="line">  public void message()&#123;</div><div class="line">  System.out.println(&quot;能够发短信&quot;);&#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  class XiaoMi extends Phone&#123;</div><div class="line">     public static void main(String[] args)&#123;</div><div class="line">     XiaoMi mi = new XiaoMi();</div><div class="line">     mi.size=5.5;</div><div class="line">     mi.color=&quot;白色&quot;;</div><div class="line">     System.out.println(&quot;手机尺寸为：&quot;+mi.size+&quot;   &quot;+&quot;手机颜色为&quot;+mi.color);</div><div class="line">  mi.call;</div><div class="line">     mi.message;&#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  运行结果为：</div><div class="line">  </div><div class="line">  手机尺寸为：5.5   手机颜色为白色</div><div class="line">  能够打电话</div><div class="line">  能够发短信</div><div class="line">  </div><div class="line">  class HuaWei extends Phone&#123;</div><div class="line">     String os = &quot;华为操作系统&quot;;</div><div class="line">     public void call()&#123;</div><div class="line">     System.out.println(&quot;用华为手机方式打电话&quot;);&#125;</div><div class="line">     public static void main(String[] args)&#123;</div><div class="line">     HuaWei hw = new HuaWei();</div><div class="line">     hw.size=6;</div><div class="line">     hw.color = &quot;黑色&quot;;</div><div class="line">     System.out.println(&quot;手机尺寸为：&quot;+hw.size+&quot;   &quot;+&quot;手机颜色为&quot;+hw.color);</div><div class="line">     hw.call();</div><div class="line">     hw.messag();&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">运行的结果为：</div><div class="line"></div><div class="line">手机尺寸为：6.0   手机颜色为黑色</div><div class="line">用华为手机方式打电话</div><div class="line">能够发短信</div></pre></td></tr></table></figure>
<p>　　从示例中可以看出，XiaoMi和HuaWei通过关键字extends实现了从phone的继承，那么phone就被成为父类，XiaoMi和HuaWei就是子类。子类继承自父类之后，就拥有了父类全部的方法和成员。并且，子类可以新增属于自己的成员和方法，也可以覆写父类的方法。在覆写父类的方法时，如果要在覆写的方法中调用从父类继承而来的方法，可以用关键字super来表示，如super.call().<br>  　　一般来说，为了继承，会将所有父类的成员指定为private,而将所有的方法指定为public，通过方法去访问数据成员。<br>    <strong>2.2 继承中的子类的初始化</strong><br>    　　“当创建了一个子类对象时，该对象包含了一个父类的子对象。这个子对象与我们用父类直接创建的对象是一样的。两者的区别在于，后者来自外部，而父类的子对象被包装在子类对象内部。”<br>      　　这是因为，我们在进行子类对象创建的时候，系统会首先掉用父类的构造方法。如以下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class father&#123;</div><div class="line">	father()&#123;</div><div class="line">		System.out.println(&quot;father constructor&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class son extends father&#123;</div><div class="line">	son()&#123;</div><div class="line">		System.out.println(&quot;son constructor&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class grandson extends son&#123;</div><div class="line">	grandson()&#123;</div><div class="line">		System.out.println(&quot;grandson constructor&quot;);</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		grandson g= new grandson();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">father constructor</div><div class="line">son constructor</div><div class="line">grandson constructor</div></pre></td></tr></table></figure>
<p>可以看出来，构造方法的执行是从父类开始的，如果父类还有上一级的父类，会进一步向上追溯。在该示例中，无参的构造方法是显式写出来的，如果没有显式的构造方法，系统也会调用默认的构造方法。<br>　　上述事例中的构造方法都是没有参数列表，如果构造方法含有参数，就必须用super关键字显式的写在子类构造方法的第一行。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">class father&#123;</div><div class="line">	father(int i)&#123;</div><div class="line">		System.out.println("father constructor");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class son extends father&#123;</div><div class="line">	son(int i)&#123;</div><div class="line">		super(i);</div><div class="line">		System.out.println("son constructor");</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class grandson extends son&#123;</div><div class="line">	grandson()&#123;</div><div class="line">		super(1);</div><div class="line">		System.out.println("grandson constructor");</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		grandson g= new grandson();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们不用super关键字进行调用，系统就会报如下错误：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Implicit super constructor father() is undefined. Must explicitly invoke another constructor</div></pre></td></tr></table></figure>
<p>如果我们不把super放在第一行，系统就会报如下错误：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Constructor call must be the first statement <span class="keyword">in</span> <span class="selector-tag">a</span> constructor</div></pre></td></tr></table></figure>
<p><strong>2.3 继承中的方法的重载与重写</strong><br>如果在父类中已经有重载的方法，那么在子类中重新定义该方法的重载，并不会屏蔽掉父类的方法，这一点与重写不一样。示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">class Fu &#123;</div><div class="line">	public void say(int i)&#123;</div><div class="line">		System.out.println("我的年龄是："+i);</div><div class="line">	&#125;</div><div class="line">	public void say(String s)&#123;</div><div class="line">		System.out.println("我的名字是："+s);</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Zi extends Fu &#123;</div><div class="line">     public void say(char c)&#123;</div><div class="line">    	 System.out.println("我最喜欢的字母是"+c);</div><div class="line">    </div><div class="line">     &#125;</div><div class="line">     public void say(int i)&#123;</div><div class="line">    	 i=i-24;</div><div class="line"> 		System.out.println("我的年龄是："+i);</div><div class="line"> 	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Zi z = new Zi();</div><div class="line">		z.say(48);</div><div class="line">		z.say("张三");</div><div class="line">		z.say('x');	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行的结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">我的年龄是：<span class="number">24</span></div><div class="line">我的名字是：张三</div><div class="line">我最喜欢的字母是x</div></pre></td></tr></table></figure>
<p>父类中有两个重载的say方法，传递的参数分别是int和String，子类中也有say方法，传递了参数char，该方法与并不是对父类的覆盖，而是重载，相当于一个新的方法。子类中还有一个参数为int的say方法，这个方法是对父类方法的覆盖。</p>
<p><strong>2.4 继承中的向上转型</strong><br><strong>“子类是父类的一种类型”</strong>。父类中所有的方法在子类中同样有效，向父类发送的消息同样可以向子类发送。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">public void method_1()&#123;&#125;</div><div class="line">public static void method_2(A a)&#123;</div><div class="line">a.method_1();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B extends A&#123;</div><div class="line">public static void main(String[] args)&#123;</div><div class="line">B b= new B();</div><div class="line">A.method_2(b)</div><div class="line">;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中，在父类中定义了一个静态方法method_2，这个方法的传递参数是A类对象的一个引用，该方法可以用类名直接调用。在子类中，建立了子类的一个对象b,在调用方法method_2时，传递的参数是子类B的对象b,程序可以运行。这说明，子类对象b同样也是父类A的对象。将子类B的引用向上转型到A类的引用，这个就叫做“向转型”，这个方法在多态中应用较多。</p>
<p><strong>2.5 组合与继承的选择</strong><br>1.组合常用于想在新类中使用现有类的功能而不是接口的场所，而需要使用现有类的所有成员和方法，并且需要使用接口时，用继承。<br>2.组合是“has-a”的关系，而继承是“is-a”的关系，当我们所需要使用的两个类复合其中的关系时，就用对应的组合或者继承。<br>3.到底是用组合还是继承，一个最简单的办法就是看是否需要从子类向父类进行向上转型。如果必须向上转型，则要用继承，否则，可以考虑应用组合语法。</p>
<p><strong>总结</strong></p>
<ul>
<li>组合是一种复用代码的方法，有较强的灵活性；</li>
<li>继承中，子类是父类的一种类型，它也是向上转型和多态的基础</li>
<li>组合和继承的选用要看具体使用场景，按照自己归纳的三个原则进行选择。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/11/《Java编程思想》学习笔记之隐藏具体实现（第五章）/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/11/《Java编程思想》学习笔记之隐藏具体实现（第五章）/" itemprop="url">
                  《Java编程思想》学习笔记之隐藏具体实现（第五章）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-11T10:22:04+08:00">
                2016-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2016/12/11/《Java编程思想》学习笔记之隐藏具体实现（第五章）/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之隐藏具体实现（第五章）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　在面向对象设计中，要考虑的一个基本问题是“如何把变动的事物与保持不变的事物区分开”。<br>  　　对于程序开发者而言，开发的程序和软件是让用户或者客户端程序员进行使用的，但是不希望他们能够对程序内部进行非法的更改。因此，需要对程序进行良好的封装设计，以便于用户或者客户端程序员能够正确的使用程序而不破坏代码。<br>    　　在Java中，是通过提供访问权限修饰符来解决这个问题的。访问权限能够向用户或者客户端程序员指明哪些是可用的，哪些是不可用的，通过层次分明的访问权限进行控制。<br>     　　 另外，访问控制符会因为类所在的位置不同而受到影响，它是依赖于程序库的。<br>      　　本章要点：<br>     　　1.关键字package和import<br>       　　2.关键字public，private和protected
       　　</p>
<h2 id="1-关键字package和import"><a href="#1-关键字package和import" class="headerlink" title="1. 关键字package和import"></a><strong>1. 关键字package和import</strong></h2><p>package是为了将一组类文件放置在同一个目录下，避免相同命名的类的冲突。举例说明，假如三年级有两个名叫张三的同学，我们把这两个张三分别放在了三（一）班和三（二）班，那么这两个班就是两个不同的package。伪代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package 三（一）班；</div><div class="line">class student&#123;</div><div class="line">String name = <span class="string">"张三"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">package 三（二）班；</div><div class="line">class student&#123;</div><div class="line">String name = <span class="string">"张三"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在.Java文件的起始处，用“package 包名”的方式声明该Java文件是该程序库的一部分。一个包不是将被打包的东西包装成一个单一的文件，一个包可以由许多的.class文件构成。<br>对于包的命名，一般是将反顺序的类的创建者的internet域名作为package名称，如com.xuwei.因为域名应该是独一无二的，所以package名称也是独一无二的。</p>
<p>import关键字与package关键字是一个互逆的过程。</p>
<p>假如在com.xuwei包中有一个类MyClass，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">package com.xuwei;</div><div class="line">public class MyClass&#123;</div><div class="line">//.....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们想用MyClass类创建对象时，如果不采用import关键字，创建过程是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">com.xuwei.MyClass m =  new com.xuwei.MyClass();</div></pre></td></tr></table></figure>
<p>当我们使用import关键字后，创建过程的书写就会变得简单一些，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import com.xuwei.*;</div><div class="line">MyClass m = new MyClass();</div></pre></td></tr></table></figure></p>
<p>我们也可以创建属于自己的工具库来减少重复代码的输入，例如，我们经常会写输出语句System.out.println，我们可以创建别名来减少输入的负担，如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.tools;</div><div class="line">public class P&#123;</div><div class="line">public static void sop(String s)&#123;</div><div class="line">System.out.printin(s);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们需要使用的时候，就可以用简写的打印方法：如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//导入工具库</div><div class="line">import com.xuwei.tools;</div><div class="line"></div><div class="line">public class ToolTest&#123;</div><div class="line">public static void main(String[] args)&#123;</div><div class="line">P.sop("Hello word")&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，当我们需要创建一些自己的快捷方法时，我们可以把这些方法放在同一个类库中，只要导入这个类库，就可以很方便的进行使用。</p>
<h2 id="2-关键字public、private、protected"><a href="#2-关键字public、private、protected" class="headerlink" title="2.关键字public、private、protected"></a><strong>2.关键字public、private、protected</strong></h2><p>　　java通过访问修饰词对类中的成员和方法进行修饰，一般将它置于定义之前，进行访问控制。<br>  　　访问权限最大的是<strong>public</strong>，用public修饰后，该成员或者方法就可以被不同包中的类所访问。，如下所示：我们在com.xuwei包中创建一个Student类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.xuwei;</div><div class="line"></div><div class="line"> //学生类 </div><div class="line"> </div><div class="line">public class Student &#123;</div><div class="line">	public String id;</div><div class="line">	public String name;</div><div class="line">	public Student(String id,String name)&#123;</div><div class="line">		this.id=id;</div><div class="line">		this.name=name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类的名称以及成员和构造方法都是用public修饰的，导入之后，我们可以在另一个包中直接使用这个类，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line">import com.xuwei.*;</div><div class="line"></div><div class="line">public class Test1 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Student s = new Student("001","张三");</div><div class="line">		System.out.println(s.id+"   "+s.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">001</span>   张三</div></pre></td></tr></table></figure>
<p>由此可见，public类有最大的访问权限，可以实现不同包之间的类的共享。</p>
<p>　　当我们不在类之前或者成员和方法之前添加任何修饰符时，默认的就是<strong>包访问权限</strong>，处于同一个包中的类可以相互访问，但是如果在其他的包中进行访问，编译就会报错，比如，把Student中的成员name的public去掉，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.xuwei;</div><div class="line"></div><div class="line"> //学生类 </div><div class="line"> </div><div class="line">public class Student &#123;</div><div class="line">	public String id;</div><div class="line">    String name;</div><div class="line">	public Student(String id,String name)&#123;</div><div class="line">		this.id=id;</div><div class="line">		this.name=name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时如何再在test包中进行访问，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line">import com.xuwei.*;</div><div class="line"></div><div class="line">public class Test1 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Student s = new Student("001","张三");</div><div class="line">		System.out.println(s.id+"   "+s.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行时，程序会报错如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.Error</span>: Unresolved compilation problem: </div><div class="line">	The field Student<span class="selector-class">.name</span> is not visible</div></pre></td></tr></table></figure>
<p>由此可见，默认的包访问权限比包要小，只允许同一个包之间的访问。</p>
<p>　　private指的是私有，只能用来修饰成员变量和方法，被他修饰之后，对应的变量和方法只在本类中可以访问，同一个包中的其他类都不能够进行访问，能够进行很好的封装隐藏。<br>  　　如果把类的构造方法进行私有化，那就能阻止别人直接访问构造器，控制创建对象，一般会提供一个普通方法进行调用来创建对象。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    package com.xuwei;</div><div class="line"></div><div class="line"> //学生类 </div><div class="line"> </div><div class="line">public class Student &#123;</div><div class="line">	public String id;</div><div class="line">    String name;</div><div class="line">	private Student()&#123;&#125;</div><div class="line">    public static Student makeStudent()&#123;</div><div class="line">         return new Student();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　对于成员变量，为了防止非法操作，我们也可以将其私有化。为了让外界进行访问这些变量，可以通过建立公开的访问方法进行访问。<br>　　protected属于继承访问权限，访问权限介于public和包访问权限之间。当用protected修饰成员变量或者方法的时候，被修饰的变量和方法能被同一包中的其他类进行访问。同时，如果有另一个包中的某一个类继承自该类，那么子类同样可以访问被protected修饰的成员变量和方法。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><p>  1.完成大型的程序设计工作，往往需要不同模块的拼装。通过package和import关键字，可以有效的建立模块之间的层次目录，便于模块的管理。<br>  2.访问修饰符为程序设计提供了封装隐藏的实现，能够增强程序的可读性和安全性，在设计模式中也可能有较大的发挥。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          <section id="comment">  
  <!-- ��˵���ۿ� start -->
	<div class="ds-thread" data-thread-key="<%= page.path %>" data-title="<%= page.title %>" data-url="https://xuwei1991.github.io/<%= page.permalink %>"></div>
<!-- ��˵���ۿ� end -->
<!-- ��˵����JS���� start (һ����ҳֻ������һ��) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"xuwei1234"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- ��˵����JS���� end -->
 
</section>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="xuwei1991" />
          <p class="site-author-name" itemprop="name">xuwei1991</p>
          <p class="site-description motion-element" itemprop="description">The Best or Nothing</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">45</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuwei1991</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("PlM9fkBu5Xsbaz55LCTKph3O-gzGzoHsz", "Ro21MawN38aeHbNOxyQiQCOC");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
