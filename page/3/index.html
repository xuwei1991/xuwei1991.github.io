<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="The Best or Nothing">
<meta property="og:type" content="website">
<meta property="og:title" content="xuwei'blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="xuwei'blog">
<meta property="og:description" content="The Best or Nothing">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xuwei'blog">
<meta name="twitter:description" content="The Best or Nothing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title> xuwei'blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">xuwei'blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/14/Java设计模式之工厂方法模式-抽象工厂方法模式/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/14/Java设计模式之工厂方法模式-抽象工厂方法模式/" itemprop="url">
                  Java设计模式之工厂方法模式+抽象工厂方法模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-14T21:35:51+08:00">
                2017-02-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2017/02/14/Java设计模式之工厂方法模式-抽象工厂方法模式/" class="leancloud_visitors" data-flag-title="Java设计模式之工厂方法模式+抽象工厂方法模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　工厂方法模式和抽象工厂方法模式是Java创建型模式的一种，是用来更方便的创建对象的。另外，简单工厂方法也是学习它们的基础，本章主要对这三个模式进行学习。<br>  本章要点：</p>
<ul>
<li>简单工厂方法模式</li>
<li>工厂方法模式</li>
<li>抽象工厂方法模式</li>
<li>总结</li>
</ul>
<h2 id="1-简单工厂方法模式"><a href="#1-简单工厂方法模式" class="headerlink" title="1. 简单工厂方法模式"></a><strong>1. 简单工厂方法模式</strong></h2><h4 id="1-1-概念及由来"><a href="#1-1-概念及由来" class="headerlink" title="1.1 概念及由来"></a><strong>1.1 概念及由来</strong></h4><p>　　通常，我们需要用到一个对象时，都是采用关键字new来进行创建。举例来说，小米手机有多个产品，如果我们想到用到手机的功能，通常都是在主函数中new出手机对象，然后再进行方法的调用。<br>  如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.DesignPattern;</div><div class="line">//小米1产品类</div><div class="line">class Mi1&#123;</div><div class="line">	public void call()&#123;</div><div class="line">		//小米1打电话功能</div><div class="line">		System.out.println("用小米1手机打电话");</div><div class="line">		&#125;</div><div class="line">     	//小米1发短信功能</div><div class="line">	public void sendmessage()&#123;</div><div class="line">		System.out.println("用小米1手机发短信");</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//小米2产品类</div><div class="line">class Mi2&#123;</div><div class="line">	public void call()&#123;</div><div class="line">		//小米2打电话功能</div><div class="line">		System.out.println("用小米2手机打电话");</div><div class="line">		&#125;</div><div class="line">	    //小米2发短信功能</div><div class="line">	public void sendmessage()&#123;</div><div class="line">		System.out.println("用小米2手机发短信");</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line">public class FactoryDemo1 &#123;</div><div class="line">   public static void main(String[] args)&#123;</div><div class="line">	   //创建小米1和小米2对象</div><div class="line">	   Mi1 m1 = new Mi1();</div><div class="line">	   Mi2 m2 = new Mi2();</div><div class="line">	   //调用小米1的方法</div><div class="line">	   m1.call();</div><div class="line">	   m1.sendmessage();</div><div class="line">	   //调用小米2的方法</div><div class="line">	   m2.call();</div><div class="line">	   m2.sendmessage();	      </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　如上面的示例所示，能够完成我们需要达到的功能。但是，存在两个缺点：</p>
<ol>
<li>客户端进行创建对象时，创建过程是对客户端可见的，不符合程序的封装特性；</li>
<li>上述示例中对象创建比较简单，如果某个对象的创建需要多种初始化设置，那么在客户端进行创建对象就是不合适的，不利于代码的简洁和可读性；<br>　　可以通过简单工厂方法来解决这个问题。在上述示例中，小米手机的系列产品的功能方法是一致的，可以把小米手机作为父类抽取出来，后续的方法调用可以采用多态的形式进行。另外可以建造工厂，专门生产小米手机，把代码放置在工厂类中，向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。<h4 id="1-2-简单工厂设计模式的主要角色"><a href="#1-2-简单工厂设计模式的主要角色" class="headerlink" title="1.2 简单工厂设计模式的主要角色"></a><strong>1.2 简单工厂设计模式的主要角色</strong></h4>　　作为简单工厂设计模式，它有效的简化了对象的创建，并封装了代码。它有三个主要的角色：</li>
</ol>
<ol>
<li><strong>抽象产品角色</strong>：它是具体产品抽取而来的父类或者是接口，定义了具体产品要实现基本的方法；</li>
<li><strong>具体产品角色</strong>：具体产品的实现类，重写父类的方法，实现自己的功能；</li>
<li><strong>工厂类角色</strong>：简单工厂方法的核心角色，通过工厂类角色实现产品的具体创建过程；<h4 id="1-3-简单工厂设计模式的代码体现"><a href="#1-3-简单工厂设计模式的代码体现" class="headerlink" title="1.3 简单工厂设计模式的代码体现"></a><strong>1.3 简单工厂设计模式的代码体现</strong></h4>　　通过上面的分析，可以建三个类来实现简单工厂设计模式。首先创建抽象产品角色，把小米手机作为父类，提供打电话和发短信的功能，再创建具体类角色，分别定义小米1和小米2，并重写它们的功能，然后再建立工厂，在小米工厂中生产小米1和小米2。在客户端进行对象创建时，只需要调用工厂，用工厂进行调用即可。<br>　　代码示例如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">    package com.xuwei.DesignPattern;</div><div class="line">//抽象产品类，定义抽象方法</div><div class="line">abstract class Mi&#123;</div><div class="line">	abstract void call();</div><div class="line">	abstract void sendsendmessage();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//具体产品小米1继承抽象产品小米手机，并复写方法；</div><div class="line">class Mi1 extends Mi&#123;</div><div class="line">	@Override</div><div class="line">	void call() &#123;</div><div class="line">		System.out.println(&quot;用小米1手机打电话&quot;);		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	void sendsendmessage() &#123;</div><div class="line">		System.out.println(&quot;用小米1手机发短信&quot;);	</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//具体产品小米2继承抽象产品小米手机，并复写方法；</div><div class="line">class Mi2 extends Mi&#123;</div><div class="line">	@Override</div><div class="line">	void call() &#123;</div><div class="line">		System.out.println(&quot;用小米2手机打电话&quot;);		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	void sendsendmessage() &#123;</div><div class="line">		System.out.println(&quot;用小米2手机发短信&quot;);	</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//工厂类，负责生产小米1和小米2</div><div class="line">class MiFactory&#123;	</div><div class="line">	public  static Mi createMi(int MiType)&#123;</div><div class="line">		//通过传入的类型来选择生产的具体产品类</div><div class="line">		switch(MiType)&#123;</div><div class="line">		//如果传入的是1，就生产小米1</div><div class="line">		case 1:</div><div class="line">			return new Mi1();</div><div class="line">		//如果传入的是2，就生产小米2</div><div class="line">		case 2:</div><div class="line">			return new Mi2();</div><div class="line">		default:</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		return null;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FactoryDemo2 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		//通过向工厂传入参数来创建小米1产品和小米2产品</div><div class="line">		Mi m1 = MiFactory .createMi(1);</div><div class="line">		Mi m2 =MiFactory.createMi(2);</div><div class="line">		//调用小米1和小米2的方法</div><div class="line">		m1.call();</div><div class="line">		m1.sendsendmessage();</div><div class="line">		m2.call();</div><div class="line">		m2.sendsendmessage();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　通过采用简单工厂方法，解决了系列产品对象的创建问题，有效的封装了代码，并且使得调用者更加方便的使用。</p>
<h2 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2. 工厂方法模式"></a><strong>2. 工厂方法模式</strong></h2><h4 id="2-1-工厂方法模式的概念和由来"><a href="#2-1-工厂方法模式的概念和由来" class="headerlink" title="2.1 工厂方法模式的概念和由来"></a><strong>2.1 工厂方法模式的概念和由来</strong></h4><p>　　工厂方法模式和简单工厂模式属于一个系列，都是用来创建对象的设计模式，工厂方法模式是基于简单工厂方法之上的。拿上面的例子来说，目前两个产品都可以在工厂类中进行生产。如果小米3又出来了，需要在工厂中进行生产，那么，就必须修改工厂方法的代码，这样就不符合了设计模式的开闭原则，不利于后续的拓展。由此提出来了工厂方法模式，将工厂类进行抽象，具体的工厂来负责生产具体的产品。</p>
<h4 id="2-2-工厂方法设计模式的主要角色"><a href="#2-2-工厂方法设计模式的主要角色" class="headerlink" title="2.2 工厂方法设计模式的主要角色"></a><strong>2.2 工厂方法设计模式的主要角色</strong></h4><p>　　工厂方法设计模式减少了工厂方法压力，让具体的产品生产在子类工厂中进行实现，它主要有四种主要的角色：</p>
<p> 1.<strong>抽象产品角色</strong>：它是具体产品抽取而来的父类或者是接口，定义了具体产品要实现基本的方法；</p>
<p> 2.<strong>具体产品角色</strong>：具体产品的实现类，重写父类的方法，实现自己的功能；</p>
<p>3.<strong>抽象工厂角色</strong>：具体工厂类要继承的父类或要实现的接口，定义生产方法；</p>
<p>4.<strong>具体工厂角色</strong>：重写或实现抽象工厂的方法，生产具体的产品；</p>
<h4 id="2-3工厂方法设计模式的程序示例"><a href="#2-3工厂方法设计模式的程序示例" class="headerlink" title="2.3工厂方法设计模式的程序示例"></a><strong>2.3工厂方法设计模式的程序示例</strong></h4><p>　　加入添加新的产品小米3，通过改进程序代码，能够解决问题。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.DesignPattern;</div><div class="line"></div><div class="line">abstract class Mi&#123;</div><div class="line">	abstract void call();</div><div class="line">	abstract void sendsendmessage();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//具体产品小米1继承抽象产品小米手机，并复写方法；</div><div class="line">class Mi1 extends Mi&#123;</div><div class="line">	@Override</div><div class="line">	void call() &#123;</div><div class="line">		System.out.println("用小米1手机打电话");		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	void sendsendmessage() &#123;</div><div class="line">		System.out.println("用小米1手机发短信");	</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//具体产品小米2继承抽象产品小米手机，并复写方法；</div><div class="line">class Mi2 extends Mi&#123;</div><div class="line">	@Override</div><div class="line">	void call() &#123;</div><div class="line">		System.out.println("用小米2手机打电话");		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	void sendsendmessage() &#123;</div><div class="line">		System.out.println("用小米2手机发短信");	</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//具体产品小米3继承抽象产品小米手机，并复写方法；</div><div class="line">class Mi3 extends Mi&#123;</div><div class="line">	@Override</div><div class="line">	void call() &#123;</div><div class="line">		System.out.println("用小米3手机打电话");		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	void sendsendmessage() &#123;</div><div class="line">		System.out.println("用小米3手机发短信");	</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//抽象工厂类，定义抽象的生产方法</div><div class="line">abstract class MiFactory&#123;</div><div class="line">	abstract Mi createMi();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Mi1_Factory extends MiFactory&#123;</div><div class="line">    //覆写工厂类的生产方法，生产小米1</div><div class="line">	Mi createMi() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Mi1();</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Mi2_Factory extends MiFactory&#123;</div><div class="line">    //覆写工厂类的生产方法，生产小米2</div><div class="line">	Mi createMi() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Mi2();</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Mi3_Factory extends MiFactory&#123;</div><div class="line">    //覆写工厂类的生产方法，生产小米3</div><div class="line">	Mi createMi() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Mi3();</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class FactoryDemo3 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Mi1_Factory mf1 = new Mi1_Factory();</div><div class="line">		Mi m1 = mf1.createMi();</div><div class="line">		m1.call();</div><div class="line">		m1.sendsendmessage();</div><div class="line">		</div><div class="line">		Mi2_Factory mf2 = new Mi2_Factory();</div><div class="line">		Mi m2 = mf2.createMi();</div><div class="line">		m2.call();</div><div class="line">		m2.sendsendmessage();</div><div class="line">		</div><div class="line">		Mi3_Factory mf3 = new Mi3_Factory();</div><div class="line">		Mi m3 = mf3.createMi();</div><div class="line">		m3.call();</div><div class="line">		m3.sendsendmessage();	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果后续要在生产小米4，只需要添加小米4产品类和小米4工厂类，不需要修改已有的代码。上述代码做到了低耦合性，也负责设计模式的开闭原则。</p>
<h2 id="3-抽象工厂方法模式"><a href="#3-抽象工厂方法模式" class="headerlink" title="3.抽象工厂方法模式"></a><strong>3.抽象工厂方法模式</strong></h2><h4 id="3-1-抽象工厂方法模式的概念及由来"><a href="#3-1-抽象工厂方法模式的概念及由来" class="headerlink" title="3.1 抽象工厂方法模式的概念及由来"></a><strong>3.1 抽象工厂方法模式的概念及由来</strong></h4><p>　　抽象工厂方法模式和前两种工厂模式同属一个系列，但是用来解决不同的问题，它的适用场所是存在产品族的情况。假如，上述示例中，小米1还要生产CPU和电池，小米2也要声场CPU和电池，两个产品分别配备各自的电池。那么就存在了一个产品序列。引进抽象工厂模式，可以处理具有相同（或者相似）等级结构的多个产品族中的产品对象的创建问题。</p>
<h4 id="3-2-抽象工厂方法模式的主要角色"><a href="#3-2-抽象工厂方法模式的主要角色" class="headerlink" title="3.2 抽象工厂方法模式的主要角色"></a><strong>3.2 抽象工厂方法模式的主要角色</strong></h4><p>　　和工厂方法模式一样，抽象工厂方法模式也有四个主要的角色，但是和工厂方法模式的角色内容有点不一样。</p>
<ol>
<li>抽象产品角色：有多个抽象产品类，每个抽象产品类派生出多个具体的产品类</li>
<li>具体产品类：实现抽象产品类的方法</li>
<li>抽象工厂类：一个抽象工厂，定义生产产品族的方法</li>
<li>具体工厂类：每个工厂类实现多个产品的制造方法，这些产品同属一个产品族；<h4 id="3-3-抽象工厂方法模式的程序示例"><a href="#3-3-抽象工厂方法模式的程序示例" class="headerlink" title="3.3 抽象工厂方法模式的程序示例"></a><strong>3.3 抽象工厂方法模式的程序示例</strong></h4>　　假如有两个产品，分别是小米1和小米2，而每个产品又有CPU和电池，构成了一个产品族。如果用之前学到的工厂方法模式，那么就要建立四个工厂，彼此之间没有形成联系，客户端进行调用时，也要具体的指明产品信息，较为繁琐。采用抽象工厂方法模式，能够简化代码，如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.DesignPattern;</div><div class="line">//抽象产品CPU</div><div class="line">abstract class CPU&#123;&#125;</div><div class="line"></div><div class="line">//具体产品类，小米1的电CPU</div><div class="line">class Mi1_cpu extends CPU&#123;</div><div class="line">	public Mi1_cpu()&#123;System.out.println("小米1的CPU被生产了");&#125;</div><div class="line">&#125;</div><div class="line">//具体产品类，小米2的CPU</div><div class="line">class Mi2_cpu extends CPU&#123;</div><div class="line">	public Mi2_cpu()&#123;System.out.println("小米2的CPU被生产了");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//抽象产品电池</div><div class="line">abstract class DianChi&#123;&#125;</div><div class="line"></div><div class="line">//具体产品类，小米1的电池</div><div class="line">class Mi1_DianChi extends DianChi&#123;</div><div class="line">	public Mi1_DianChi()&#123;System.out.println("小米1的电池被生产了");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//具体产品类，小米2的电池</div><div class="line">class Mi2_DianChi extends DianChi&#123;</div><div class="line">	public Mi2_DianChi()&#123;System.out.println("小米2的电池被生产了");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//抽象工厂，定义生产电池和生产CPU的方法</div><div class="line"> interface Factory&#123;</div><div class="line">	public CPU createCPU();</div><div class="line">	public  DianChi createDianChi();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//具体工厂，小米1的工厂，同时生产小米1的CPU和电池 </div><div class="line"> class Mi1_Factory implements Factory&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public CPU createCPU() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Mi1_cpu();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public DianChi createDianChi() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Mi1_DianChi();</div><div class="line">	&#125;	 </div><div class="line"> &#125;</div><div class="line"> </div><div class="line">//具体工厂，小米2的工厂，同时生产小米2的CPU和电池 </div><div class="line"> class Mi2_Factory implements Factory&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public CPU createCPU() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Mi2_cpu();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public DianChi createDianChi() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Mi2_DianChi();</div><div class="line">	&#125;	 </div><div class="line"> &#125;</div><div class="line"> </div><div class="line"></div><div class="line"></div><div class="line">public class FactoryDemo4 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//创建一个小米1的工厂，通过工厂生产需要的电池和CPU</div><div class="line">		Mi1_Factory mf1 = new Mi1_Factory();</div><div class="line">		mf1.createCPU();</div><div class="line">		mf1.createDianChi();</div><div class="line">		</div><div class="line">		//创建一个小米2的工厂，通过工厂生产需要的电池和CPU</div><div class="line">		Mi2_Factory mf2 = new Mi2_Factory();</div><div class="line">		mf2.createCPU();</div><div class="line">		mf2.createDianChi();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码较好的解决了产品族的问题。但是同时也存在一个缺点，如果再加入其他的产品对象，比如要生产手机屏幕，那么代码就要大幅度修改，不再适用。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h2><ol>
<li>无论是哪种工厂方法模式，最终的目的都是封装代码和解耦。</li>
<li>工厂模式和抽象工厂模式的区别是，工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。抽象工厂更多的应用在产品族情况中。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/12/Java设计模式概述/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/12/Java设计模式概述/" itemprop="url">
                  java设计模式概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-12T12:28:58+08:00">
                2017-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2017/02/12/Java设计模式概述/" class="leancloud_visitors" data-flag-title="java设计模式概述">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。————来自百度百科<br>  　　本章要点：</p>
<ol>
<li>设计模式的原则</li>
<li>设计模式的种类及分类</li>
<li><p>总结</p>
<h2 id="1-设计模式的原则"><a href="#1-设计模式的原则" class="headerlink" title="1.设计模式的原则"></a><strong>1.设计模式的原则</strong></h2><p>　　采用设计模式是为了代码复用，增强可维护性。为了达到这个目的，设计模式一般要遵从以下原则。</p>
<h4 id="1-1-开闭原则"><a href="#1-1-开闭原则" class="headerlink" title="1.1 开闭原则"></a><strong>1.1 开闭原则</strong></h4><p>　　开闭原则是由Bertrand Meyer提出的。原文是：“Software entities should be open for extension,but closed for modification”。就是说模块应<strong>对扩展开放，而对修改关闭</strong>。也就是说在拓展程序时，尽量不要修改原有的代码。</p>
<h4 id="1-2-里氏代换原则"><a href="#1-2-里氏代换原则" class="headerlink" title="1.2 里氏代换原则"></a><strong>1.2 里氏代换原则</strong></h4><p>　　里氏代换原则是由Barbara Liskov提出的。原则是父类可以出现的地方子类一定能够出现。里氏代换原则是继承复用的一个基础，Java程序在编译的时候也会检查这一个原则。在Java继承中有这样一个原则，子类复写父类的方法时，方法的权限不能够比父类的方法权限小，这样，在父类方法可以用到的地方，子类也有权限进行使用。</p>
<h4 id="1-3-依赖倒转原则"><a href="#1-3-依赖倒转原则" class="headerlink" title="1.3 依赖倒转原则"></a><strong>1.3 依赖倒转原则</strong></h4><p>　　指在软件里面，把父类都替换成它的子类，程序的行为没有变化。简单的说，子类型能够替换掉它们的父类型。依赖性倒转其实可以说是面向对象设计的标志，用哪种语言编程并不是很重要。—–来自baike</p>
<h4 id="1-4-接口隔离原则"><a href="#1-4-接口隔离原则" class="headerlink" title="1.4 接口隔离原则"></a><strong>1.4 接口隔离原则</strong></h4><p>　　这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。尽量让每个接口干单一的事，能够降低耦合性。</p>
<h4 id="1-5-迪米特法则（最少知道原则）"><a href="#1-5-迪米特法则（最少知道原则）" class="headerlink" title="1.5 迪米特法则（最少知道原则）"></a><strong>1.5 迪米特法则（最少知道原则）</strong></h4><p>　　一个实体对象应当尽量与其他实体对象相隔离，保持各自的独立。</p>
<h4 id="1-6-合成复用原则"><a href="#1-6-合成复用原则" class="headerlink" title="1.6 合成复用原则"></a><strong>1.6 合成复用原则</strong></h4><p>　　在程序中，应当尽量使用合成复用，而不是使用继承。</p>
<h2 id="2-设计模式的种类及分类"><a href="#2-设计模式的种类及分类" class="headerlink" title="2. 设计模式的种类及分类"></a><strong>2. 设计模式的种类及分类</strong></h2><p>　　按照字典顺序排序，Java设计模式一共有23种，分别如下：</p>
<h4 id="2-1-设计模式种类"><a href="#2-1-设计模式种类" class="headerlink" title="2.1 设计模式种类"></a><strong>2.1 设计模式种类</strong></h4><p>　　Abstract Factory（<strong>抽象工厂模式</strong>）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>　　Adapter（<strong>适配器模式</strong>）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>　　Bridge（<strong>桥接模式</strong>）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>　　Builder（<strong>建造者模式</strong>）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>　　Chain of Responsibility（<strong>责任链模式</strong>）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。<br>　　Command（<strong>命令模式</strong>）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。<br>　　Composite（<strong>组合模式</strong>）：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。<br>　　Decorator（<strong>装饰模式</strong>）：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。<br>　　Facade（<strong>外观模式</strong>）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>　　Factory Method（<strong>工厂模式</strong>）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。<br>　　Flyweight（<strong>享元模式</strong>）：运用共享技术有效地支持大量细粒度的对象。<br>　　Interpreter（<strong>解析器模式</strong>）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。<br>　　Iterator（<strong>迭代器模式</strong>）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。<br>　　Mediator（<strong>中介模式</strong>）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>　　Memento（<strong>备忘录模式</strong>）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。<br>　　Observer（<strong>观察者模式</strong>）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。<br>　　Prototype（<strong>原型模式</strong>）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。<br>　　Proxy（<strong>代理模式</strong>）：为其他对象提供一个代理以控制对这个对象的访问。<br>　　Singleton（<strong>单例模式</strong>）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在九月的专栏中，David Geary探讨了单例模式以及在面对多线程（multi-threading）、类装载器（class loaders）和序列化（serialization）时如何处理这些缺陷。<br>　　State（<strong>状态模式</strong>）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。<br>　　Strategy（<strong>策略模式</strong>）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。<br>　　Template Method（<strong>模板方法模式</strong>）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>　　Visitor（<strong>访问者模式</strong>）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<h4 id="2-2-设计模式分类"><a href="#2-2-设计模式分类" class="headerlink" title="2.2 设计模式分类"></a><strong>2.2 设计模式分类</strong></h4><p>按照使用功能，设计模式一共分为以下三个大类：</p>
</li>
<li><p><strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
</li>
<li><strong>结构型模式</strong>，共七种：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a><strong>3. 总结</strong></h2>　　设计模式是编程经验的总结，系统的学习设计模式有利于项目的构建，接下来会对每个设计模式进行详细的学习。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/11/《Java编程思想》学习笔记之并发/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/11/《Java编程思想》学习笔记之并发/" itemprop="url">
                  《Java编程思想》学习笔记之并发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-11T13:32:29+08:00">
                2017-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2017/02/11/《Java编程思想》学习笔记之并发/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之并发">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　Java是一种多线程语言，并且提出来了并发问题。通过并发编程，能够提高程序的执行速度，但同时也会带来一些数据安全问题。本章主要对Java并发编程的知识进行学习。<br>  本章要点：</p>
<ol>
<li>多线程的概念</li>
<li>线程创建的方式（两种方式、匿名内部类创建、守护线程）</li>
<li>Executor与线程池</li>
<li>join()、sleep()和yield()方法</li>
<li>同步方法与同步代码块</li>
<li>多线程之间的通信</li>
<li>死锁<h2 id="1-多线程的概念"><a href="#1-多线程的概念" class="headerlink" title="1.多线程的概念"></a><strong>1.多线程的概念</strong></h2>　　实现并发有两种方式，分别是多<strong>进程</strong>和多<strong>线程</strong>。</li>
</ol>
<p>　　多进程概念及特点 ：</p>
<ol>
<li>它是运行在自己的<strong>地址空间</strong>内的自包容的程序。</li>
<li>它是多任务操作系统实现的，多任务操作系统可以通过周期性地将CPU从一个进程切换到另一个进程，来实现同时运行多个进程。如打开QQ程序和酷狗音乐程序，他们就是两个不同的进程。</li>
<li>每个任务作为进程都是在自己的地址空间中执行，任务之间不可能有干涉，它们是<strong>相互独立</strong>的，之间没有任何彼此通信的需要。</li>
</ol>
<p>　　对进程通常会有数量和开销的限制，Java在顺序型语言的基础上提供对线程的支持。</p>
<p>　　多线程概念及特点：</p>
<ol>
<li>线程是程序执行的一条路径，单个进程可以拥有多个线程。</li>
<li>线程之间<strong>共享</strong>数据资源和地址空间。</li>
<li>线程之间并不独立，需要<strong>互相通信</strong>，由程序进行保证。</li>
</ol>
<p>　　 任何一个Java程序都是多线程的，因为它至少包含有一个主线程和一个垃圾回收线程。</p>
<h2 id="2-线程的创建方式"><a href="#2-线程的创建方式" class="headerlink" title="2.线程的创建方式"></a><strong>2.线程的创建方式</strong></h2><p>　　创建线程有两种方式，分别是：继承Thread类和实现Runnable接口。</p>
<h4 id="2-1继承Thread类创建线程"><a href="#2-1继承Thread类创建线程" class="headerlink" title="2.1继承Thread类创建线程"></a><strong>2.1继承Thread类创建线程</strong></h4><p>  　　通过继承Thread类创建线程有以下几个必不可少的步骤：<br>  　　步骤一：创建一个类继承Thread；<br>  　　步骤二：重写run()方法，在方法中写入要执行的任务，这是线程执行的方法主体；<br>　　  步骤三：创建线程对象；<br> 　　 步骤四：开启新线程；<br> 　　 程序示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo1 extends Thread&#123;  //步骤一</div><div class="line">	public void run()&#123;                    //步骤二</div><div class="line">		for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			System.out.println(&quot;Hello World!!!&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ThreadDemo1 t = new ThreadDemo1();//步骤三</div><div class="line">		t.start();                        //步骤四</div><div class="line">		for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			System.out.println(&quot;-------Hello Java!!!--------&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在上述示例中，显式的有两个线程，分别是线程t和主线程main，线程t打印Hello World!!!，主线程main打印——-Hello Java!!!——–<br>　　程序输出的部分片段为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-------Hello Java!!!--------</div><div class="line">-------Hello Java!!!--------</div><div class="line">Hello World!!!</div><div class="line">Hello World!!!</div><div class="line">Hello World!!!</div><div class="line">Hello World!!!</div><div class="line">Hello World!!!</div><div class="line">-------Hello Java!!!--------</div><div class="line">-------Hello Java!!!--------</div></pre></td></tr></table></figure>
<p>从输出结果可以看出，输出是没有顺序的，相互穿插。这是由于，线程执行的时间片是由线程调度器负责划分的，顺序和时间是随机的，所以每次运行的结果可能都不一样。</p>
<h4 id="2-2-实现Runnable接口创建线程"><a href="#2-2-实现Runnable接口创建线程" class="headerlink" title="2.2 实现Runnable接口创建线程"></a><strong>2.2 实现Runnable接口创建线程</strong></h4><p>　　除了继承Thread类来创建线程，还可以通过实现Runnable接口来创建线程。通过这种方式创建线程，需要以下几个步骤：<br>  　　步骤一：创建一个类，实现Runnable接口；<br>    　　步骤二：重写run()方法，在方法中写入要执行的任务；<br>      　　步骤三：创建自定义的Runnable子类对象；<br>        　　步骤四：创建Thread线程对象，把上一步创建的Runnable子类对象传入Thread构造参数中；<br>          　　步骤五：开启线程，执行任务；<br>            　　程序示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo2 implements Runnable&#123;//步骤一</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;//步骤二</div><div class="line">		for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			System.out.println(&quot;Hello World!!!&quot;);</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ThreadDemo2 td = new ThreadDemo2();//步骤三</div><div class="line">		Thread t = new Thread(td);//步骤四</div><div class="line">		t.start();//步骤五</div><div class="line">		for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			System.out.println(&quot;-------Hello Java!!!--------&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果片段为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Hello World!!!</div><div class="line">-------Hello Java!!!--------</div><div class="line">-------Hello Java!!!--------</div><div class="line">Hello World!!!</div></pre></td></tr></table></figure>
<h4 id="2-3-两种创建线程方式的比较"><a href="#2-3-两种创建线程方式的比较" class="headerlink" title="2.3 两种创建线程方式的比较"></a><strong>2.3 两种创建线程方式的比较</strong></h4><p>　　从上述示例中也可以看出，两种方式创建线程有以下区别：<br>  　　继承Thread的类自动拥有了Thread类的方法，可以直接调用start()方法来开启线程；实现Runnable接口的类需要先创建自定义的类的对象，然后把这个对象作为参数传入Thread构造方法中才能创建线程，进而再调用start方法来开启线程</p>
<p>   两种方式的优缺点比较：</p>
<ol>
<li>继承Thread类创建线程可以直接使用Thread类的方法，代码更加简单，而通过实现Runnable接口创建线程则相对复杂；</li>
<li>Java只支持单继承，却支持多实现。 继承Thread类后就不能再继承别的类，实现Runnable接口后还可以继承别的类和实现别的接口。因此，实现Runnable接口创建线程的程序拓展性更好；</li>
</ol>
<h4 id="2-4-通过匿名内部类方式创建线程"><a href="#2-4-通过匿名内部类方式创建线程" class="headerlink" title="2.4 通过匿名内部类方式创建线程"></a><strong>2.4 通过匿名内部类方式创建线程</strong></h4><p>  　有的时候，通过匿名内部类把线程代码隐藏在类中能够有效的简化代码。</p>
<h4 id="2-4-1-匿名内部类继承Thread创建线程"><a href="#2-4-1-匿名内部类继承Thread创建线程" class="headerlink" title="2.4.1 匿名内部类继承Thread创建线程"></a><strong>2.4.1 匿名内部类继承Thread创建线程</strong></h4><p>   　继承Thread类创建线程的方式通过匿名内部类的方式可以表示为如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo3 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//匿名内部类代码</div><div class="line">		new Thread()&#123;</div><div class="line">			public void run()&#123;</div><div class="line">			for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">				System.out.println("Hello World!!!");</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">      &#125;.start();</div><div class="line">      //主线程执行代码</div><div class="line">      for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			System.out.println("-------Hello Java!!!--------");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码与ThreadDemo1.java的代码是一致的。<br>也可以表示如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo4 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//匿名内部类代码</div><div class="line">		Thread t = new Thread()&#123;  //父类引用指向子类对象</div><div class="line">			public void run()&#123;</div><div class="line">			for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">				System.out.println("Hello World!!!");</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">      &#125;;</div><div class="line">		t.start();</div><div class="line">      //主线程执行代码</div><div class="line">      for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			System.out.println("-------Hello Java!!!--------");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过父类的引用指向匿名子类的对象，然后再进行方法的调用，类似于多态的体现。</p>
<h4 id="2-4-2-匿名内部类实现Runnable接口创建线程"><a href="#2-4-2-匿名内部类实现Runnable接口创建线程" class="headerlink" title="2.4.2 匿名内部类实现Runnable接口创建线程"></a><strong>2.4.2 匿名内部类实现Runnable接口创建线程</strong></h4><p>　　匿名内部类实现Runnable接口创建线程示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo5 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//匿名内部类实现Runnable接口</div><div class="line">		new Thread(new Runnable()&#123;public void run() &#123;</div><div class="line">			for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">				System.out.println("Hello World!!!");</div><div class="line">			&#125;	</div><div class="line">		&#125;&#125;).start();</div><div class="line">		</div><div class="line">		for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			System.out.println("-------Hello Java!!!--------");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码与ThreadDemo2.java是一致的，也可以通过如下方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo6 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//匿名内部类实现Runnable接口</div><div class="line">		Thread t = new Thread(new Runnable()&#123;public void run() &#123;</div><div class="line">			for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">				System.out.println("Hello World!!!");</div><div class="line">			&#125;	</div><div class="line">		&#125;&#125;);</div><div class="line">		t.start();</div><div class="line">		</div><div class="line">		for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			System.out.println("-------Hello Java!!!--------");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-5-Thread名称的设置和获取方法"><a href="#2-5-Thread名称的设置和获取方法" class="headerlink" title="2.5 Thread名称的设置和获取方法"></a><strong>2.5 Thread名称的设置和获取方法</strong></h4><p>线程名称的获取是通过getName()方法实现的，首先通过Thread.currentThread()获得当前线程对象，再通过getName()获取线程名。在Java线程会有默认的名字。比如，对于ThreadDemo1类，我们在两个输出语句中加入Thread.currentThread().getName()，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(Thread.currentThread().getName()+"---"+"Hello World!!!");</div><div class="line">System.out.println(Thread.currentThread().getName()+"---"+"-------Hello Java!!!--------");</div></pre></td></tr></table></figure>
<p>那么输出的结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">main----------Hello Java!!!--------</div><div class="line">Thread-<span class="number">0</span>---Hello World!!!</div></pre></td></tr></table></figure>
<p>　　可以看出，主线程的名字就是main，而自定义线程都是从Thread-0开始编号的。<br>　　在实际使用中，可能需要给线程取个性化的名称，设置线程名有两种方法：<br><strong>第一种方法：通过构造方法传入线程名</strong><br>Thread的构造方法可以接受字符串类型作为自己的线程名，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">new Thread("我是自定义线程")&#123;</div><div class="line">			public void run()&#123;</div><div class="line">			for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">				System.out.println(Thread.currentThread().getName()+"---"+"Hello World!!!");</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">      &#125;.start();</div></pre></td></tr></table></figure>
<p>运行结果为;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我是自定义线程---Hello World!!!</div></pre></td></tr></table></figure>
<p><strong>第二种方法：通过setName()设置线程名</strong><br>有了线程对象后，可以通过setName()设置线程的名字，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ThreadDemo1 t = new ThreadDemo1();</div><div class="line">		t.setName("woshixiancheng");</div><div class="line">		t.start();</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">woshixiancheng---Hello World!!!</div></pre></td></tr></table></figure>
<h4 id="2-6-守护线程的创建"><a href="#2-6-守护线程的创建" class="headerlink" title="2.6 守护线程的创建"></a><strong>2.6 守护线程的创建</strong></h4><p>　　守护线程是指在程序运行的时候在后台提供一种通用服务的线程，当所有非守护线程结束的时候，守护线程终止。按照理解，Java程序中主线程main是非守护线程，而垃圾回收线程是守护线程。设置守护线程的方法非常简单，那就是在线程启动之前调用setDemo()方法，就能够将普通线程设置为守护线程。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo7 extends Thread&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int i=0;i&lt;1000;i++)&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName()+"---"+"Hello World!!!");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ThreadDemo1 t = new ThreadDemo1();</div><div class="line">		t.setName("woshixiancheng");</div><div class="line">		t.setDaemon(true);//设置为守护线程</div><div class="line">		t.start();</div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName()+"---"+"-------Hello Java!!!--------");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，线程t被设置为守护线程，而主线程main仍然是普通线程。按照程序设定，主线程会有十条输出语句，而线程t会有1000条输出语句。但是由于线程t被设置称为守护线程，当主线程结束的时候，守护线程也就随之结束，不进行后续的打印工作。</p>
<h2 id="3-Executor与线程池"><a href="#3-Executor与线程池" class="headerlink" title="3.Executor与线程池"></a><strong>3.Executor与线程池</strong></h2><p>　　在Java se5之后，Java提供了执行器Executor来管理Thread对象，简化了并发编程。使用单个的Executor就能够创建和管理系统中的所有任务。Executor还有一个关闭方法shutdown()，该方法的调用可以防止新任务被提交给这个Executor，当前线程将继续运行在shutdown()被调用之前提交的任务。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">import java.util.concurrent.*;</div><div class="line"></div><div class="line">public class ThreadDemo8 extends Thread&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			System.out.println(Thread.currentThread().getName()+"---"+"Hello World!!!");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">     ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">		for(int i=0;i&lt;5;i++)</div><div class="line">        //线程创建并开启线程</div><div class="line">			exec.execute(new ThreadDemo8());</div><div class="line">			exec.shutdown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　上述示例中，创建了5个线程，统一交给了线程池进行管理。<br>  　　上述程序中使用的线程池是CachedThread，在Java中，线程池有三种，分别如下：</p>
<ul>
<li>CachedThreadPool，在程序执行过程中创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，它是Executor的首选；</li>
<li>FixedThreadPool，限制线程的数量，一次性预先执行代价高昂的线程分配。能够节省时间，不用为每个任务都固定的付出创建线程的开销；</li>
<li>singleThreadExecutor，类似线程数量为1的FixedThreadPool。如果向SingleThreadExecutor提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前结束运行结束，所有的任务将使用相同的线程。</li>
</ul>
<h2 id="4-join-、sleep-和yield-方法"><a href="#4-join-、sleep-和yield-方法" class="headerlink" title="4.join()、sleep()和yield()方法"></a><strong>4.join()、sleep()和yield()方法</strong></h2><p>　　对于线程而言，一共有五种存在状态，分别是:<br>　　第一种：新建状态(New)，新建一个线程对象；<br>　　第二种：就绪状态（Runnable），线程创建之后，调用start方法开启线程。该线程即处于就绪状态，等待获取CPU的使用权；<br>　　第三种：运行状态（Running），就绪状态的线程获取到了CPU执行权，转入执行状态；<br>　　第四种：阻塞状态（Blocked），线程因为某种原因放弃CPU执行权，暂时停止运行。直到线程进入就绪状态，才可能获取执行权进行运行。<br>　　第五种：死亡状态（Dead），线程执行完或者因为其他原因退出了run()方法，线程结束生命周期。<br>　　join()、sleep()和yield()就涉及到这几种状态的切换。</p>
<h4 id="4-1-join"><a href="#4-1-join" class="headerlink" title="4.1  join()"></a><strong>4.1  join()</strong></h4><p>　　join()按字面意思理解就是加入一个线程。使用方式是在其他线程上进行调用，也就是插队。一般有两种方式：<br>　　第一：join()，当前线程停止，直到第二个线程执行结束后才能继续执行。如果某个线程上调用join()，那么该线程将进入阻塞状态，直到目标线程结束才恢复为就绪状态。<br>  　　第二：join(int),指定毫秒数，在指定的时间结束后线程才进入就绪状态。<br>    　　如以下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo9 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		final Thread t1 =new Thread()&#123;</div><div class="line">			public void run()&#123;</div><div class="line">				for(int i=0;i&lt;=1000;i++)</div><div class="line">					System.out.println(getName()+&quot;--------Hello World--------&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		</div><div class="line">		Thread t2 =new Thread()&#123;</div><div class="line">			public void run()&#123;</div><div class="line">				for(int i=0;i&lt;=1000;i++)&#123;</div><div class="line">					if(i%10==0)&#123;</div><div class="line">						try &#123;</div><div class="line">							//t1.join();</div><div class="line">							t1.join(3);</div><div class="line">						&#125; catch (InterruptedException e) &#123;</div><div class="line">							// TODO Auto-generated catch block</div><div class="line">							e.printStackTrace();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					else System.out.println(getName()+&quot;Hello Java&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">		</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在上述示例中，在线程t2中调用t1.join（），使得t1插了t2的队。<br>　　需要注意的是：join()方法是可能产生异常的，而异常不能跨线程传递回main(),所以必须在本地处理所有在线程内部产生的异常。</p>
<h4 id="4-2-sleep"><a href="#4-2-sleep" class="headerlink" title="4.2 sleep()"></a><strong>4.2 sleep()</strong></h4><p>sleep方法也是Thread的一个重要方法，调用sleep()将使任务终止执行给定的时间，如下，利用sleep方法来实现倒计时的输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo10 extends Thread&#123;</div><div class="line">	private int NUM=5;</div><div class="line">	public void run()&#123;</div><div class="line">    	while(NUM&gt;0)&#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">    	System.out.println("倒计时第"+NUM--+"秒");</div><div class="line">    	&#125;</div><div class="line">   </div><div class="line">    &#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		Thread t = new ThreadDemo10();</div><div class="line">		t.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">倒计时第<span class="number">5</span>秒</div><div class="line">倒计时第<span class="number">4</span>秒</div><div class="line">倒计时第<span class="number">3</span>秒</div><div class="line">倒计时第<span class="number">2</span>秒</div><div class="line">倒计时第<span class="number">1</span>秒</div></pre></td></tr></table></figure>
<p>　　如上示例，线程进入run方法后，会先睡眠1秒，然后按照间隔一秒的时间进行倒计时的输出。sleep方法也会抛出异常，需要在内部进行捕获。</p>
<h4 id="4-2-yeild"><a href="#4-2-yeild" class="headerlink" title="4.2 yeild()"></a><strong>4.2 yeild()</strong></h4><p>  yeild()也是Thread的一个方法，它的使用与sleep方法有一些类似，区别是：<br> 　　 sleep()方法使线程从运行状态转入阻塞状态，直到睡醒之后，线程才进入就绪状态。所以，执行了sleep()方法的线程在指定的时间内肯定不会被执行；<br>  　　yeild()方法是让当前执行的线程让出CPU执行权，从运行状态到就绪状态，但是让出的时间是不可设定的。</p>
<h2 id="5-同步方法与同步代码块"><a href="#5-同步方法与同步代码块" class="headerlink" title="5.同步方法与同步代码块"></a><strong>5.同步方法与同步代码块</strong></h2><p>　　如果有两个以上的任务在访问并操作相同的资源，就会造成线程冲突，并且导致 不正确的结果。Java是采用序列化访问共享资源的方式来解决线程冲突问题的。通过关键字synchronized来同步执行语句或者方法，在给定时刻只允许一个线程访问资源。Java中有同步代码块和同步方法两种。</p>
<h4 id="5-1-同步代码块"><a href="#5-1-同步代码块" class="headerlink" title="5.1 同步代码块"></a><strong>5.1 同步代码块</strong></h4><p>如以下的示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo12 &#123;</div><div class="line">    </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Count c = new Count();</div><div class="line">		Thread t1 = new Thread(c,"A");</div><div class="line">		Thread t2 = new Thread(c,"B");</div><div class="line">		Thread t3 = new Thread(c,"C");</div><div class="line">		</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		t3.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Count implements Runnable&#123;</div><div class="line">    private int NUM=100;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		while(true)&#123;</div><div class="line">		if(NUM&gt;0)</div><div class="line">			&#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(50);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+".....剩下的个数为"+NUM--);</div><div class="line">		&#125;</div><div class="line">	  &#125;		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　三个线程A、B、C分别操作同一个资源，对NUM进行自减操作，正常来说，程序运行的结果是从100到1。截取到的最后的运行结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C.....剩下的个数为<span class="number">2</span></div><div class="line">B.....剩下的个数为<span class="number">1</span></div><div class="line">A.....剩下的个数为<span class="number">0</span></div><div class="line">C.....剩下的个数为-<span class="number">1</span></div></pre></td></tr></table></figure>
<p>　　程序运行出现了负数，这是因为程序执行到NUM为1的时候，线程B验证了执行条件后睡眠了，此时NUM为１，线程A也通过了验证，进入了任务，同理，C也进入了任务。此时，线程都通过验证，又相继醒来，继续执行下面的代码，连续“－－”了三次后，出现了错误的输出结果。<br>　　　此时，把执行代码块加上同步，就可以保证只有一个线程在进行执行语句，就能够避免不正确的输出，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo12 &#123;</div><div class="line">    </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Count c = new Count();</div><div class="line">		Thread t1 = new Thread(c,"A");</div><div class="line">		Thread t2 = new Thread(c,"B");</div><div class="line">		Thread t3 = new Thread(c,"C");</div><div class="line">		</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		t3.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Count implements Runnable&#123;</div><div class="line">    private int NUM=100;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		while(true)&#123;</div><div class="line">        //加上同步</div><div class="line">		synchronized(this)&#123;</div><div class="line">		if(NUM&gt;0)</div><div class="line">			&#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(50);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+".....剩下的个数为"+NUM--);</div><div class="line">		&#125;	</div><div class="line">	  &#125;</div><div class="line">	  &#125;		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后几条的输出为:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A.....剩下的个数为<span class="number">3</span></div><div class="line">A.....剩下的个数为<span class="number">2</span></div><div class="line">C.....剩下的个数为<span class="number">1</span></div></pre></td></tr></table></figure>
<p>无论进行多少次运行，程序的输出都符合逻辑。</p>
<h4 id="5-2-非静态方法同步"><a href="#5-2-非静态方法同步" class="headerlink" title="5.2 非静态方法同步"></a><strong>5.2 非静态方法同步</strong></h4><p>　　除了给一些代码同步，也可以给方法进行同步，当在对象上调用任意被synchronized修饰的方法时，此对象都被加上锁，这时，该对象的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能够被调用。<br>  　　编写一段代码对同步方法进行测试，模拟银行的存钱和取钱功能。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">    package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo13 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		final Bank b = new Bank();</div><div class="line">		Thread t1 = new Thread(&quot;取钱线程&quot;)&#123;</div><div class="line">			public void run() &#123;</div><div class="line">				for(int i=0;i&lt;5;i++)		</div><div class="line">				&#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(20);</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						// TODO Auto-generated catch block</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					b.dep(100);</div><div class="line">				&#125;				</div><div class="line">			&#125;	</div><div class="line">		&#125;;</div><div class="line">		Thread t2 = new Thread(&quot;存钱线程&quot;)&#123;</div><div class="line">			public void run() &#123;</div><div class="line">				for(int i=0;i&lt;10;i++)		</div><div class="line">				&#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(20);</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						// TODO Auto-generated catch block</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					b.add(100);</div><div class="line">				&#125;				</div><div class="line">			&#125;	</div><div class="line">		&#125;;</div><div class="line">	</div><div class="line">		</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bank&#123;</div><div class="line">	private int Money=1000;</div><div class="line">	public void dep(int num)&#123;</div><div class="line">		Money-=num;</div><div class="line">		System.out.println(Thread.currentThread().getName()+&quot;花了100元------------账户还有&quot;+Money+&quot;元钱&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public  void add(int num)&#123;</div><div class="line">		Money+=num;</div><div class="line">		System.out.println(Thread.currentThread().getName()+&quot;存了100元。。。账户有&quot;+Money+&quot;元钱&quot;);</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　如上，Bank类有两个方法，分别是存钱方法和取钱方法，钱的金额基数是1000元。利用匿名内部类创建两个线程任务，取钱线程负责取钱，取5次，一次取100元；存钱线程负责存钱，存10次，一次100元.正常理解下，最后的金额应该是1500元。<br>  　　运行程序，有一次得到如下结果；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">存钱线程存了100元。。。账户有900元钱</div><div class="line">取钱线程花了100元------------账户还有900元钱</div><div class="line">取钱线程花了100元------------账户还有800元钱</div><div class="line">存钱线程存了100元。。。账户有900元钱</div><div class="line">存钱线程存了100元。。。账户有800元钱</div><div class="line">取钱线程花了100元------------账户还有800元钱</div><div class="line">存钱线程存了100元。。。账户有900元钱</div><div class="line">取钱线程花了100元------------账户还有800元钱</div><div class="line">取钱线程花了100元------------账户还有800元钱</div><div class="line">存钱线程存了100元。。。账户有800元钱</div><div class="line">存钱线程存了100元。。。账户有900元钱</div><div class="line">存钱线程存了100元。。。账户有1000元钱</div><div class="line">存钱线程存了100元。。。账户有1100元钱</div><div class="line">存钱线程存了100元。。。账户有1200元钱</div><div class="line">存钱线程存了100元。。。账户有1300元钱</div></pre></td></tr></table></figure>
<p>　　由结果可以看出，数据访问产生混乱，结果也不可靠。在这种情况下，把取钱和存钱方法加上锁，进行同步，如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public synchronized void dep(int num) &#123; &#125;；</div><div class="line">public  synchronized void add(int num) &#123; &#125;；</div></pre></td></tr></table></figure>
<p>　　加锁进行同步之后，只有存钱或者取钱操作完成之后，另外的线程才能进行操作。在非同步方法中，锁对象是this，也就是调用的实例对象。进行同步处理之后，多次运行，结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">取钱线程花了<span class="number">100</span>元------------账户还有<span class="number">900</span>元钱</div><div class="line">存钱线程存了<span class="number">100</span>元。。。账户有<span class="number">1000</span>元钱</div><div class="line">存钱线程存了<span class="number">100</span>元。。。账户有<span class="number">1100</span>元钱</div><div class="line">取钱线程花了<span class="number">100</span>元------------账户还有<span class="number">1000</span>元钱</div><div class="line">取钱线程花了<span class="number">100</span>元------------账户还有<span class="number">900</span>元钱</div><div class="line">存钱线程存了<span class="number">100</span>元。。。账户有<span class="number">1000</span>元钱</div><div class="line">取钱线程花了<span class="number">100</span>元------------账户还有<span class="number">900</span>元钱</div><div class="line">存钱线程存了<span class="number">100</span>元。。。账户有<span class="number">1000</span>元钱</div><div class="line">取钱线程花了<span class="number">100</span>元------------账户还有<span class="number">900</span>元钱</div><div class="line">存钱线程存了<span class="number">100</span>元。。。账户有<span class="number">1000</span>元钱</div><div class="line">存钱线程存了<span class="number">100</span>元。。。账户有<span class="number">1100</span>元钱</div><div class="line">存钱线程存了<span class="number">100</span>元。。。账户有<span class="number">1200</span>元钱</div><div class="line">存钱线程存了<span class="number">100</span>元。。。账户有<span class="number">1300</span>元钱</div><div class="line">存钱线程存了<span class="number">100</span>元。。。账户有<span class="number">1400</span>元钱</div><div class="line">存钱线程存了<span class="number">100</span>元。。。账户有<span class="number">1500</span>元钱</div></pre></td></tr></table></figure>
<h4 id="5-3-静态方法同步"><a href="#5-3-静态方法同步" class="headerlink" title="5.3 静态方法同步"></a><strong>5.3 静态方法同步</strong></h4><p>　　静态方法的同步与非静态方法的同步有以下几点区别：</p>
<ul>
<li>静态方法操作的是静态数据，要用static修饰。非静态方法操作的是成员数据，要通过实例化对象进行调用。</li>
<li>非静态方法的锁对象是this，而静态方法的锁对象是类的字节码文件。<br>　　同样的代码改变如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo13 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Thread t1 = new Thread("取钱线程")&#123;</div><div class="line">			public void run() &#123;</div><div class="line">				for(int i=0;i&lt;5;i++)		</div><div class="line">				&#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(20);</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						// TODO Auto-generated catch block</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					Bank.dep(100);</div><div class="line">				&#125;				</div><div class="line">			&#125;	</div><div class="line">		&#125;;</div><div class="line">		Thread t2 = new Thread("存钱线程")&#123;</div><div class="line">			public void run() &#123;</div><div class="line">				for(int i=0;i&lt;10;i++)		</div><div class="line">				&#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(20);</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						// TODO Auto-generated catch block</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					Bank.add(100);</div><div class="line">				&#125;				</div><div class="line">			&#125;	</div><div class="line">		&#125;;</div><div class="line">	</div><div class="line">		</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bank&#123;</div><div class="line">	private static int Money=1000;</div><div class="line">	public synchronized static void dep(int num)&#123;</div><div class="line">		Money-=num;</div><div class="line">		System.out.println(Thread.currentThread().getName()+"花了100元------------账户还有"+Money+"元钱");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public  static synchronized void add(int num)&#123;</div><div class="line">		Money+=num;</div><div class="line">		System.out.println(Thread.currentThread().getName()+"存了100元。。。账户有"+Money+"元钱");</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;`enter code here`</div></pre></td></tr></table></figure>
<h4 id="5-4-显式的Lock对象"><a href="#5-4-显式的Lock对象" class="headerlink" title="5.4 显式的Lock对象"></a><strong>5.4 显式的Lock对象</strong></h4><p>　　之前的加锁都是用synchronized关键字进行修饰的，我们无法看到内部的上锁和解锁过程。在Java SE5之后，提供了类库支持显式的Lock接，Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。Lock接口一共有以下几个方法，分别是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void  lock()<span class="comment">//获取锁</span></div><div class="line">void lockInterruptibly()<span class="comment">//返回绑定到此 Lock 实例的新 Condition 实例</span></div><div class="line">boolean trylock()<span class="comment">//调用时锁为空闲状态才获取该锁</span></div><div class="line">boolean tryLock(long <span class="selector-tag">time</span>, TimeUnit unit)<span class="comment">//如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</span></div><div class="line">void unlock()<span class="comment">//释放锁</span></div></pre></td></tr></table></figure>
<p>Lock接口一共有三个实现类，分别如下：</p>
<ul>
<li>ReentrantLock，它是一个可重入的互斥锁 Lock，具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</li>
<li>ReentrantReadWriteLock.ReadLock</li>
<li>ReentrantReadWriteLock.WriteLock<br>　其中，ReentrantLock类是最常用的，它实现了Lock接口的方法，在实际使用中，可以完成对 synchronized的替代。利用Lock锁对象替换ThreadDemo13的代码，功能实现如下;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line">public class ThreadDemo14 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Thread t1 = new Thread("取钱线程")&#123;</div><div class="line">			public void run() &#123;</div><div class="line">				for(int i=0;i&lt;5;i++)		</div><div class="line">				&#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(20);</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						// TODO Auto-generated catch block</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					Bank1.dep(100);</div><div class="line">				&#125;				</div><div class="line">			&#125;	</div><div class="line">		&#125;;</div><div class="line">		Thread t2 = new Thread("存钱线程")&#123;</div><div class="line">			public void run() &#123;</div><div class="line">				for(int i=0;i&lt;10;i++)		</div><div class="line">				&#123;</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(20);</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						// TODO Auto-generated catch block</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					Bank1.add(100);</div><div class="line">				&#125;				</div><div class="line">			&#125;	</div><div class="line">		&#125;;</div><div class="line">	</div><div class="line">		</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bank1&#123;</div><div class="line">	private static final ReentrantLock lock = new ReentrantLock();</div><div class="line">	private static int Money=1000;</div><div class="line">	public static void dep(int num)&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">		Money-=num;</div><div class="line">		System.out.println(Thread.currentThread().getName()+"花了100元------------账户还有"+Money+"元钱");</div><div class="line">		&#125;</div><div class="line">		finally&#123;</div><div class="line">		lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public  static  void add(int num)&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">		Money+=num;</div><div class="line">		System.out.println(Thread.currentThread().getName()+"存了100元。。。账户有"+Money+"元钱");</div><div class="line">		&#125;</div><div class="line">		finally&#123;</div><div class="line">		lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现的功能与synchronized一致，需要注意的是：</p>
<ol>
<li>synchronized对锁的释放是由JVM保证的，ReentrantLock必须通过unlock()来释放锁；</li>
<li>如果因为其他异常没有释放锁，程序会陷入崩溃，因此，对于unlock()方法，必须放在finally语句中，这样才能避免程序的死亡；<h2 id="6-多线程之间的通信"><a href="#6-多线程之间的通信" class="headerlink" title="6.多线程之间的通信"></a><strong>6.多线程之间的通信</strong></h2></li>
</ol>
<p>　　当使用线程来同时运行多个线程时，可以通过使用锁来同步两个线程，从而使得一个线程不会干涉另一个线程的资源，这样就解决了线程之间的干涉问题。而线程之间有时候需要进行通信和协作，比如线程之间的运行的顺序。<br>多线程之间的通信最经典的例子是生产者-消费者模型，下面用代码表述如何实现模型。</p>
<h4 id="6-1-wait-、notify-与notifyAll"><a href="#6-1-wait-、notify-与notifyAll" class="headerlink" title="6.1 wait()、notify()与notifyAll()"></a><strong>6.1 wait()、notify()与notifyAll()</strong></h4><p>通过 wait()、notify()能够实现线程之间的通信。关于这几个方法，需要注意的是：</p>
<ol>
<li>wait()、notify()与notifyAll()是基类Object的方法。因为这些方法是被锁对象进行调用的，而锁可以是任意对象，所以必须把这几个方法设置为基类的方法</li>
<li>wait()期间，对象锁是释放的。这与sleep()不同，线程在sleep期间，锁并没有被释放。而在wait期间将释放锁，这意味着其他的线程可以获得这个锁</li>
<li>只能够在同步方法或者同步代码块里面才能够调用这几个方法，因为在调用这几个方法前必须先拥有对象的锁</li>
</ol>
<p>　　如果有一个资源和两个线程，一个负责生产，一个负责消费。生产一个消费一个，为了让线程能够按照预定的方式进行运转，需要调用如上的几个方法。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo15 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Resource r = new Resource();</div><div class="line">		Producer p = new Producer(r);</div><div class="line">		Consumer c = new Consumer(r);</div><div class="line">		//创建生产者线程和消费者线程</div><div class="line">		Thread t1 = new Thread(p,"生产者");</div><div class="line">		Thread t2 = new Thread(c,"消费者");</div><div class="line">		</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//资源类</div><div class="line">class Resource&#123;</div><div class="line">    int Count=1;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//生产者</div><div class="line">class Producer implements Runnable&#123;</div><div class="line">	final private Resource r;</div><div class="line">	public Producer(Resource r)&#123;this.r = r;&#125;</div><div class="line">	public void run() &#123;</div><div class="line">		while(true)&#123;</div><div class="line">		   //对资源上锁</div><div class="line">			synchronized(r)&#123;</div><div class="line">				//如果资源数量不为零，不需要生产，线程等待wait()</div><div class="line">			while(r.Count!=0)&#123;	</div><div class="line">				try &#123;</div><div class="line">				r.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;&#125;</div><div class="line">			//如果资源数量为零，进行生产，资源数量加一</div><div class="line">			r.Count++;</div><div class="line">			System.out.println(Thread.currentThread().getName()+"--------生产了1份资源");</div><div class="line">			//唤醒其他线程</div><div class="line">			r.notify();	</div><div class="line">		&#125;	&#125;	</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//消费者</div><div class="line">class Consumer implements Runnable&#123;</div><div class="line">	final private Resource r;</div><div class="line">	public Consumer(Resource r)&#123;this.r = r;&#125;</div><div class="line">	public void run() &#123;</div><div class="line">		while(true)&#123;</div><div class="line">			//对资源上锁</div><div class="line">			synchronized(r)&#123;</div><div class="line">			//如果资源数量为0，消费者等待</div><div class="line">			while(r.Count==0)&#123;try &#123;</div><div class="line">				r.wait();</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;&#125;</div><div class="line">			//如果资源数量不为0,消耗一个资源</div><div class="line">			r.Count--;</div><div class="line">			System.out.println(Thread.currentThread().getName()+"消费了1份资源");</div><div class="line">			//唤醒其他线程</div><div class="line">			r.notify();		</div><div class="line">		&#125;	</div><div class="line">	  &#125;</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>截取运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">消费者消费了<span class="number">1</span>份资源</div><div class="line">生产者--------生产了<span class="number">1</span>份资源</div><div class="line">消费者消费了<span class="number">1</span>份资源</div><div class="line">生产者--------生产了<span class="number">1</span>份资源</div><div class="line">消费者消费了<span class="number">1</span>份资源</div><div class="line">生产者--------生产了<span class="number">1</span>份资源</div><div class="line">消费者消费了<span class="number">1</span>份资源</div><div class="line">生产者--------生产了<span class="number">1</span>份资源</div><div class="line">消费者消费了<span class="number">1</span>份资源</div><div class="line">生产者--------生产了<span class="number">1</span>份资源</div><div class="line">消费者消费了<span class="number">1</span>份资源</div><div class="line">生产者--------生产了<span class="number">1</span>份资源</div><div class="line">消费者消费了<span class="number">1</span>份资源</div><div class="line">生产者--------生产了<span class="number">1</span>份资源</div></pre></td></tr></table></figure>
<p>如上所示，程序能够顺利的按照消费-生产-消费的顺序进行。<br>另外，使用notify()时，在众多的同一个锁的线程中，只有一个被唤醒，如果使用notify()，就必须保证被唤醒的是恰当的线程。使用notifyAll()时，将唤醒所有等待该锁的线程</p>
<h4 id="6-2-await-，signal-和signalAll"><a href="#6-2-await-，signal-和signalAll" class="headerlink" title="6.2 await()，signal()和signalAll()"></a><strong>6.2 await()，signal()和signalAll()</strong></h4><p>　　 await()，signal()和signalAll()是Lock接口的方法，是与显式的Lock对象配合使用的，它所能够实现的功能和wait()、notify()与notifyAll()一样。所不同的是，通过Lock实例能够获取多个Condition实例，从而能定向的唤醒线程。<br>　　 使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　final Lock lock = new ReentrantLock();        //显式创建一个锁</div><div class="line">final Condition c1  = lock.newCondition();    //创建锁的第一个Condition实例</div><div class="line">final Condition c2 = lock.newCondition();     //创建锁的第二个Condition实例</div></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.Condition;</div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line">//测试代码</div><div class="line">public class ThreadDemo16 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//创建资源实例</div><div class="line">		 Food food = new Food();	</div><div class="line">		 //创建线程进行生产操作</div><div class="line">         new Thread(new Producer1(food)).start();</div><div class="line">        //创建线程进行消费操作</div><div class="line">         new Thread(new Consumer1(food)).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//生产者代码</div><div class="line">class Producer1 implements Runnable&#123;</div><div class="line">	private Food food;</div><div class="line">	public Producer1(Food food)&#123;this.food = food;&#125;</div><div class="line">	//覆写run房法，调用生产方法</div><div class="line">	public void run() &#123;</div><div class="line">		food.put();	</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//消费者代码</div><div class="line">class Consumer1 implements Runnable&#123;</div><div class="line">	private Food food;</div><div class="line">	public Consumer1(Food food)&#123;this.food = food;&#125;</div><div class="line">	//覆写run方法，调用消费方法</div><div class="line">	public void run() &#123;</div><div class="line">		food.get();	</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//资源类</div><div class="line">class Food&#123;</div><div class="line">	private  int num=0;</div><div class="line">	//显式的创建锁对象</div><div class="line">	private Lock lock = new ReentrantLock();</div><div class="line">	//通过newCondition()方法创建两个Condition实例</div><div class="line">	private Condition c1 = lock.newCondition();</div><div class="line">	private Condition c2 = lock.newCondition();</div><div class="line">	</div><div class="line">	//生产方法</div><div class="line">	public void put()&#123;</div><div class="line">		//用锁进行同步</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">		while(true)&#123;</div><div class="line">			//进行判断，如果资源不为0，就用进行生产，线程等待</div><div class="line">			if(num!=0)</div><div class="line">				try &#123;</div><div class="line">					c1.await();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			//如果资源为零，打印语句，生产一个资源</div><div class="line">			System.out.println(Thread.currentThread().getName()+"放进了--------"+(++num)+"个资源");</div><div class="line">			//唤醒指定的线程</div><div class="line">			c2.signal();</div><div class="line">			</div><div class="line">		&#125;&#125;</div><div class="line">		//释放锁</div><div class="line">		finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//消费方法</div><div class="line">	public void get()&#123;</div><div class="line">		lock.lock();</div><div class="line">		try&#123;</div><div class="line">		while(true)&#123;</div><div class="line">			//如果资源数量为0,线程等待</div><div class="line">			if(num ==0)</div><div class="line">				try &#123;</div><div class="line">					c2.await();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			//如果资源数量不为0，取走一个资源，</div><div class="line">			System.out.println(Thread.currentThread().getName()+"取走了"+(num--)+"个资源");</div><div class="line">			//唤醒线程c1</div><div class="line">			c1.signal();</div><div class="line">			</div><div class="line">		&#125;&#125;</div><div class="line">		//释放锁</div><div class="line">		finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>上述程序示例运行的代码部分如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Thread-<span class="number">0</span>放进了--------<span class="number">1</span>个资源</div><div class="line">Thread-<span class="number">1</span>取走了<span class="number">1</span>个资源</div><div class="line">Thread-<span class="number">0</span>放进了--------<span class="number">1</span>个资源</div><div class="line">Thread-<span class="number">1</span>取走了<span class="number">1</span>个资源</div><div class="line">Thread-<span class="number">0</span>放进了--------<span class="number">1</span>个资源</div></pre></td></tr></table></figure>
<p>能够实现生产一个消费一个的循环。</p>
<h4 id="6-3-阻塞队列实现并发"><a href="#6-3-阻塞队列实现并发" class="headerlink" title="6.3 阻塞队列实现并发"></a><strong>6.3 阻塞队列实现并发</strong></h4><p>　　上面两个例子都是通过同步策略和线程唤醒机制来实现生产者-消费者模型的，还可以通过阻塞队列来实现这个模型。阻塞队列可以对线程进行阻塞，当消费者从阻塞队列中取元素，而队列此时为空时，消费者线程会被阻塞，直到队列中添加了元素。当队列中添加了新元素之后，消费者线程会自动被唤醒，不需要额外的代码进行实现。<br>  　　Java是在Java Se5之后提供阻塞队列的，常用的主要有以下几种：</p>
<ul>
<li>ArrayBlockingQueue，它是一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。它是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。 </li>
<li>LinkedBlockingQueue，它是一个由链表支持的阻塞队列，此队列按 FIFO（先进先出）排序元素，链接队列的吞吐量通常要高于基于数组的队列。</li>
<li>PriorityBlockingQueue，一个无界阻塞队列，它使用与类 PriorityQueue 相同的顺序规则，并且提供了阻塞获取操作。它不是FIFO原则进行排序，而是按照元素的优先级对元素进行排序。</li>
<li>DelayQueue，一个基于Delay的无界阻塞队列，只有在延迟期满时才能从中提取元素。它也是一个无界队列，往其中插入元素不会限制，但是向外取元素时会受到元素为空的限制。<br>和非阻塞队列不一样的是，阻塞队列包含了非阻塞队列的方法，且对这些方法进行了同步，另外还添加了四个方法用来实现线程阻塞。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">put</span><span class="params">()</span></span><span class="comment">//将指定元素从队尾加入队列，如果队列满，则线程等待；</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">take</span><span class="params">()</span></span><span class="comment">//从队首取出元素，如果队列为空，则线程等待；</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">offer</span><span class="params">()</span></span><span class="comment">//将指定的元素从队尾加入队列，如果队列满，则线程等待指定的时间，达到时间期限后，如果没有插入成功，则返回false，否则返回true</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">poll</span><span class="params">()</span></span><span class="comment">//从队首取出元素，如果队列为空，则等待指定的时间。达到时间期限后，如果没有取出成功，则返回false，否则返回true</span></div></pre></td></tr></table></figure>
<p>　　通过ArrayBlockingQueue阻塞队列来实现生产者-消费者模型，实现的代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">import java.util.concurrent.ArrayBlockingQueue;</div><div class="line"></div><div class="line">public class ThreadDemo17 &#123;</div><div class="line">        </div><div class="line">	private static final int SIZE = 10;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ThreadDemo17 td = new ThreadDemo17();</div><div class="line">		ArrayBlockingQueue&lt;String&gt; abq = new ArrayBlockingQueue&lt;String&gt;(SIZE);</div><div class="line">		td.new Producer3(abq).start();</div><div class="line">		td.new Consumer3(abq).start();</div><div class="line">		//new Thread(new Consumer3(abq)).start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">class Producer3 extends Thread&#123;</div><div class="line">	private ArrayBlockingQueue&lt;String&gt; abq = null;</div><div class="line">	public Producer3(ArrayBlockingQueue&lt;String&gt; abq)&#123;this.abq=abq;&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		while(true)&#123;</div><div class="line">			try &#123;</div><div class="line">				//System.out.println(Thread.currentThread().getName()+"---------准备存放数，还剩余的空间为"+(10-abq.size()));</div><div class="line">				abq.put("Hello  Java");</div><div class="line">				System.out.println(Thread.currentThread().getName()+"---------存放了一个数据，还剩余的空间为"+(10-abq.size()));</div><div class="line">				Thread.sleep(50);</div><div class="line"></div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;		</div><div class="line">		&#125;			</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Consumer3 extends Thread &#123;</div><div class="line">	private ArrayBlockingQueue&lt;String&gt; abq = null;</div><div class="line">	public Consumer3(ArrayBlockingQueue&lt;String&gt; abq)&#123;this.abq=abq;&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		while(true)&#123;</div><div class="line">			try &#123;</div><div class="line">				//System.out.println(Thread.currentThread().getName()+"目前有"+abq.size()+"个数据"+"准备取走数据");</div><div class="line">				abq.take();</div><div class="line">				System.out.println(Thread.currentThread().getName()+"从从队列中取走一个数据，"+"，还有"+abq.size()+"个数据");</div><div class="line">                Thread.sleep(100);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				// TODO Auto-generated catch block</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;		</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>部分运行代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread-<span class="number">0</span>---------存放了一个数据，还剩余的空间为<span class="number">9</span></div><div class="line">Thread-<span class="number">1</span>从从队列中取走一个数据，，还有<span class="number">0</span>个数据</div><div class="line">Thread-<span class="number">0</span>---------存放了一个数据，还剩余的空间为<span class="number">9</span></div><div class="line">Thread-<span class="number">0</span>---------存放了一个数据，还剩余的空间为<span class="number">8</span></div><div class="line">Thread-<span class="number">1</span>从从队列中取走一个数据，，还有<span class="number">1</span>个数据</div><div class="line">Thread-<span class="number">0</span>---------存放了一个数据，还剩余的空间为<span class="number">8</span></div><div class="line">Thread-<span class="number">0</span>---------存放了一个数据，还剩余的空间为<span class="number">7</span></div><div class="line">Thread-<span class="number">1</span>从从队列中取走一个数据，，还有<span class="number">2</span>个数据</div><div class="line">Thread-<span class="number">0</span>---------存放了一个数据，还剩余的空间为<span class="number">7</span></div><div class="line">Thread-<span class="number">0</span>---------存放了一个数据，还剩余的空间为<span class="number">6</span></div></pre></td></tr></table></figure>
<p>可以看出：put(),take()方法实现了同步和线程中的通信，从输出中可以看出来效果。<br>？？？在后面截取的数据中，有如下的一段：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Thread-<span class="number">1</span>从从队列中取走一个数据，，还有<span class="number">9</span>个数据</div><div class="line">Thread-<span class="number">0</span>---------存放了一个数据，还剩余的空间为<span class="number">0</span></div><div class="line">Thread-<span class="number">0</span>---------存放了一个数据，还剩余的空间为<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span>从从队列中取走一个数据，，还有<span class="number">10</span>个数据</div></pre></td></tr></table></figure>
<p>暂时还不知道原因，put(),take()方法实现了同步，能够确保数据的准确性，但是示例中的run()方法里面除了有这两个方法，还有自己设置的输出语句块，这些语句没有同步，是不是影响了最后的输出，但是并不会影响实际数据的存储，个人的理解，不知道是否正确。</p>
<h2 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7.死锁"></a><strong>7.死锁</strong></h2><p>　　死锁是多线程中常出现的一个问题，问题不容易被发现但同时是需要被避免的。　<br>    　　从哲学家吃饭问题来引申出死锁问题。假如有2个哲学家围绕在一个圆桌上等待吃饭，而一共只有2只筷子，放在哲学家中的中间位置。吃饭需要同时获取到身边的两只筷子。用代码表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo18 &#123;</div><div class="line">    private static String S1=&quot;筷子1&quot;;</div><div class="line">    private static String S2=&quot;筷子2&quot;;  		 </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread(&quot;哲学家1号----&quot;)&#123;</div><div class="line">			public void run()&#123;</div><div class="line">				while(true)&#123;</div><div class="line">					synchronized(S1)&#123;</div><div class="line">						System.out.println(Thread.currentThread().getName()+&quot;拿到了&quot;+S1+&quot;,等待&quot;+S2);</div><div class="line">						synchronized(S2)&#123;</div><div class="line">							System.out.println(Thread.currentThread().getName()+&quot;拿到了&quot;+S2+&quot;,开始吃饭了&quot;);</div><div class="line">						&#125;					</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		new Thread(&quot;哲学家2号&quot;)&#123;</div><div class="line">			public void run()&#123;</div><div class="line">				while(true)&#123;</div><div class="line">					synchronized(S2)&#123;</div><div class="line">						System.out.println(Thread.currentThread().getName()+&quot;拿到了&quot;+S2+&quot;,等待&quot;+S1);</div><div class="line">						synchronized(S1)&#123;</div><div class="line">							System.out.println(Thread.currentThread().getName()+&quot;拿到了&quot;+S1+&quot;,开始吃饭了&quot;);</div><div class="line">						&#125;					</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">1</span>,等待筷子<span class="number">2</span></div><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">2</span>,开始吃饭了</div><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">1</span>,等待筷子<span class="number">2</span></div><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">2</span>,开始吃饭了</div><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">1</span>,等待筷子<span class="number">2</span></div><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">2</span>,开始吃饭了</div><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">1</span>,等待筷子<span class="number">2</span></div><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">2</span>,开始吃饭了</div><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">1</span>,等待筷子<span class="number">2</span></div><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">2</span>,开始吃饭了</div><div class="line">哲学家<span class="number">2</span>号拿到了筷子<span class="number">2</span>,等待筷子<span class="number">1</span></div><div class="line">哲学家<span class="number">1</span>号----拿到了筷子<span class="number">1</span>,等待筷子<span class="number">2</span></div></pre></td></tr></table></figure>
<p>　　程序设定是无限循环的，但是运行到上述示例最后一行后，陷入了无线等待状态。哲学家2号拿到了筷子1，等待筷子2，而此时哲学家1号拿到了筷子2，在等待筷子1，他们谁也无法说服谁放下另一只筷子，陷入了死循环。</p>
<p>　　关于死锁问题，通过程序示例，可以总结出发生死锁时必须要满足的四个条件：<br>　　第一：互斥条件。任务使用的资源中至少有一个是不能共享的。程序中筷子就是资源，在某一时刻，一根筷子只能被一个哲学家使用，不能两个哲学家同时要使用一直筷子。<br>　　第二：至少有一个任务，它必须持有一个资源而且正在等待获取当前被别的任务所持有的资源。在程序中，哲学家2号持有了筷子2资源，等待筷子1资源，而筷子1资源此时正在被哲学家1号进行使用。<br>　　第三：资源不能被任务抢占。也就是说，哲学家2号不能去抢哲学家1号的筷子，哲学家1号也不能去抢哲学家2号的资源，都是文明人。<br>　　第四：必须有循环等待。一个任务在等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直循环，直到有一个任务等待第一个任务的资源。示例中是两个哲学家，也是处于循环等待的状态。如果是更多的哲学家坐在圆桌上，发生示例中的吃饭情况，也会发生死锁。</p>
<p>　　要发生死锁，上述四个条件必须同时满足。所以要防止死锁的话，只需要破坏其中的任意一个条件就行，目前来说，最容易破坏的就是第四个条件。拿上述示例来说，如果不让哲学家陷入循环等待，就可以打破死锁。解决的办法是两个哲学家都先抢占筷子1，如果其中一个先拿到了筷子1，接下来他可以继续拿筷子2，等他吃完之后，两者在进行新一轮的抢占。但是可以保证同时只有一个人吃饭。<br>　　改后的代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.Thread;</div><div class="line"></div><div class="line">public class ThreadDemo18 &#123;</div><div class="line">    private static String S1="筷子1";</div><div class="line">    private static String S2="筷子2";  		 </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread("哲学家1号----")&#123;</div><div class="line">			public void run()&#123;</div><div class="line">				while(true)&#123;</div><div class="line">					synchronized(S1)&#123;</div><div class="line">						System.out.println(Thread.currentThread().getName()+"拿到了"+S1+",等待"+S2);</div><div class="line">						synchronized(S2)&#123;</div><div class="line">							System.out.println(Thread.currentThread().getName()+"拿到了"+S2+",开始吃饭了");</div><div class="line">						&#125;					</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		new Thread("哲学家2号")&#123;</div><div class="line">			public void run()&#123;</div><div class="line">				while(true)&#123;</div><div class="line">					synchronized(S1)&#123;</div><div class="line">						System.out.println(Thread.currentThread().getName()+"拿到了"+S2+",等待"+S1);</div><div class="line">						synchronized(S2)&#123;</div><div class="line">							System.out.println(Thread.currentThread().getName()+"拿到了"+S1+",开始吃饭了");</div><div class="line">						&#125;					</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="８-总结"><a href="#８-总结" class="headerlink" title="８.总结"></a><strong>８.总结</strong></h2><ul>
<li>通过线程，可以运行多个独立的任务，能够提高程序运行的效率；</li>
<li>线程可能会在共享资源上进行干涉，同步互斥锁来进行同步，能防止这些冲突</li>
<li>引入锁机制后，可能会导致死锁的发生，要尽量避免死锁，不要在同步代码块中嵌套其他的同步代码块</li>
<li>具体的应用在进一步实战中进行学习</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/02/《Java编程思想》学习笔记之注解/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/02/《Java编程思想》学习笔记之注解/" itemprop="url">
                  《Java编程思想》学习笔记之注解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-02T22:27:02+08:00">
                2017-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2017/02/02/《Java编程思想》学习笔记之注解/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之注解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　注解是java SE5引入的新特性，通过注解，实现了元数据与源代码的结合。本章主要对注解的语法，作用和常用的用法进行学习。<br>  本章要点：</p>
<ul>
<li>注解的语法</li>
<li>注解的作用</li>
<li>注解的用法</li>
<li>总结<h2 id="1-注解的语法"><a href="#1-注解的语法" class="headerlink" title="1.注解的语法"></a><strong>1.注解的语法</strong></h2>　　注解是通过“@注解名”的形式存在与代码之中的。如下所示：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pubic class Testable&#123;</div><div class="line">    public void execute()&#123;System.out.println("execute run");&#125;</div><div class="line">    @Test void testExecute()&#123;System.out.println("testExecute run");&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从语法的角度来看，注解的使用方式和修饰符的使用很类似。</p>
<h4 id="1-1注解的分类"><a href="#1-1注解的分类" class="headerlink" title="1.1注解的分类"></a><strong>1.1注解的分类</strong></h4><p>　　Java的注解主要分为两类，一类是Java内置的三种标准注解，另一类是四种元注解，元注解负责注解其他的注解。<br>  　　三种标准注解定义在java.lang包中，分别为：</p>
<ol>
<li><strong>@Override</strong>，表示当前的方法定义将覆盖超类中的方法。如果拼写错误或者方法签名不匹配，将会在编译器报错。</li>
<li><strong>@Deprecated</strong>，被该注解修饰后，表示这个方法或类不再建议使用。如果有程序员使用了，那么编译器将会发出警告信息。</li>
<li><p><strong>@Suppress Warnings</strong>，用来关闭不当的编译器警告信息。比如在进行强制类型转换时，编译器会给出警告信息，如果使用@SuppressWarnings(“unchecked”)，编译器就不会警告了。</p>
<p>　　Java的四种元注解用于创建需要的注解，如下：</p>
</li>
</ol>
<ol>
<li><p><strong>@Target</strong>，该元注解用来定义自定义的注解将用于什么地方，用法为@Target(ElementType.作用范围)<br>其中，作用范围有七种，分别为：<br>@Target(ElementType.<strong>CONSTRUCTOR</strong>)，表明该注解用于构造方法；<br>@Target(ElementType.<strong>FIELD</strong>)，表明该注解用于成员变量(包含枚举)；<br>@Target(ElementType.<strong>LOCAL_VARIABLE</strong>)，表明该注解用于局部变量；<br>@Target(ElementType.<strong>METHOD</strong>)，表明该注解用于方法；<br> @Target(ElementType.<strong>PACKAGE</strong>)，表明该注解用于包；<br>  @Target(ElementType.<strong>PARAMETER</strong>)，表明该注解用于方法参数；<br>   @Target(ElementType.<strong>TYPE</strong>)，表明该注解用于类、接口或者枚举声明；</p>
</li>
<li><p><strong>@Retention</strong>，该元注解用来定义自定义的注解在哪一个级别可用，用法为@Retention(RetentionPolicy.级别)<br>其中，使用级别有三种，分别为：<br>@Retention(RetentionPolicy.<strong>SOURCE</strong>)，注解在源代码中可用，将被编译器丢弃；<br>@Retention(RetentionPolicy.<strong>CLASS</strong>)，注解在类文件中可用，但会被虚拟机丢弃；<br>@Retention(RetentionPolicy.<strong>RUNTIME</strong>)，虚拟机在运行期也保留注解，因此可以通过反射机制来读取注解的信息。</p>
</li>
<li><strong>@Documented</strong>，应用该元注解表明将自定义注解添加到javadoc中；</li>
<li><strong>@Inherited</strong>，表明允许子类继承父类中的注解；<h4 id="1-2-自定义注解语法"><a href="#1-2-自定义注解语法" class="headerlink" title="1.2 自定义注解语法"></a><strong>1.2 自定义注解语法</strong></h4>在上面我们使用了@Test的注解，具体的@Test注解定义如下：</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Target(ElementType.METHOD)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">public @interface Test&#123;&#125;</div></pre></td></tr></table></figure>
<p>　　一般常用的元注解就是@Target和@Retention，上述示例中，注解@Test用于方法，在运行时可用。注解用@interface修饰，和接口类似。在Java中，注解也将会被编译成Class文件。<br>  　　上述注解中，没有任何元素，称为<strong>标记注解</strong>。通常情况下，向注解添加元素，实现更多的功能。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package AnnotationTest;</div><div class="line"></div><div class="line">import java.lang.annotation.*;</div><div class="line"></div><div class="line">@Target(ElementType.METHOD)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">public @interface UseCase &#123;</div><div class="line">   public int id();</div><div class="line">   public String description() default &quot;no description&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　注解@UseCase中，包含有int元素id和一个String元素description。在Java中，注解元素可以的类型有限，主要是以下几种：</p>
<ul>
<li>所有的基本类型（int，float，boolean）</li>
<li>String</li>
<li>Class</li>
<li>enum</li>
<li>Annotation</li>
<li>以上类型的数组</li>
</ul>
<p>　　对于注解中的元素有两个基本要求，分别是：<br>  　　<strong>第一：元素不能有不确定的值</strong>。要么有默认值，要么在使用注解时提供元素的值；<br>    　　<strong>第二：对于非基本类型的元素</strong>，无论是在源码声明中还是注解接口定义中，都不能用null作为值。一般用空字符串或者复制来表示该元素不存在。<br>  　  通过使用该注解，可以用来跟踪项目中的用例。如果方法实现了用例的需求，那么就为方法添加该注解，通过计算已经实现的用例，就可以很好的掌握项目的进展。<br>  　　如下，类中的方法被注解为用例，使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    package AnnotationTest;</div><div class="line"></div><div class="line">public class PassWordUtils &#123;</div><div class="line">   @UseCase(id=47,description=&quot;Passwords must contains at least one numeric&quot;)</div><div class="line">   public boolean validatePassword(String password)&#123;</div><div class="line">	   return(password.matches(&quot;\\w*\\d\\w*&quot;));</div><div class="line">	   &#125;</div><div class="line">   </div><div class="line">   @UseCase(id=48)</div><div class="line">   public String encryPassword(String password)&#123;</div><div class="line">	   return new StringBuilder(password).reverse().toString();</div><div class="line">	   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　　注解的元素在使用时表现为键值对的形式，并且需要置于@UseCase声明之后的括号里面。另外，如果没有给出具体元素的值，在处理这个类时，就会采用元素的默认值。</p>
<h2 id="2-注解的作用"><a href="#2-注解的作用" class="headerlink" title="2.注解的作用"></a><strong>2.注解的作用</strong></h2><p>   注解主要有以下几个作用：</p>
<ol>
<li>生成文档。与注释性文字相比，注解更加适用于描述类的相关的信息。</li>
<li>在编译期进行格式检查。比如，把@Override放在方法前面，如果这个方法没有覆盖父类的方法，在编译期间就能检查出来。</li>
<li>跟踪代码依赖性，实现替代配置文件功能。现在一般的框架使用注解配置来减少配置文件的数量。（？）<h2 id="3-注解的用法"><a href="#3-注解的用法" class="headerlink" title="3.注解的用法"></a><strong>3.注解的用法</strong></h2></li>
</ol>
<h4 id="3-1-注解处理器"><a href="#3-1-注解处理器" class="headerlink" title="3.1 注解处理器"></a><strong>3.1 注解处理器</strong></h4><p>通过反射机制，创建注解处理器工具类，可以用来解析带有注解的源代码。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package AnnotationTest;</div><div class="line"></div><div class="line">import java.lang.reflect.Method;</div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class UseCaseTracker &#123;</div><div class="line">    public static void trackUseCase(List&lt;Integer&gt; useCases,Class&lt;?&gt; c1)&#123;</div><div class="line">    	for(Method m:c1.getDeclaredMethods())&#123;</div><div class="line">    		UseCase uc = m.getAnnotation(UseCase.class);</div><div class="line">    		if(uc!=null)&#123;</div><div class="line">    			System.out.println("Found use case:"+uc.id()+"   "+uc.description());</div><div class="line">    			useCases.remove(new Integer(uc.id()));</div><div class="line">    		&#125;</div><div class="line">    	&#125;</div><div class="line">    	for(int i:useCases)&#123;</div><div class="line">    		System.out.println("Warning: missing the use case: "+i);</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		List&lt;Integer&gt; useCases = new ArrayList&lt;Integer&gt;();</div><div class="line">		Collections.addAll(useCases,47,48,49);</div><div class="line">		trackUseCase(useCases,PassWordUtils.class);		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　如上述示例，trackUseCases方法可以追踪注解用例在源码中的使用情况，它有两个参数，分别是需要查询的集合和源代码文件。通过反射方法getDeclaredMethods()方法获取到源代码类文件中的所有方法，然后调用getAnnoation()返回指定类型的注解对象，然后再调用id()和description()提取UseCase对象中元素的值。如果方法在注解时，没有指定值，则返回的是默认值。<br>　　通过注解和注解处理器，可以对源代码进行解析。</p>
<h4 id="3-2-基于注解的单元测试"><a href="#3-2-基于注解的单元测试" class="headerlink" title="3.2 基于注解的单元测试"></a><strong>3.2 基于注解的单元测试</strong></h4><p>　　单元测试是对类中的方法提供测试的一种实践，目的是有规律的测试一个类中的各个部分是否具备正确的行为。<br>  　　常用的基于注解的测试框架是@Unit。它最基本的一个注解是@Test，通过@Test来标记测试方法，测试方法不带参数，并返回boolean结果来说明测试成功还是失败。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package AnnotationTest;</div><div class="line">import net.mindview.atunit;</div><div class="line"></div><div class="line">public class AtUnitExample &#123;</div><div class="line">    public String method1()&#123;return &quot;This is method1&quot;;&#125;</div><div class="line">    public int method2()&#123;</div><div class="line">    	System.out.println(&quot;This is method2&quot;);</div><div class="line">    	return 2;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Test boolean method1Test()&#123;</div><div class="line">    	return method1().equals(&quot;This is method1&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Test private boolean  method2Test()&#123;return method2()==2;&#125;</div><div class="line">    </div><div class="line">    @Test boolean failTest()&#123;return false;&#125;</div><div class="line">    </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		OSExecute.command(&quot;AnnotationTest AtUnitExample&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@Test注解被放置在method1Test()、method2Test()和failTest()之前，将这些方法标记为单位测试进行运行。编写单元测试时，唯一需要做的就是决定测试是成功还是失败。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a><strong>4.总结</strong></h2><ul>
<li>注解是Java 的高级特性，它为我们在代码中添加信息提供了形式化的方法。</li>
<li>注解不能影响程序代码的执行，无论增加、删除注解，代码都能够执行。</li>
<li>Java只提供了三种基本注解，在大多数情况下，我们所使用的注解都是通过元注解来进行定义的，需要对注解定义的语法有一定了解。</li>
<li>注解的测试功能比较强大，需要进一步学习。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/19/《Java编程思想》学习笔记之枚举/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/19/《Java编程思想》学习笔记之枚举/" itemprop="url">
                  《Java编程思想》学习笔记之枚举
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-19T23:46:27+08:00">
                2017-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2017/01/19/《Java编程思想》学习笔记之枚举/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之枚举">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　枚举在Java中的应用较为普遍，一般的用途是将一组具名的值集合在一起，作为一种的新的类型在程序组件中应用。<br>  本章要点：</p>
<ul>
<li>枚举类型的基本应用</li>
<li>switch语句中的枚举</li>
<li>枚举类的常用方法</li>
<li>枚举中添加方法</li>
<li>枚举与接口</li>
<li>枚举集合（enumset与enummap）</li>
<li>总结<h2 id="1-枚举类型的基本应用"><a href="#1-枚举类型的基本应用" class="headerlink" title="1.枚举类型的基本应用"></a><strong>1.枚举类型的基本应用</strong></h2>　当我们需要用到一个常量的时候，一般会用static和final进行修饰，如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final double PI=3.14;</div></pre></td></tr></table></figure>
<p>　　数学中的圆周率PI就可以用这种方式固定下来，之后可以很方便的对这个数学常量进行调用。而如果有一组相关的常量需要被应用，枚举类型是最好的选择。<br>  比如，一周有七天，从周一到周日，可以用枚举把它们组合在一起。如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public enum Week &#123; MON, TUE, WED, THU ,FRI, SAT, SUN&#125;</div></pre></td></tr></table></figure>
<p>　　枚举类用关键字enum表示，用大括号表示值的集合。可以通过如下两种方式进行使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//第一种方式，直接用  枚举类名.值  进行调用</div><div class="line">package xuwei.enumtest.com;</div><div class="line">public class enumTest1 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println("Today is  "+Week.MON);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//第二种方式，静态导入枚举类，就可以直接进行调用</div><div class="line">package xuwei.enumtest.com;</div><div class="line">import static xuwei.enumtest.com.Week.*;</div><div class="line">public class enumTest1 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println("Today is  "+MON);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果均为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Today is  MON</div></pre></td></tr></table></figure>
<p>　　如上就是枚举类最简单的用法，用关键字enum将一组具名的值的有限集合创建为一种新的类型，这些具名的值可以作为常规的程序组件使用。</p>
<h2 id="2-switch语句中的枚举"><a href="#2-switch语句中的枚举" class="headerlink" title="2.switch语句中的枚举"></a><strong>2.switch语句中的枚举</strong></h2><p>　　switch语句是程序控制语句中的常用的一种，通过不同的值，选择不同的程序分支来运行。一般来说，在switch中只能使用整数值，但是枚举实例自身具有整数值的次数，可以在switch语句中使用，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package xuwei.enumtest.com;</div><div class="line"></div><div class="line">public class enumTest2 &#123;</div><div class="line">	Week day = Week.FRI;</div><div class="line">	public  void method()&#123;</div><div class="line">		switch(day)&#123;</div><div class="line">		case MON:</div><div class="line">			System.out.println("星期一，上班啦!!!");break;</div><div class="line">		case TUE:</div><div class="line">			System.out.println("星期二，上班啦!!!");break;</div><div class="line">		case WED:</div><div class="line">			System.out.println("星期三，上班啦!!!");break;</div><div class="line">		case THU:</div><div class="line">			System.out.println("星期四，上班啦!!!");break;</div><div class="line">		case FRI:</div><div class="line">			System.out.println("星期五，上班啦!!!");break;</div><div class="line">		case SAT:</div><div class="line">			System.out.println("星期六，放假啦!!!");break;</div><div class="line">		case SUN:</div><div class="line">			System.out.println("星期天，放假啦!!!");break;</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		enumTest2 et = new enumTest2();</div><div class="line">		et.method();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">星期五，上班啦!!!</div></pre></td></tr></table></figure>
<p>需要注意的是：<strong>在case语句中可以直接使用枚举实例，不需要用枚举类型来修饰</strong>。</p>
<h2 id="3-枚举类的常用方法"><a href="#3-枚举类的常用方法" class="headerlink" title="3.枚举类的常用方法"></a><strong>3.枚举类的常用方法</strong></h2><p>　　当我们创建枚举类时，编译器会生成一个相关的类，这个类继承自java.lang.Enum，它是所有 Java 语言枚举类型的公共基本类。它提供的一些基本方法，枚举也可以进行使用。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">ordinal</span><span class="params">()</span></span>  <span class="comment">//返回枚举实例在枚举声明中的位置，其中初始常量序数为零；</span></div><div class="line"><span class="function"><span class="title">compareTo</span><span class="params">()</span></span> <span class="comment">//比较枚举实例与指定对象的顺序；</span></div><div class="line"><span class="function"><span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span></span><span class="comment">//根据指定的名称返回相应的enum实例；</span></div><div class="line"><span class="function"><span class="title">name</span><span class="params">()</span></span><span class="comment">//返回枚举实例的名称</span></div><div class="line"><span class="function"><span class="title">getDeclaringClass</span><span class="params">()</span></span><span class="comment">//返回枚举实例所对应的字节码文件</span></div><div class="line"><span class="function"><span class="title">equals</span><span class="params">(Object other)</span></span><span class="comment">//将指定对象和枚举实例进行对比</span></div><div class="line"><span class="function"><span class="title">hashCode</span><span class="params">()</span></span>  <span class="comment">//返回枚举实例的哈希值</span></div><div class="line"><span class="function"><span class="title">toString</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>通过示例对主要的方法进行验证：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package xuwei.enumtest.com;</div><div class="line"></div><div class="line">public class enumTest3 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//ordinal方法验证</div><div class="line">		System.out.println("ordinal方法验证---"+"星期五的位置为   "+Week.FRI.ordinal());</div><div class="line">		</div><div class="line">		//compareTo方法验证</div><div class="line">		System.out.println("compareTo方法验证---"+"枚举值的顺序差值"+Week.FRI.compareTo(Week.SUN));</div><div class="line">		</div><div class="line">		//valueOf方法验证</div><div class="line">		String s = "FRI" ;</div><div class="line">		Week day = Enum.valueOf(Week.class,s);</div><div class="line">		System.out.println("valueOf方法验证---"+"是否存在星期五"+day);</div><div class="line">		</div><div class="line">		//name()方法验证</div><div class="line">		System.out.println("name()方法验证---"+Week.FRI.name());</div><div class="line">		</div><div class="line">		//getDeclaringClass()方法验证</div><div class="line">		System.out.println("getDeclaringClass()方法验证---"+Week.FRI.getDeclaringClass());</div><div class="line">		</div><div class="line">		//equals()方法验证</div><div class="line">		System.out.println("equals()方法验证---"+Week.FRI.equals(Week.SUN));</div><div class="line">    	System.out.println("equals()方法验证---"+Week.FRI.equals(Week.FRI));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ordinal方法验证---星期五的位置为   <span class="number">4</span></div><div class="line">compareTo方法验证---枚举值的顺序差值-<span class="number">2</span></div><div class="line">alueOf方法验证---是否存在星期五FRI</div><div class="line"><span class="function"><span class="title">name</span><span class="params">()</span></span>方法验证---FRI</div><div class="line"><span class="function"><span class="title">getDeclaringClass</span><span class="params">()</span></span>方法验证---class xuwei<span class="selector-class">.enumtest</span><span class="selector-class">.com</span><span class="selector-class">.Week</span></div><div class="line"><span class="function"><span class="title">equals</span><span class="params">()</span></span>方法验证---false</div><div class="line"><span class="function"><span class="title">equals</span><span class="params">()</span></span>方法验证---true</div></pre></td></tr></table></figure>
<h2 id="4-枚举中添加方法"><a href="#4-枚举中添加方法" class="headerlink" title="4.枚举中添加方法"></a><strong>4.枚举中添加方法</strong></h2><h4 id="4-1-添加对枚举实例的描述"><a href="#4-1-添加对枚举实例的描述" class="headerlink" title="4.1 添加对枚举实例的描述"></a><strong>4.1 添加对枚举实例的描述</strong></h4><p>　　之前学习的枚举都是简单的枚举实例，一般来说，我们也希望每个枚举示例能够返回对自身的描述。可以通过提供构造方法，负责处理描述信息，并添加方法，返回这个描述信息，如下；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package xuwei.enumtest.com;</div><div class="line"></div><div class="line">public enum Week1 &#123;</div><div class="line">	MON("今天星期一"),TUE("今天星期二"),WED("今天星期三"),THU("今天星期四"),FRI("今天星期五"),SAT("今天星期六"),SUN("今天星期天");//最后一个分号不可少</div><div class="line">	</div><div class="line">	private String description;</div><div class="line">	private Week1(String description)&#123;this.description = description;&#125;</div><div class="line">	</div><div class="line">	public String getDescription()&#123;return description;&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		for(Week1 day:Week1.values())</div><div class="line">			System.out.println(day+":"+day.getDescription());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MON:今天星期一</div><div class="line">TUE:今天星期二</div><div class="line">WED:今天星期三</div><div class="line">THU:今天星期四</div><div class="line">FRI:今天星期五</div><div class="line">SAT:今天星期六</div><div class="line">SUN:今天星期天</div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ol>
<li>枚举实例序列的最后必须添加一个分号；</li>
<li>必须先定义枚举实例，然后才能定义方法和属性；</li>
<li>枚举类的构造方法声明为私有，只在内部使用，也不允许外界通过构造方法创建实例<h4 id="4-2-覆盖toString方法"><a href="#4-2-覆盖toString方法" class="headerlink" title="4.2 覆盖toString方法"></a><strong>4.2 覆盖toString方法</strong></h4>通过覆写toString方法，也能够为枚举实例添加字符串描述：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package xuwei.enumtest.com;</div><div class="line"></div><div class="line">public enum Week3 &#123;</div><div class="line">	</div><div class="line">	MON, TUE, WED, THU ,FRI, SAT, SUN;</div><div class="line">	public String toString()&#123;return "Today is "+name();&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		for(Week3 day:Week3.values())</div><div class="line">			System.out.println(day);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行的结果为:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Today is MON</div><div class="line">Today is TUE</div><div class="line">Today is WED</div><div class="line">Today is THU</div><div class="line">Today is FRI</div><div class="line">Today is SAT</div><div class="line">Today is SUN</div></pre></td></tr></table></figure>
<h2 id="5-枚举与接口"><a href="#5-枚举与接口" class="headerlink" title="5.枚举与接口"></a><strong>5.枚举与接口</strong></h2><p>　　所有的枚举类都继承自java.lang.Enum，而Java不支持多继承，所以枚举类不能够再继承其他的类。但是，枚举类可以实现接口。如下代码所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package xuwei.enumtest.com;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">interface Do&lt;T&gt;&#123;</div><div class="line">	public T Show();</div><div class="line">&#125;</div><div class="line">//Week4实现Do接口，并重写了它里面的Show()方法</div><div class="line">public enum Week4 implements Do&lt;Week4&gt;&#123;</div><div class="line">	MON, TUE, WED, THU ,FRI, SAT, SUN;</div><div class="line">    private Random rand = new Random(47);</div><div class="line">	@Override</div><div class="line">	public Week4 Show() &#123;</div><div class="line">		return values()[rand.nextInt(values().length)];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试类</div><div class="line">package xuwei.enumtest.com;</div><div class="line"></div><div class="line">public class enumTest5 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Week4 week = Week4.FRI;</div><div class="line">		System.out.println(week.Show());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SUN</div></pre></td></tr></table></figure>
<p>　　除了从外部实现一个接口的方法，也可以在一个接口的内部，创建实现接口的枚举，从而通过接口组织枚举。如下;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package xuwei.enumtest.com;</div><div class="line">//通过接口把枚举组合在一起</div><div class="line">public interface Food &#123;</div><div class="line">   enum Fruit implements Food&#123;Apple,Orange,Banana;&#125;</div><div class="line">   </div><div class="line">   enum Coffee implements Food&#123;BlackCoffee,Latte,Tea;&#125;//疑问？要分号和要分号都不报编译错误，貌似都可行，为何？</div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试类调用枚举</div><div class="line">package xuwei.enumtest.com;</div><div class="line">import static xuwei.enumtest.com.Food.*;</div><div class="line">public class enumTest6 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">       //都是Food型，可以用Food接收</div><div class="line">		Food food = Fruit.Apple;</div><div class="line">		food = Coffee.Latte;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-枚举集合（EnumSet与EnumMap）"><a href="#6-枚举集合（EnumSet与EnumMap）" class="headerlink" title="6.枚举集合（EnumSet与EnumMap）"></a><strong>6.枚举集合（EnumSet与EnumMap）</strong></h2><h4 id="6-1-EnumSet"><a href="#6-1-EnumSet" class="headerlink" title="6.1 EnumSet"></a><strong>6.1 EnumSet</strong></h4><p>　　EnumSet是与枚举类型一起使用的专用 Set 实现。引入EnumSet是为了通过枚举创建一种替代品，用来替代传统的基于int的“位标志”（表示开关信息）。EnumSet的优点在于：它在说明一个二进制位是否存在时，具有更好的表达能力，并且不需要担心性能。<br>  　　EnumSet的基本使用方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package xuwei.enumtest.com;</div><div class="line"></div><div class="line">import java.util.EnumSet;</div><div class="line"></div><div class="line">public class EnumSetTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//创建一个具有Week枚举类型的空EnumSet，参数类型为枚举的字节码文件</div><div class="line">		EnumSet&lt;Week&gt; es = EnumSet.noneOf(Week.class);</div><div class="line">		</div><div class="line">		//利用add()方法把枚举实例添加到EnumSet中</div><div class="line">		es.add(Week.MON);</div><div class="line">		System.out.println(es);</div><div class="line">		</div><div class="line">		//返回包含指定元素的枚举类型，并将其添加</div><div class="line">		es.addAll(EnumSet.of(Week.TUE,Week.WED));</div><div class="line">		System.out.println(es);</div><div class="line">		</div><div class="line">		//创建一个包含所有指定枚举类型实例的EnumSet，参数类型是枚举的字节码文件</div><div class="line">		es=EnumSet.allOf(Week.class);</div><div class="line">		System.out.println(es);</div><div class="line">		</div><div class="line">		//通过removeAll()移除指定的枚举实例</div><div class="line">		es.removeAll(EnumSet.of(Week.SAT, Week.SUN));</div><div class="line">		System.out.println(es);</div><div class="line">		</div><div class="line">		//移除EnumSet某一范围内的枚举实例</div><div class="line">		es.removeAll(EnumSet.range(Week.MON, Week.WED));</div><div class="line">		System.out.println(es);</div><div class="line">		</div><div class="line">		//原有的EnumSet的补集</div><div class="line">		es=EnumSet.complementOf(es);</div><div class="line">		System.out.println(es);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[MON]</div><div class="line">[MON, TUE, WED]</div><div class="line">[MON, TUE, WED, THU, FRI, SAT, SUN]</div><div class="line">[MON, TUE, WED, THU, FRI]</div><div class="line">[THU, FRI]</div><div class="line">[MON, TUE, WED, SAT, SUN]</div></pre></td></tr></table></figure>
<h4 id="6-2-EnumMap"><a href="#6-2-EnumMap" class="headerlink" title="6.2 EnumMap"></a><strong>6.2 EnumMap</strong></h4><p>　　EnumMap是与枚举类型一起使用的专用Map实现。它要求其中的键（Key）必须来自于一个枚举类型。EnumMap的优点在于允许程序员改变值对象（？暂时还不理解）。示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package xuwei.enumtest.com;</div><div class="line"></div><div class="line">import java.util.EnumMap;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">interface Command&#123;void say();&#125;</div><div class="line">public class EnumMapTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//以Week枚举的字节码文件为参数，构建EnumMap</div><div class="line">		EnumMap&lt;Week,Command&gt; em = new EnumMap&lt;Week,Command&gt;(Week.class);</div><div class="line">		</div><div class="line">		em.put(Week.MON, new Command()&#123;public void say()&#123;System.out.println("上班啦!!!");&#125;&#125;);</div><div class="line">		</div><div class="line">		em.put(Week.SAT, new Command()&#123;public void say()&#123;System.out.println("放假啦!!!");&#125;&#125;);</div><div class="line">		//返回EnumMap中包含的映射关系的 set 视图</div><div class="line">		for(Map.Entry&lt;Week, Command&gt; e: em.entrySet())&#123;</div><div class="line">			System.out.print(e.getKey()+":");</div><div class="line">			e.getValue().say();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为；</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MON:上班啦!!!</div><div class="line">SAT:放假啦!!!</div></pre></td></tr></table></figure>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a><strong>7.总结</strong></h2><ol>
<li>枚举类都是继承自java.lang.Enum类的，通过关键字enum来表示。</li>
<li>枚举可以将一组具名的值的有限集合创建为一种新的类型，并对其加以描述。</li>
<li>枚举与接口、泛型、多态以及集合均有交叉应用，需要加以学习。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/14/《Java编程思想》学习笔记之序列化与反序列化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/14/《Java编程思想》学习笔记之序列化与反序列化/" itemprop="url">
                  《Java编程思想》学习笔记之序列化与反序列化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-14T23:08:24+08:00">
                2017-01-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2017/01/14/《Java编程思想》学习笔记之序列化与反序列化/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之序列化与反序列化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　之前所介绍的各种IO流都是把硬盘上的文件、字符数组和字符串进行写入和读取操作，如果是把对象写入流，或者把流恢复成对象，那就涉及到序列化与反序列化。<br>  本章要点：</p>
<ol>
<li>序列化与反序列化的概念及优点</li>
<li>序列化与反序列化的步骤</li>
<li>序列化的控制</li>
<li>总结<h2 id="1-序列化与反序列化的概念及优点"><a href="#1-序列化与反序列化的概念及优点" class="headerlink" title="1.序列化与反序列化的概念及优点"></a><strong>1.序列化与反序列化的概念及优点</strong></h2>　　在正常情况下我们根据需要创建对象，但是在程序终止时，对象也不会继续存在。但是在实际某些情况下，我们希望对象在程序不运行情况下仍保存信息，并且在下次重新启用程序时，上次留存的对象信息能够被恢复。Java中，对象的序列化与反序列化就能够实现这样的功能，而且能够弥补不同操作系统之间的差异。<br>　　<strong>对象的序列化</strong>是指将Java对象转化为字节序列的过程；<strong>反序列化</strong>是指将字节序列恢复为Java对象的过程。<br>对象的序列化有两个比较明显的优点；</li>
</ol>
<ol>
<li><strong>持久性</strong>。通过将一个序列化对象写入磁盘，然后在重新调用程序时恢复这个对象，就能够实现对象的持久性。这就意味着一个对象的生存周期并不取决于程序是否在执行，它可以生存于程序的调用之间。</li>
<li><strong>对象的调用</strong>。存活在其他计算机的对象通过序列化与反序列化能够在本机上进行使用，就像存在于本机上一样。<h2 id="2-序列化与反序列化的步骤"><a href="#2-序列化与反序列化的步骤" class="headerlink" title="2.序列化与反序列化的步骤"></a><strong>2.序列化与反序列化的步骤</strong></h2>　　Java中，完成对象的序列化与反序列化的IO流是ObjectOutputStream与ObjectInputStream，其次，对象要实现<strong>Serializable接口和Externalizable接口</strong>，具体的步骤如下：<br><strong>第一步</strong>：创建对象，并一定要实现Serializable接口或者Externalizable接口</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Person implements Serializable&#123;&#125;</div></pre></td></tr></table></figure>
<p>  <strong>第二步</strong>：创建一个对象输出流，包含一个其他类型的目标输出流，如文件输出流：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(“D:\\IOtest\\test11”));</div></pre></td></tr></table></figure>
<p><strong>第三步</strong>：通过对象输出流的writeObject()方法把对象写入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">out.writeObject(p1);</div></pre></td></tr></table></figure>
<p><strong>第四步</strong>：创建一个对象的输入流，包含一个其他类型的输入流，如文件输入流：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjectInputStream in= new ObjectInputStream(new FileInputStream(“D:\\IOtest\\test11”));</div></pre></td></tr></table></figure></p>
<p><strong>第五步</strong>：通过对象的readObject()方法读取对象，需要进行强制类型转换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person p1 = (Person)in.readObject();</div></pre></td></tr></table></figure>
<p>具体的程序示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">//第一步：创建可以序列化的类</div><div class="line">package com.xuwei.serializable;</div><div class="line"></div><div class="line">import java.io.Serializable;</div><div class="line"></div><div class="line">public class Person implements Serializable&#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	public Person(String name,int age)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public String toString() &#123;</div><div class="line">		return "Person [name=" + name + ", age=" + age + "]";</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">package com.xuwei.serializable;</div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class SerializableTest1 &#123;</div><div class="line">	public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class="line">		Person p1 = new Person("zhangsan",23);</div><div class="line">		Person p2 = new Person("lisi",24);</div><div class="line">		Person p3 = new Person("wangwu",25);</div><div class="line">        </div><div class="line">		//第二步：创建对象输出流</div><div class="line">		ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("D:\\IOtest\\test11.txt"));</div><div class="line">        </div><div class="line">        //第三步：写入对象并关闭输出流</div><div class="line">		out.writeObject(p1);</div><div class="line">		out.writeObject(p2);</div><div class="line">		out.writeObject(p3);</div><div class="line">		out.close();</div><div class="line">        </div><div class="line">		//第四步：创建对象输入流</div><div class="line">		ObjectInputStream in= new ObjectInputStream(new FileInputStream("D:\\IOtest\\test11.txt"));</div><div class="line">        </div><div class="line">        //第五步：读取对象</div><div class="line">		 p1= (Person) in.readObject();</div><div class="line">		 p2= (Person) in.readObject();</div><div class="line">		 p3= (Person) in.readObject();</div><div class="line">		 System.out.println(p1);</div><div class="line">		 System.out.println(p2);</div><div class="line">		 System.out.println(p3);</div><div class="line">		 in.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person [name=zhangsan, age=<span class="number">23</span>]</div><div class="line">Person [name=lisi, age=<span class="number">24</span>]</div><div class="line">Person [name=wangwu, age=<span class="number">25</span>]</div></pre></td></tr></table></figure>
<p>需要注意的是，读取的对象要和写入的对象进行一一对应，也可以把对象写入容器中，读取时，直接把元素再放入容器中，更加简便，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.serializable;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class SerializableTest1 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class="line">		Person p1 = new Person("zhangsan",23);</div><div class="line">		Person p2 = new Person("lisi",24);</div><div class="line">		Person p3 = new Person("wangwu",25);</div><div class="line">		List&lt;Person&gt; list = new ArrayList&lt;&gt;();</div><div class="line">		list.add(p1);</div><div class="line">		list.add(p2);</div><div class="line">		list.add(p3);</div><div class="line">		</div><div class="line">		</div><div class="line">		ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("D:\\IOtest\\test11.txt"));</div><div class="line">		out.writeObject(list);</div><div class="line">		out.close();</div><div class="line">		</div><div class="line">		ObjectInputStream in= new ObjectInputStream(new FileInputStream("D:\\IOtest\\test11.txt"));</div><div class="line">		list = (List&lt;Person&gt;) in.readObject();</div><div class="line">		 for(Person li:list)</div><div class="line">			 System.out.println(li);</div><div class="line">		 in.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-序列化的控制"><a href="#3-序列化的控制" class="headerlink" title="3.序列化的控制"></a><strong>3.序列化的控制</strong></h2><h4 id="3-1-Externalizable接口"><a href="#3-1-Externalizable接口" class="headerlink" title="3.1 Externalizable接口"></a><strong>3.1 Externalizable接口</strong></h4><p>Externalizable接口继承自Serializable接口，使用它也可以完成完成对象的序列化，特别要注意一下几点：</p>
<ul>
<li>实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public。因为使用Externalizable进行序列化，当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。</li>
<li>Serializable没有提供任何方法，而Externalizable有两个方法，分别是writeExternal和readExternal，实现Externalizable的类必须重写这两个方法，它们用来传入字段，如果writeExternal()与readExternal()方法未作任何处理，那么该序列化行为将不会保存/读取任何一个字段。<br>使用的示例如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">//Person类：提供公共的无参构造方法并且重写接口的两个方法</div><div class="line">package com.xuwei.serializable;</div><div class="line"></div><div class="line">import java.io.Externalizable;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.ObjectInput;</div><div class="line">import java.io.ObjectOutput;</div><div class="line">import java.io.Serializable;</div><div class="line"></div><div class="line">public class Person implements Externalizable&#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	public Person()&#123;&#125;</div><div class="line">	public Person(String name,int age)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public String toString() &#123;</div><div class="line">		return "Person [name=" + name + ", age=" + age + "]";</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void writeExternal(ObjectOutput out) throws IOException &#123;</div><div class="line">		out.writeObject(name);</div><div class="line">		out.writeInt(age);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void readExternal(ObjectInput in) throws IOException,</div><div class="line">			ClassNotFoundException &#123;</div><div class="line">		name = (String)in.readObject();</div><div class="line">		age = in.readInt();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试类不变</div><div class="line">package com.xuwei.serializable;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class SerializableTest1 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</div><div class="line">		Person p1 = new Person("zhangsan",23);</div><div class="line">		Person p2 = new Person("lisi",24);</div><div class="line">		Person p3 = new Person("wangwu",25);</div><div class="line">		List&lt;Person&gt; list = new ArrayList&lt;&gt;();</div><div class="line">		list.add(p1);</div><div class="line">		list.add(p2);</div><div class="line">		list.add(p3);</div><div class="line">		</div><div class="line">		</div><div class="line">		ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("D:\\IOtest\\test11.txt"));</div><div class="line">		out.writeObject(list);</div><div class="line">		out.close();</div><div class="line">		</div><div class="line">		ObjectInputStream in= new ObjectInputStream(new FileInputStream("D:\\IOtest\\test11.txt"));</div><div class="line">		list = (List&lt;Person&gt;) in.readObject();</div><div class="line">		 for(Person li:list)</div><div class="line">			 System.out.println(li);</div><div class="line">		 in.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person [name=zhangsan, age=<span class="number">23</span>]</div><div class="line">Person [name=lisi, age=<span class="number">24</span>]</div><div class="line">Person [name=wangwu, age=<span class="number">25</span>]</div></pre></td></tr></table></figure>
<p>如果去注释掉那两个重写方法里面的内容，如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void writeExternal(ObjectOutput out) throws IOException &#123;</div><div class="line">    <span class="comment">//out.writeObject(name);</span></div><div class="line">   <span class="comment">// out.writeInt(age);</span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">public void readExternal(ObjectInput <span class="keyword">in</span>) throws IOException,</div><div class="line">        ClassNotFoundException &#123;</div><div class="line">   <span class="comment">// name = (String)in.readObject();</span></div><div class="line">   <span class="comment">//age = in.readInt();</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么运行结果为;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person [name=null, age=<span class="number">0</span>]</div><div class="line">Person [name=null, age=<span class="number">0</span>]</div><div class="line">Person [name=null, age=<span class="number">0</span>]</div></pre></td></tr></table></figure>
<h4 id="3-2-transient关键字用法"><a href="#3-2-transient关键字用法" class="headerlink" title="3.2 transient关键字用法"></a><strong>3.2 transient关键字用法</strong></h4><p>如果对象中有一些信息是敏感信息，比如年龄age，我们不希望它被序列化恢复，可以有两种方法。一种是实现Externalizable接口，并且在writeExternal()与readExternal()方法中不传入这些信息。另外一种即使实现Serializable接口，把敏感信息用transient关键字修饰，那么进行序列化恢复时，就是显式的系统默认值。程序如下：<br>把年龄用transient修饰：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private transient int age;</div></pre></td></tr></table></figure>
<p>运行程序后的结果为;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person [name=zhangsan, age=<span class="number">0</span>]</div><div class="line">Person [name=lisi, age=<span class="number">0</span>]</div><div class="line">Person [name=wangwu, age=<span class="number">0</span>]</div></pre></td></tr></table></figure>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a><strong>4.总结</strong></h2><ol>
<li>记住序列化的两个流：ObjectOutputStream和ObjectInputStream；两个接口：Serializable接口和Externalizable接口</li>
<li>记住序列化的五个步骤</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/14/《Java编程思想》学习笔记之IO流体系/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/14/《Java编程思想》学习笔记之IO流体系/" itemprop="url">
                  《Java编程思想》学习笔记之IO流体系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-14T10:07:09+08:00">
                2017-01-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2017/01/14/《Java编程思想》学习笔记之IO流体系/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之IO流体系">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　流的定义是：一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。根据数据传输特性的不同，Java的IO流提供了种类繁多的实现类，本章主要对这些IO流体系进行学习。<br>  本章要点：</p>
<ul>
<li>IO流的主要分类方式</li>
<li>InputStream和OutputStream</li>
<li>Reader和Writer</li>
<li>RandomAccessFile</li>
<li>IO流的基本使用方式</li>
<li>新IO及其使用方法</li>
<li>压缩</li>
<li><p>总结</p>
<h2 id="1-IO流的主要分类方式"><a href="#1-IO流的主要分类方式" class="headerlink" title="1. IO流的主要分类方式"></a><strong>1. IO流的主要分类方式</strong></h2><p>　　按照流中数据的传输方向，流可以分为<strong>输入流</strong>和<strong>输出流</strong>。流向是针对程序角度而言的，输入指的是从文件到程序，输出指的是从程序到文件。<br>　　根据处理数据的对象及编码不同。流被分为<strong>字节流</strong>和<strong>字符流</strong>。两者的主要区别是：</p>
</li>
<li><p><strong>数据读写的单位不同</strong>。字节流以字节为单位，一次读写八个位；字符流以字符为单位，根据码表映射字符，一次可以读写多个字节。</p>
</li>
<li><strong>处理对象不同</strong>。由于所有数据都是以字节形式存在的，所以字节流可以处理所有典型的数据（如图片和视频文件），字符流只能处理字符类型（文本）的数据。<br>　　一般只在处理文本数据时采用字符流，其他情况下均采用字节流。<br>　　按照这两种分组方式，Java的IO流体系就主要被分为四种，分别是：<strong>字节输入流（InputStream）、字节输出流（OutputStream）、字符输入流（Reader）、字符输出流（Writer）</strong>。<br>  　　这四种流都是Java.io体系下的抽象类，根据不同的应用场合，它们都有多种的实现类，主要的体系如下。</li>
</ul>
<h2 id="2-InputStream和OutputStream"><a href="#2-InputStream和OutputStream" class="headerlink" title="2. InputStream和OutputStream"></a><strong>2. InputStream和OutputStream</strong></h2><p>　　InputStream和OutputStream是对字节数据进行操作的一组流，根据不同的数据源和输出目标，它们也有自己的实现类体系。</p>
<h4 id="2-1-InputStream体系"><a href="#2-1-InputStream体系" class="headerlink" title="2.1  InputStream体系"></a><strong>2.1  InputStream体系</strong></h4><p>　　InputStream是字节输入流的抽象类，根据数据源的不同，它有多种实现子类。</p>
<table>
<thead>
<tr>
<th>子类名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteArrayInputStream</td>
<td>以字节数组为数据源。提供一个内部缓冲区，该缓冲区包含从流中读取的字节</td>
</tr>
<tr>
<td>StringBufferInputStream</td>
<td>以字符串作为数据源。该类已过时。</td>
</tr>
<tr>
<td>FileInputStream</td>
<td>以文件为数据源，可以用于读取诸如图像数据之类的原始字节流</td>
</tr>
<tr>
<td>PipedInputStream</td>
<td>以管道为数据源，管道输入流应该连接到管道输出流；管道输入流提供要写入管道输出流的所有数据字节。与多线程相关</td>
</tr>
<tr>
<td>SequenceInputStream</td>
<td>将两个或者多个InputStream对象转化成单一的InputStream，它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。</td>
</tr>
<tr>
<td>FilterInputStream</td>
<td>包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。</td>
</tr>
</tbody>
</table>
<p> 在FilterInputStream中，又有两个很重要的子类，能够用来完成不同的输入需求。</p>
<ol>
<li>DataInputStream：此类包含用于读取基本数据类型的全部接口，允许我们读取不同的基本类型数据以及String对象。通常情况下与DataOutputStream搭配使用，可以完成基本类型数据的迁移。</li>
<li>BufferedInputStream：此类的主要作用是为其他输入流添加一些功能，即缓冲输入以及支持 mark 和 reset 方法的能力。使用它可以防止每次读取时都进行实际写操作。<h4 id="2-2-OutputStream体系"><a href="#2-2-OutputStream体系" class="headerlink" title="2.2 OutputStream体系"></a><strong>2.2 OutputStream体系</strong></h4>OutputStream是字节输出流的抽象类，根据数据输出的目标，它有多种实现类。</li>
</ol>
<table>
<thead>
<tr>
<th>子类名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteArrayOutputStream</td>
<td>该类实现了一个字节输出流，将数据写入一个字节数组。在内存中创建缓冲区，缓冲区会随着数据的不断写入而自动增长。</td>
</tr>
<tr>
<td>FileOutputStream</td>
<td>用于将数据写入文件（图片、视频）的字节输出流</td>
</tr>
<tr>
<td>PipedOutputStream</td>
<td>指定用于多线程的数据的目的地，任何写入其中的信息都会自动作为相关PipedInputStream的输出</td>
</tr>
<tr>
<td>FilterOutputStream</td>
<td>该类是过滤输出流的所有类的超类。这些流位于已存在的输出流（基础 输出流）之上，它们将已存在的输出流作为其基本数据接收器，但可能直接传输数据或提供一些额外的功能。</td>
</tr>
</tbody>
</table>
<p>　　在FilterOutputStream中，又有三个比较重要的子类，用来完成不同的输出需求。</p>
<ol>
<li><strong>DataOutputStream</strong>：与DataInputStream配合使用，它允许应用程序以适当方式将基本 Java 数据类型写入输出流中。然后，应用程序可以使用数据输入流将数据读入。</li>
<li><strong>PrintStream</strong>：可以用来可视化的打印所有的基本数据类型以及String对象，它的两个主要的方法是print()和println()。与其他输出流不同，PrintStream 永远不会抛出 IOException，因此，必须使用checkError()自行测试错误状态，如果出现错误则返回true.PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。</li>
<li><strong>BufferedOutputStream</strong>：该数据流使用缓冲技术，当每次向流写入时，不必每次都进行实际的物理写操作，使用较为频繁。<h2 id="3-Reader和Writer"><a href="#3-Reader和Writer" class="headerlink" title="3.Reader和Writer"></a><strong>3.Reader和Writer</strong></h2>　　字符流是Java 1.1添加到IO类库中来的，主要是为了方便对Unicode字符进行处理。为了实际的需要，它们也有多种实现类。<h4 id="3-1-Reader体系"><a href="#3-1-Reader体系" class="headerlink" title="3.1 Reader体系"></a><strong>3.1 Reader体系</strong></h4>　　Reader是用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。 </li>
</ol>
<p>Reader<br>　|—–BufferedReader：从字符输入流中读取文本，缓冲各个字符,实现字符、数组和行的高效读取。<br> 　|—–CharArrayReader：实现一个可用作字符输入流的字符缓冲区。<br>  　|—–FilterReader：用于读取已过滤的字符流的抽象类<br>   　|—–InputStreamReader：采取指定的编码读取字节并将其解码为字符<br>    　　|—–FileReader：读取字符文件的便捷类<br>    　|—–PipedReader：传送的字符输入流<br>     　|—–StringReader：源为一个字符串的字符流</p>
<p>　　关于InputStreamReader和FileReader的一点小区别：FileReader是InputStreamReader的子类，继承了InputStreamReader的方法，唯一的不同在于构造方法。InputStreamReader构造方法参数为InputStream和编码，可以指定编码方式读取；而FileReader不能指定编码方式。</p>
<h4 id="3-2-Writer体系"><a href="#3-2-Writer体系" class="headerlink" title="3.2 Writer体系"></a><strong>3.2 Writer体系</strong></h4><p>　　Writer是用于写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。</p>
<p>  Writer<br>　|—–BufferedWriter：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。<br> 　|—–CharArrayWriter：实现一个可用作字符输出流的字符缓冲区。<br>  　|—–FilterWriter：用于写入已过滤的字符流的抽象类<br>   　|—–OutputStreamWriter：采用指定的编码将要写入流中的字符编码成字节<br>    　　|—–FileWriter：写入字符文件的便捷类<br>    　|—–PipedWriter：传送的字符输出流<br>     　|—–PrintWriter：向文本输出流打印对象的格式化表示形式。<br>     　|—–StringWriter：一个字符流，可以用其回收在字符串缓冲区中的输出来构造字符串</p>
<p>关于PrintWriter，需要注意的是：它的格式化接口与PrintStream相同。</p>
<h2 id="4-RandomAccessFile"><a href="#4-RandomAccessFile" class="headerlink" title="4.RandomAccessFile"></a><strong>4.RandomAccessFile</strong></h2><p>RandomAccessFile是独立于四大流体系，它直接继承自Object。它同时实现了DataInput和DataOutput（DataInputStream和DataOutputStream也分别实现了这两个接口），所以它类似组合使用了DataInputStreamDataOutputStream,可以同时实现读功能和写功能。示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class test6 &#123;</div><div class="line">    static String file = "D:\\IOtest\\test6.dat";</div><div class="line">    static void show() throws IOException&#123;</div><div class="line">    	RandomAccessFile rf = new RandomAccessFile(file,"r");</div><div class="line">    	for(int i=0;i&lt;3;i++)</div><div class="line">    		System.out.println("Value"+i+": "+rf.readDouble());</div><div class="line">    	System.out.println(rf.readUTF());</div><div class="line">    	rf.close();</div><div class="line">    &#125;</div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">    	RandomAccessFile rf = new RandomAccessFile(file,"rw");</div><div class="line">    	for(int i=0;i&lt;3;i++)</div><div class="line">    		rf.writeDouble(i*1.1);</div><div class="line">    	rf.writeUTF("Hello Word");</div><div class="line">    	rf.close();</div><div class="line">    	show();</div><div class="line">    	System.out.println("------------");</div><div class="line">    	rf = new RandomAccessFile(file,"rw");</div><div class="line">    	rf.seek(2*8);</div><div class="line">    	rf.writeDouble(2017.0112);</div><div class="line">    	rf.close();</div><div class="line">    	show(); 	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Value0: <span class="number">0.0</span></div><div class="line">Value1: <span class="number">1.1</span></div><div class="line">Value2: <span class="number">2.2</span></div><div class="line">Hello Word</div><div class="line">------------</div><div class="line">Value0: <span class="number">0.0</span></div><div class="line">Value1: <span class="number">1.1</span></div><div class="line">Value2: <span class="number">2017.0112</span></div><div class="line">Hello Word</div></pre></td></tr></table></figure>
<p>示例中，用RandomAccessFile来完成输入和输出工作，当指定为“r”时，为只读，当指定为“rw”时，为读写。seek()方法可以完成值的查找，并可以重新写值进行覆盖。</p>
<h2 id="5-IO流的基本使用方式"><a href="#5-IO流的基本使用方式" class="headerlink" title="5. IO流的基本使用方式"></a><strong>5. IO流的基本使用方式</strong></h2><p>　　从上面的IO体系介绍可以看出来，Java有众多可以处理数据的流类，在实际使用中，这些类通过各种组合进行使用。</p>
<h4 id="5-1-BufferedReader和FileReader组合读入字符文件"><a href="#5-1-BufferedReader和FileReader组合读入字符文件" class="headerlink" title="5.1 BufferedReader和FileReader组合读入字符文件"></a><strong>5.1 BufferedReader和FileReader组合读入字符文件</strong></h4><p>　　如果需要读入一个文件用于字符输入，一般采用FileReader读取，BufferedReader包装，因为BufferedReader带有缓冲，而且能够逐行读取。示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class test1 &#123;</div><div class="line">    public static String read(String filename) throws IOException&#123;</div><div class="line">    	 BufferedReader in = new BufferedReader (new FileReader(filename));   	 </div><div class="line">    	 List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">    	 String s;</div><div class="line">    	 while((s=in.readLine())!=null)</div><div class="line">    		 list.add(s);</div><div class="line">    	 in.close();</div><div class="line">    	 return list.toString();</div><div class="line">    &#125;</div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		System.out.println(read("D:\\IOtest\\test1.txt"));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行的结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[abcd, efg, hijk, lmn, opq, qrt, <span class="number">123</span>]</div></pre></td></tr></table></figure>
<p>注意：需要逐行快速读取字符文件时，一般采用如下格式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BufferedReader in = new BufferedReader (new FileReader(filename));</div></pre></td></tr></table></figure>
<h4 id="5-2-StringReader读取字符"><a href="#5-2-StringReader读取字符" class="headerlink" title="5.2 StringReader读取字符"></a><strong>5.2 StringReader读取字符</strong></h4><p>当需要对字符进行逐个读取时，可以采用StringReader，它的read()方法可以每次读取一个字符，如下所示。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class test2 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		StringReader in = new StringReader(test1.read("D:\\IOtest\\test2.txt"));</div><div class="line">		int c;</div><div class="line">		while ((c=in.read())!=-1)</div><div class="line">			System.out.println((char)c);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line"><span class="selector-tag">a</span></div><div class="line"><span class="selector-tag">b</span></div><div class="line">c</div><div class="line">,</div><div class="line"> </div><div class="line">x</div><div class="line">y</div><div class="line">z</div><div class="line">]</div></pre></td></tr></table></figure>
<p>可以看出，StringReader的read()方法是逐个读取字符的。<br>需要逐个字符进行读取的时候，一般采用如下格式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">StringReader in = new StringReader(String s);</div></pre></td></tr></table></figure>
<h4 id="5-3-用字节流读取文件"><a href="#5-3-用字节流读取文件" class="headerlink" title="5.3 用字节流读取文件"></a><strong>5.3 用字节流读取文件</strong></h4><p>　　如果不是文本文件，那么进行读取时就要采用字节流。读取字节流采用FileInputStream(),然后用缓冲输入字节流BufferedInputStream进行包装，再用DataInputStream进行包装，如下示例，对图片进行处理。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class test3 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream("D:\\IOtest\\1.jpg")));</div><div class="line">		while(in.available()!=0)</div><div class="line">			System.out.println(in.readByte());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在程序中，图片文件被字节输入流以字节的形式进行读取，输出是数字表示的字节形式。available()用来查看还有多少可供存取的字符，从而作为一个循环终止条件。<br>注：以字节输入流读取字节文件时，采用的格式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(filename)));</div></pre></td></tr></table></figure>
<h4 id="5-4-文本文件的输出"><a href="#5-4-文本文件的输出" class="headerlink" title="5.4 文本文件的输出"></a><strong>5.4 文本文件的输出</strong></h4><p>　　当需要把数据从流中输出到文件时，可以创建FileWriter与指定文件连接，一般还要加上BufferedWriter进行包装进行缓冲输出，如下示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class test4 &#123;</div><div class="line">	static String file = "D:\\IOtest\\test4.txt";</div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		BufferedReader in = new BufferedReader(new StringReader(test1.read("D:\\IOtest\\test2.txt")));</div><div class="line">		BufferedWriter out = new BufferedWriter(new FileWriter(file));</div><div class="line">		String s;</div><div class="line">		while((s=in.readLine())!=null)</div><div class="line">			out.append(s);</div><div class="line">		out.close();</div><div class="line">		System.out.println(test1.read(file));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　如上面的示例所示，从test2.txt将数据读取到流中，然后创建缓冲输出流对象BufferedWriter，将流中的数据输出到test4.txt.<br>  　　需要注意的是：再把数据从流写入文件后，首先进的是缓冲区,在调用close()关闭时，才会把缓冲区中的数据刷新到文件中。<br>     也可以用PrintWriter包装进行格式化输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class test4 &#123;</div><div class="line">	static String file = &quot;D:\\IOtest\\test4.txt&quot;;</div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		BufferedReader in = new BufferedReader(new StringReader(test1.read(&quot;D:\\IOtest\\test2.txt&quot;)));</div><div class="line">		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(file)));</div><div class="line">		String s;</div><div class="line">		while((s=in.readLine())!=null)</div><div class="line">			out.print(s);</div><div class="line">		out.close();</div><div class="line">		System.out.println(test1.read(file));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-5-字节输出流和字节输入流进行数据存储和恢复"><a href="#5-5-字节输出流和字节输入流进行数据存储和恢复" class="headerlink" title="5.5 字节输出流和字节输入流进行数据存储和恢复"></a><strong>5.5 字节输出流和字节输入流进行数据存储和恢复</strong></h4><p>　　可以通过字节输出流DataOutputStream将写入数据，并且通过DataInputStream准确的读取数据，而忽略平台的差异性。示例程序如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class test5 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		DataOutputStream out =new DataOutputStream(new BufferedOutputStream(new FileOutputStream("D:\\IOtest\\test5.txt")));</div><div class="line">		out.writeDouble(123.123);</div><div class="line">		out.writeUTF("Hello World");</div><div class="line">		out.close();</div><div class="line">		</div><div class="line">		DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream("D:\\IOtest\\test5.txt")));</div><div class="line">		System.out.println(in.readDouble());</div><div class="line">		System.out.println(in.readUTF());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">123.123</span></div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>　　需要注意的是：我为了保证读操作能够正常工作，写操作和读操作是要一一对应，而且，要知道流中数据项具体的位置。如上面的示例所用，如果把读操作的顺序调换为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(in.readUTF());</div><div class="line">System.out.println(in.readDouble());</div></pre></td></tr></table></figure>
<p>那么，就没有一一对应，数据读取时就会报错。<br>　　另外，readUTF()和writeUTF()使用的是适合于Java的UTF-8编码格式，如果用非Java程序读写UTF-8的字符串，就必须编写一些特殊的代码。</p>
<h4 id="5-6-用System-in从键盘输入"><a href="#5-6-用System-in从键盘输入" class="headerlink" title="5.6 用System.in从键盘输入"></a><strong>5.6 用System.in从键盘输入</strong></h4><p>System.in是一个未被包装和加工的InputStream，通过它可以实现从键盘读入数据。一般来说，需要用InputStreamReader把System.in转化成Reader，然后再用BufferedReader进行包装，从而实现逐行读入，示例代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class test7 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));</div><div class="line">		String s;</div><div class="line">		while((s=bf.readLine())!=null &amp;&amp; s.length()!=0)</div><div class="line">			System.out.println(s);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-新IO及其主要用法"><a href="#6-新IO及其主要用法" class="headerlink" title="6.新IO及其主要用法"></a><strong>6.新IO及其主要用法</strong></h2><p>　　在jdk 1.4之后，Java引入了新的Java.IO类库，命名为java.nio.，主要的目的是提高速度。新IO处理速度的提高得益于它使用通道和缓冲器，我们只是和缓冲器交互。<br> 　　Java新IO中，唯一与通道交互的缓冲器就是ByteBuffer。Java流中，有三个类被修改，用来生成通道，分别是FileInputStream、FileOutputStream和RandomAccessFile，ByteBuffer与这些流对象产生的通道进行交互，进行数据的读写。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line">import java.nio.*;</div><div class="line">import java.nio.channels.FileChannel;</div><div class="line"></div><div class="line">public class test8 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		FileChannel fc= new FileOutputStream("D:\\IOtest\\test8.txt").getChannel();</div><div class="line">		fc.write(ByteBuffer.wrap("abc".getBytes()));</div><div class="line">		fc.close();</div><div class="line">		</div><div class="line">		fc =new RandomAccessFile("D:\\IOtest\\test8.txt","rw").getChannel();</div><div class="line">		fc.position(fc.size());</div><div class="line">		fc.write(ByteBuffer.wrap("xyz".getBytes()));</div><div class="line">		fc.close();</div><div class="line">		</div><div class="line">		fc = new FileInputStream("D:\\IOtest\\test8.txt").getChannel();</div><div class="line">		ByteBuffer buff = ByteBuffer.allocate(1024);</div><div class="line">		fc.read(buff);</div><div class="line">		buff.flip();</div><div class="line">		while(buff.hasRemaining())</div><div class="line">			System.out.println((char)buff.get());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span></div><div class="line"><span class="selector-tag">b</span></div><div class="line">c</div><div class="line">x</div><div class="line">y</div><div class="line">z</div></pre></td></tr></table></figure>
<p>　　如上述程序示例：首先是字节输出流FileOutputStream类调用getChannel()方法产生通道，通道调用write方法写入数据。在使用时，使用warp方法将已存在的字节数组包装到ByteBuffer中。第二段中，利用RandomAccessFile产生通道，并可以移动通道位置并向里面写入数据。第三段中，调用字节输入流FileInputStream产生通道，该通道是只读访问，显式的调用allocate方法分配缓冲器。需要注意的是：一旦调用read()来告知FileChannel向缓冲器存储字节时，就必须调用缓冲器的flip方法再进行数据的读取。</p>
<h2 id="7-压缩"><a href="#7-压缩" class="headerlink" title="7.压缩"></a><strong>7.压缩</strong></h2><p>　　Java的IO类库也支持读写压缩格式的数据类。根据压缩格式的不同，可以分为GZIP和Zip，对应的四个流为ZipOutputStream、GZIPOutputStream、ZipInputStream和GZIPInputStream。</p>
<h4 id="7-1-用GZIP进行单个文件压缩"><a href="#7-1-用GZIP进行单个文件压缩" class="headerlink" title="7.1 用GZIP进行单个文件压缩"></a><strong>7.1 用GZIP进行单个文件压缩</strong></h4><p>如果对单个数据流进行压缩，用GZIP是个常用的选择，使用的示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line">import java.util.zip.*;</div><div class="line"></div><div class="line">public class test9 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		BufferedReader in = new BufferedReader(new FileReader("D:\\IOtest\\test9.txt"));</div><div class="line">		BufferedOutputStream out =new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream("D:\\IOtest\\test9.gz")));</div><div class="line">		</div><div class="line">		int c;</div><div class="line">		while((c=in.read())!=-1)</div><div class="line">			out.write(c);</div><div class="line">		in.close();</div><div class="line">		out.close();</div><div class="line">		</div><div class="line">		BufferedReader in2 = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream("D:\\IOtest\\test9.gz"))));</div><div class="line">		String s;</div><div class="line">		while((s=in2.readLine())!=null)</div><div class="line">			System.out.println(s);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">abcsadsa</div><div class="line">sadjaisjals</div><div class="line">sdjcsd</div><div class="line">djsadjca</div><div class="line">sjisadi</div><div class="line">sdjsdj</div><div class="line">sdjcisd</div></pre></td></tr></table></figure>
<p>使用方式是将输出流封装成GZIPOutputStream，将输入流封装成GZIPInputStream，其他的是之前学习的普通的IO流。<br>常用的格式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BufferedOutputStream out =new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream(file)));//输出流</div><div class="line"></div><div class="line">BufferedReader in2 = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(file))));//输入流</div></pre></td></tr></table></figure>
<h4 id="7-2-使用ZIP压缩多个文件"><a href="#7-2-使用ZIP压缩多个文件" class="headerlink" title="7.2 使用ZIP压缩多个文件"></a><strong>7.2 使用ZIP压缩多个文件</strong></h4><p>Zip比GZIP功能更强大一些，它能够把多个文件进行压缩。其次，能够用Checksum类来计算和校验文件的校验和的方法，一共有两种Checksum类型，分别是Adler32（快一些）和CRC32（慢一些）。示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package IOtest;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line">import java.util.zip.*;</div><div class="line"></div><div class="line">public class test10 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		FileOutputStream f = new FileOutputStream("D:\\IOtest\\test10.zip");</div><div class="line">		CheckedOutputStream csum = new CheckedOutputStream(f,new Adler32());</div><div class="line">		ZipOutputStream zos = new ZipOutputStream(csum);</div><div class="line">		BufferedOutputStream out = new BufferedOutputStream(zos);</div><div class="line">        </div><div class="line">		//压缩入第一个文件</div><div class="line">		BufferedReader in1 = new BufferedReader(new FileReader("D:\\IOtest\\test1.txt"));</div><div class="line">		zos.putNextEntry(new ZipEntry("D:\\IOtest\\test1.txt"));</div><div class="line">		int c;</div><div class="line">		while((c=in1.read())!=-1)</div><div class="line">			out.write(c);</div><div class="line">		in1.close();</div><div class="line">		out.flush();</div><div class="line">        </div><div class="line">		//压缩入第二个文件</div><div class="line">		BufferedReader in2 = new BufferedReader(new FileReader("D:\\IOtest\\test2.txt"));</div><div class="line">		zos.putNextEntry(new ZipEntry("D:\\IOtest\\test2.txt"));</div><div class="line">		int c1;</div><div class="line">		while((c1=in2.read())!=-1)</div><div class="line">			out.write(c1);</div><div class="line">		in2.close();</div><div class="line">		out.close();</div><div class="line">        </div><div class="line">        //解压缩文件</div><div class="line">		FileInputStream fi = new FileInputStream("test10.zip");</div><div class="line">		CheckedInputStream csumi= new CheckedInputStream(fi,new Adler32());</div><div class="line">		ZipInputStream zin= new ZipInputStream(csumi);</div><div class="line">		BufferedInputStream bis = new BufferedInputStream(zin);</div><div class="line">		ZipEntry ze;</div><div class="line">		while((ze=zin.getNextEntry())!=null)</div><div class="line">			System.out.println(ze);</div><div class="line">		int x;</div><div class="line">		while((x=bis.read())!=-1)</div><div class="line">			System.out.write(x);</div><div class="line">		bis.close();		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:\IOtest\test1<span class="selector-class">.txt</span></div><div class="line">D:\IOtest\test2.txt</div></pre></td></tr></table></figure>
<p>上述程序示例，完成了两个文件的压缩和解压缩。在D盘IOTest文件夹下，能够看到被压缩的文件</p>
<ul>
<li>为压缩文件做准备。利用FileOutputStream创建文件字节输出流，CheckedOutputStream对其进行校验，ZipOutputStream创建新的Zip输出流，然后再放入缓冲字符输出流中</li>
<li>接下来就是把文件放置Zip输出流中，把需要压缩的文件读入字符输出流，调用ZipEntry创建Zip名目，进行内容的读入，并写进Zip输出流中</li>
<li>解压缩的过程与压缩过程相反，通过解压缩，可以读取到压缩文件里面的内容</li>
</ul>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a><strong>8.总结</strong></h2><ul>
<li>IO流能够完成数据的读写和传输，主要掌握四个流体系及其继承子类的使用方法和使用场合</li>
<li>IO不是单独使用的，大多数情况下都是组合在一起，这其中，带有缓冲的流应用的较多，因为读写更加高效</li>
<li>新IO与之前IO不同点在于使用ByteArray来完成对数据的操纵</li>
<li>压缩文件主要有GZIP和Zip两种，后面还要学习jar</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/11/《Java编程思想》学习笔记之File类（IO）/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/《Java编程思想》学习笔记之File类（IO）/" itemprop="url">
                  《java编程思想》学习笔记之File类(IO)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T00:20:21+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2017/01/11/《Java编程思想》学习笔记之File类（IO）/" class="leancloud_visitors" data-flag-title="《java编程思想》学习笔记之File类(IO)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　对于任何一种计算机语言来说，IO系统都是一个复杂而且重要的部分。Java通过IO类库提供了大量的类来解决IO问题，IO流中的大部分类是对文件中的数据进行操作的，而File类是与文件及文件目录本身有关系的类。它主要有创建、获取、判断、删除更改方法。本章主要对File类的特点和应用进行学习。<br>  本章要点：</p>
<ul>
<li>File构造方法</li>
<li>File 类的创建功能</li>
<li>File 类的获取功能</li>
<li>File 类的判断功能</li>
<li>File类的删除与更改功能</li>
<li>总结</li>
</ul>
<h2 id="1-File构造方法"><a href="#1-File构造方法" class="headerlink" title="1. File构造方法"></a><strong>1. File构造方法</strong></h2><p>　　通过向File类的构造方法传入相应的路径参数来创建File实例，常用的主要有以下几种构造方法。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">File</span><span class="params">(String pathname)</span></span>  <span class="comment">//通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">File</span><span class="params">(String parent,String child)</span></span>  <span class="comment">//根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">File</span><span class="params">(File parent,String child)</span></span> <span class="comment">//根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例</span></div></pre></td></tr></table></figure>
<p>　　比如，我们想要将D盘的FileTest文件夹下的某个文本文件封装成一个File文件，通过这几个构造方法，分别可以采用如下的格式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package FileTest;</div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class test1 &#123;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">         //通过第一个构造方法创建File对象</div><div class="line">		 File file1 = new File("D:\\FileTest\\1.txt");</div><div class="line">         </div><div class="line">         //通过第二个构造方法创建File对象</div><div class="line">         File file2 = new File("D:\\/FileTest","2.txt");</div><div class="line">         </div><div class="line">         //通过第三个构造方法创建File对象</div><div class="line">         File file3 = new File("D:\\FileTest");</div><div class="line">         File file4 = new File(file3,"3.txt");	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-File-类的创建功能"><a href="#2-File-类的创建功能" class="headerlink" title="2. File 类的创建功能"></a><strong>2. File 类的创建功能</strong></h2><p>　　File类中，可以完成创建功能的方法主要有以下几种。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">createNewFile</span><span class="params">()</span></span> <span class="comment">//检查文件是否存在，若不存在则创建该文件。如果指定的文件不存在并成功地创建，则返回 true；如果指定的文件已经存在，则返回 false</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">mkdirs</span><span class="params">()</span></span><span class="comment">//创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。如果该目录(或多级目录)能被创建则为 true；否则为 fals</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">mkdir</span><span class="params">()</span></span><span class="comment">//只能在已经存在的目录中创建创建目录。如果该目录能被创建则为 true；否则为 false</span></div></pre></td></tr></table></figure>
<p>　　在D盘下进行操作，对这三个方法进行验证。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package FileTest;</div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class test1 &#123;</div><div class="line">	</div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		 File file1 = new File("D:\\1.txt");</div><div class="line">		 System.out.println(file1.createNewFile());</div><div class="line">		 </div><div class="line">		 File file2 = new File("D:\\a\\b");</div><div class="line">		 System.out.println(file2.mkdirs());</div><div class="line">		 </div><div class="line">		 File file3 = new File("D:\\c\\d");</div><div class="line">		 System.out.println(file3.mkdir());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次运行结果为</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div><div class="line">false</div></pre></td></tr></table></figure>
<p>　　第一次运行时，D盘下没有1.txt文件，所以创建该文件，并返回结果为true;D盘下没有a文件夹和b文件夹，mkdirs()能够创建多重目录，并且返回为true；D盘下没有c文件夹和d文件夹，mkdir()不能够创建多重目录，返回为false<br>　　第二次的运行结果为:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">false</div><div class="line">false</div><div class="line">false</div></pre></td></tr></table></figure>
<p>　　第一次创建后，D盘下已经存在1.txt文件和文件夹a以及文件夹b，所以返回值均为false。</p>
<h2 id="3-File-类的获取功能"><a href="#3-File-类的获取功能" class="headerlink" title="3. File 类的获取功能"></a><strong>3. File 类的获取功能</strong></h2><p>　　File类中的获取功能主要有get相关的和list相关的，一般情况下，list相关的应用的较多，主要的几个方法如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">list</span><span class="params">()</span></span>  <span class="comment">//获取到的是目录下全部的文件和文件夹</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">list</span><span class="params">(FilenameFilter filter)</span></span> <span class="comment">// 获取到的是目录下满足过滤器的文件和文件夹</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">listFiles</span><span class="params">()</span></span><span class="comment">//返回带有绝对路径名的文件和文件夹</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">listFiles</span><span class="params">(FilenameFilter filter)</span></span><span class="comment">//返回满足过滤器的带有绝对路径名的文件和文件夹</span></div></pre></td></tr></table></figure>
<p>　　通过示例进行验证，在D盘下手动建立名为abc的文件夹，在该文件夹下，有一个efg文件夹，一个123.txt文件，一个新建的word文档，一个新建的excel表格。程序如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">package FileTest;</div><div class="line">import java.io.*;</div><div class="line">import java.util.regex.Pattern;</div><div class="line"></div><div class="line">public class test1 &#123;</div><div class="line">	</div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		 File file1 = new File("D:\\abc");</div><div class="line">		 String[] f1 =file1.list();</div><div class="line">		 for(String fl :f1)</div><div class="line">			 System.out.println(fl);</div><div class="line">		     System.out.println("------------------");</div><div class="line">		 </div><div class="line">		 String[] f2=file1.list(new FilenameFilter()&#123;</div><div class="line">			 private Pattern p=Pattern.compile(".+txt$");</div><div class="line">			 public boolean accept(File fir,String name)&#123;</div><div class="line">				 return p.matcher(name).matches();</div><div class="line">			 &#125;</div><div class="line">		 &#125;);</div><div class="line">		 for(String fi :f2)</div><div class="line">			 System.out.println(fi);</div><div class="line">		 System.out.println("------------------");</div><div class="line">		 </div><div class="line">		 File file2 = new File("D:\\abc");</div><div class="line">		 File[] f3 =file2.listFiles();</div><div class="line">		 for(File fi :f3)</div><div class="line">			 System.out.println(fi);</div><div class="line">		 System.out.println("------------------");</div><div class="line">		 </div><div class="line">		 File file3 = new File("D:\\abc");</div><div class="line">		 File[] f4 =file2.listFiles(new FilenameFilter()&#123;</div><div class="line">			 private Pattern p=Pattern.compile(".+txt$");</div><div class="line">			 public boolean accept(File fir,String name)&#123;</div><div class="line">				 return p.matcher(name).matches();</div><div class="line">			 &#125;</div><div class="line">		 &#125;);</div><div class="line">		 for(File fi :f4)</div><div class="line">			 System.out.println(fi);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序运行结果为;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">123</span><span class="selector-class">.txt</span></div><div class="line">edf</div><div class="line">新建 Microsoft Excel 工作表<span class="selector-class">.xlsx</span></div><div class="line">新建 Microsoft Word 文档<span class="selector-class">.docx</span></div><div class="line">------------------</div><div class="line"><span class="number">123</span><span class="selector-class">.txt</span></div><div class="line">------------------</div><div class="line">D:\abc\<span class="number">123</span><span class="selector-class">.txt</span></div><div class="line">D:\abc\edf</div><div class="line">D:\abc\新建 Microsoft Excel 工作表<span class="selector-class">.xlsx</span></div><div class="line">D:\abc\新建 Microsoft Word 文档<span class="selector-class">.docx</span></div><div class="line">------------------</div><div class="line">D:\abc\<span class="number">123</span>.txt</div></pre></td></tr></table></figure>
<p>　　注意，在使用list(FilenameFilter filter)和listFiles(FilenameFilter filter)时，传入的对象要实现FilenameFilter接口，通过正则表达式设定过滤器，在本例中，是通过匿名内部类实现的。</p>
<h2 id="4-File-类的判断功能"><a href="#4-File-类的判断功能" class="headerlink" title="4. File 类的判断功能"></a><strong>4. File 类的判断功能</strong></h2><p>　　判断方法也是File类的一个重要功能，常用的主要有以下几种：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">exists</span><span class="params">()</span></span><span class="comment">// 判断一个文件或者文件夹是否存在</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">isFile</span><span class="params">()</span></span><span class="comment">// 测试此抽象路径名表示的文件是否是一个标准文件，如果是则返回为真，如果是文件目录，则返回为假</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">isDirectory</span><span class="params">()</span></span><span class="comment">//测试此抽象路径名表示的文件是否是一个目录，当且仅当此抽象路径名表示的文件存在且 是一个目录时，返回 true；否则返回 false</span></div></pre></td></tr></table></figure>
<p>还是沿用D盘下的那个文件结构，验证上述方法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package FileTest;</div><div class="line"></div><div class="line">import java.io.File;</div><div class="line"></div><div class="line">public class test2 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		File file1 = new File("D:\\abc\\123.txt");</div><div class="line">		System.out.println(file1.isFile());</div><div class="line">		System.out.println(file1.exists());</div><div class="line">		System.out.println("------");</div><div class="line">		</div><div class="line">		File file2 = new File("D:\\abc\\edf");</div><div class="line">		System.out.println(file2.isFile());</div><div class="line">		System.out.println(file2.exists());</div><div class="line">		System.out.println("------");</div><div class="line">		</div><div class="line">		File file3 = new File("D:\\abc\\123.txt");</div><div class="line">		System.out.println(file3.isDirectory());</div><div class="line">		System.out.println(file3.exists());</div><div class="line">		System.out.println("------");</div><div class="line"></div><div class="line">		File file4 = new File("D:\\abc\\edf");</div><div class="line">		System.out.println(file4.isDirectory());</div><div class="line">		System.out.println(file4.exists());	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回的结果为;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div><div class="line">------</div><div class="line">false</div><div class="line">true</div><div class="line">------</div><div class="line">false</div><div class="line">true</div><div class="line">------</div><div class="line">true</div><div class="line">true</div></pre></td></tr></table></figure>
<h2 id="5-File类的删除与更改功能"><a href="#5-File类的删除与更改功能" class="headerlink" title="5. File类的删除与更改功能"></a><strong>5. File类的删除与更改功能</strong></h2><p>File类中，常用的删除和更改功能是deleted和renameTo,如下;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">delete</span><span class="params">()</span></span><span class="comment">// 删除此抽象路径名表示的文件或目录。</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">renameTo</span><span class="params">()</span></span><span class="comment">// 重新命名此抽象路径名表示的文件,当且仅当重命名成功时，返回 true；否则返回 false</span></div></pre></td></tr></table></figure>
<p>依旧用D盘的文件体系进行验证：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package FileTest;</div><div class="line"></div><div class="line">import java.io.File;</div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">public class test3 &#123;</div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		File file1 = new File("D:\\abc\\123.txt");</div><div class="line">		File file2 = new File("D:\\abc\\edf\\456.txt");</div><div class="line">		System.out.println(file1.renameTo(file2));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">true</div></pre></td></tr></table></figure>
<p>再运行一次，结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">false</div></pre></td></tr></table></figure>
<p>关于renameTo方法，需要注意的是：<br>1.file1不管是代表一个目录，还是一个文件的路径都必须是在磁盘上存在的。<br>2.file2与file1相反，代表一个不存在的目录或文件路径（仅限最后一个’\’后面文件夹或文件的不存在，其余的目录必须已存在）。<br><strong><strong>两个条件必须同时具备，而且执行该操作后，file1文件将不再存在。</strong></strong><br>  delete方法应用比较简单，基于上面的操作后，程序示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package FileTest;</div><div class="line"></div><div class="line">import java.io.File;</div><div class="line"></div><div class="line">public class test4 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		File file1 = new File("D:\\abc");</div><div class="line">		System.out.println(file1.delete());</div><div class="line">		</div><div class="line">		File file2 = new File("D:\\abc\\edf\\456.txt");</div><div class="line">		System.out.println(file2.delete());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">false</div><div class="line">true</div></pre></td></tr></table></figure>
<p>　　需要注意的是：如果此路径名表示一个目录，则该目录必须为空才能删除。 当且仅当成功删除文件或目录时，返回 true；否则返回 false</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a><strong>6.总结</strong></h2><ol>
<li>File类是java.io类库中的重要部分，通过它可以对文件本身进行操作，其主要的方法有增删改查，增即创建文件，删即删除文件，改即重命名文件，查即获取文件。</li>
<li>IO中除了对文件本身的操作，更重要的是对文件的内容进行操作，在后面要对IO流体系进行学习</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/08/《Java编程思想》学习笔记之hashcode与equals/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/08/《Java编程思想》学习笔记之hashcode与equals/" itemprop="url">
                  《Java编程思想》学习笔记之hashcode与equals
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-08T23:22:12+08:00">
                2017-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2017/01/08/《Java编程思想》学习笔记之hashcode与equals/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之hashcode与equals">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　在对容器进行进一步的学习时，发现hashcode和equals方法也是其中一个很重要的知识点。在容器类中，使用hash算法的有HashSet、HashMap、LinkedHashSet、LinkedHashMap。以HashSet为例，它不允许加入重复的元素，且拥有较快的查询速度。<br>  　　如下，创建一个Person类，并建立容器HashSet，往里面添加Person元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">  package test3;</div><div class="line"></div><div class="line">public class Person &#123;</div><div class="line">    private int age;</div><div class="line">    private String name;</div><div class="line">    public Person(String name,int age)&#123;</div><div class="line">    	this.age=age;</div><div class="line">    	this.name=name;</div><div class="line">    &#125;</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public String toString()&#123;</div><div class="line">		return &quot;name=&quot;+name+&quot;  &quot;+&quot;age=&quot;+age+&quot;&quot;;</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">package test3;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class HashTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();</div><div class="line">		set.add(new Person(&quot;zhangsan&quot;,25));</div><div class="line">		set.add(new Person(&quot;lisi&quot;,26));</div><div class="line">		set.add(new Person(&quot;zhangsan&quot;,25));</div><div class="line">		System.out.println(set);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行的结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[name=lisi  age=<span class="number">26</span>, name=zhangsan  age=<span class="number">25</span>, name=zhangsan  age=<span class="number">25</span>]</div></pre></td></tr></table></figure>
<p>　　输出结果中，发现一问题：name=zhangsan  age=25被重复添加了，不符合HashSet存储数据的要求。但是在之前的学习中，我添加的整型数据没有出现过这类的问题，这是为什么呢？<br>  　　经过学习，发现HashSet添加数据，判断是不是重复元素，是通过内部的equals方法实现的，euqals方法是根类Object提供的，默认的是比较元素的内存地址值。而对象的内存地址是hashcode实现的。<br>    　　当我们添加两次name=zhangsan  age=25时，生成的是两个不同的内存地址，在添加时，被看成是两个不同的对象。但是在实际应用时，我们认为这两个是同一个对象，不能够被重复加入，因此需要对此进行改进。改进的方法时同时复写Person类的hashcode()和equals()方法，这样能够根据自己的需要构建比较的基准，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">package test3;</div><div class="line"></div><div class="line">public class Person &#123;</div><div class="line">    private int age;</div><div class="line">    private String name;</div><div class="line">    public Person(String name,int age)&#123;</div><div class="line">    	this.age=age;</div><div class="line">    	this.name=name;</div><div class="line">    &#125;</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public String toString()&#123;</div><div class="line">		return &quot;name=&quot;+name+&quot;  &quot;+&quot;age=&quot;+age+&quot;&quot;;</div><div class="line">	&#125;</div><div class="line">    public int hashCode()&#123;</div><div class="line">    	int result=47;</div><div class="line">    	result = 24*result+this.name.hashCode();</div><div class="line">    	result = 24*result+this.age;</div><div class="line">    	return result;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    public boolean equals(Object o)&#123;</div><div class="line">    	return o instanceof Person&amp;&amp;this.name.equals(((Person)o).name)&amp;&amp;this.age==(((Person)o).age);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">package test3;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class HashTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();</div><div class="line">		set.add(new Person(&quot;zhangsan&quot;,25));</div><div class="line">		set.add(new Person(&quot;lisi&quot;,26));</div><div class="line">		set.add(new Person(&quot;zhangsan&quot;,25));</div><div class="line">		System.out.println(set);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行的结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[name=lisi  age=<span class="number">26</span>, name=zhangsan  age=<span class="number">25</span>]</div></pre></td></tr></table></figure>
<p>　　可以发现，重复的对象没有被添加进来。hashcode值基于对象的姓名和年龄进行了重新的定义，equals()也对姓名和年龄进行比较，当所有信息完全一致时，就认定为同一对象。<br>  　　为什么之前添加整型数据时，没有对整型的hashcode和equals复写，也能够自动识别重复对象呢？这是因为基本类型数据的对应装箱类型对象中，系统已经对这两个方法进行了重写，所以我们能够直接使用。而对于我们自己创建的对象而言，需要自己覆写这两个方法。</p>
<h4 id="需要注意的是："><a href="#需要注意的是：" class="headerlink" title="需要注意的是："></a><strong>需要注意的是：</strong></h4><ol>
<li>equals()和hashcode()是Object中的两个方法，需要<strong>同时</strong>被复写。</li>
<li>对于两个比较的对象，如果euqals()方法返回的为真，则它们的哈希值一定相等，反之，如果它们的哈希值相等，equals()返回的值不一定为真。</li>
<li>Java集合中判断两个对象的原则是：如果这两个对象的哈希值不相等，则两个对象不相同，如果两个对象的哈希值相等，进而通过euqals()方法的返回值来判断对象的属性是否相同，如果返回为真，则这两个对象相同，反之，则两个对象不同。<br>4.这两个方法在HashMap也应用较多，需要加以学习。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/08/《Java编程思想》学习笔记之泛型/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="xuwei1991">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="xuwei'blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="xuwei'blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/08/《Java编程思想》学习笔记之泛型/" itemprop="url">
                  《Java编程思想》学习笔记之泛型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-08T19:37:43+08:00">
                2017-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          
             <span id="/2017/01/08/《Java编程思想》学习笔记之泛型/" class="leancloud_visitors" data-flag-title="《Java编程思想》学习笔记之泛型">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　之前学习的内容中，一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类，代码的通用性较低。后来学习了Java的多态机制，使得程序代码具有更强的灵活性。在Java SE5之后，Java提供了泛型的概念。泛型就是适用于许多的类型。它实现了参数化类型的概念，使代码能够应用于多种类型，能够应用在容器、接口、方法和类中。<br>  本章学习要点：</p>
<ul>
<li>泛型在容器类中的应用</li>
<li>泛型在接口中的应用</li>
<li>泛型在方法中的应用</li>
<li>泛型在匿名内部类中的应用</li>
<li>泛型的擦除机制</li>
<li>泛型边界（extends和super）与通配符<h2 id="1-泛型在容器类中的应用"><a href="#1-泛型在容器类中的应用" class="headerlink" title="1.泛型在容器类中的应用"></a><strong>1.泛型在容器类中的应用</strong></h2>　　容器能够同时持有多种类型的对象，但是，大多数情况下，我们会使用容器来存储一种类型的对象。而泛型的主要目的之一就是指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。如下代码所示：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">public class LinkedListTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		List&lt;String&gt; a = new LinkedList&lt;String&gt;();</div><div class="line">		a.add("AAA");</div><div class="line">		a.add("BBB");</div><div class="line">		//a.add(123);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>如上所示，List容器能够存放多种类型的数据，但是由于应用需要，我们只在里面存储字符串类型。因此，通过泛型参数类型String来进行指定存储的类型。当我们添加了整型数据123时，程序在编译阶段就会提 在加类型不符，保证了添加数据的正确型。如果不用泛型进行限定，数据能够被添加进去，但是为后续的使用留下了隐患。<br>　　泛型在类中更广泛的使用是增加代码的复用性。创建一个类时，暂时不指定使用类型，用类型参数代替，之后再用实际的类型替换这个类型参数。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Automobile&#123;&#125;</div><div class="line"></div><div class="line">public class Holder&lt;T&gt;&#123;</div><div class="line">     private T a;</div><div class="line">     public Holder(T a)&#123;this.a = a;&#125;</div><div class="line">     public void set(T a)&#123;this.a = a;&#125;</div><div class="line">     public T get() &#123;return a;&#125;</div><div class="line">     public static void main(String[] args)&#123;</div><div class="line">           Holder&lt;Automobile&gt; h = new Holder&lt;Automobile&gt;(new Automobile());</div><div class="line">           Automobile a = h.get();</div><div class="line">//h.set("abc");</div><div class="line">//h.set(123);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　如上所示，创建Holder类时，使用类型参数符号T代替。当我们创建Holder对象时，就必须指明想要持有什么类型的对象，之后由编译器保证类型的正确性。这也是Java泛型的核心概念，那就是告诉编译器想使用什么类型，然后由编译器来处理细节问题。</p>
<h2 id="2-泛型在接口中的应用"><a href="#2-泛型在接口中的应用" class="headerlink" title="2.泛型在接口中的应用"></a><strong>2.泛型在接口中的应用</strong></h2><p>泛型也可以应用在接口中，其应用与在类中应用相似。接口用泛型表示，当具体的类实现这个接口时，可以指定接口的具体类型，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package fanxingTest;</div><div class="line"></div><div class="line">public interface Generator&lt;T&gt; &#123;</div><div class="line">   T next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">package fanxingTest;</div><div class="line"></div><div class="line"></div><div class="line">public class Fibonacci implements Generator&lt;Integer&gt;&#123;</div><div class="line">    private int count =0;</div><div class="line">    public Integer next()&#123;return fib(count++);&#125;</div><div class="line">    private int fib(int n)&#123;</div><div class="line">    	if (n&lt;2) return 1;</div><div class="line">    	return fib(n-2)+fib(n-1);</div><div class="line">    &#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Fibonacci gen = new Fibonacci();</div><div class="line">		for(int i =0;i&lt;18;i++)</div><div class="line">			System.out.print(gen.next()+",");</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">377</span>,<span class="number">610</span>,<span class="number">987</span>,<span class="number">1597</span>,<span class="number">2584</span>,</div></pre></td></tr></table></figure>
<p>　　在上述示例中，接口Generator用泛型T表示。当具体的类Fibonacci实现了这个接口时，指定类型为整型。如果我们在next()方法中尝试返回其他类型的数据，编译器就会提示类型不匹配，有效的保证了数据安全。<br>  　　需要注意的是，我们在类中使用的是基本数据类型int，但是参数类型是Integer。这是因为，Java泛型存在一个局限性，那就是基本类型无法作为类型参数。但是Java具备了自动装箱和自动拆箱的功能，能够在基本类型和相应的包装类型之间转换。</p>
<h2 id="3-泛型在方法中的应用"><a href="#3-泛型在方法中的应用" class="headerlink" title="3.泛型在方法中的应用"></a><strong>3.泛型在方法中的应用</strong></h2><p>　　泛型也可以作用在方法之上，使得方法能够独立于类而产生变化。是否拥有泛型方法与所在类是否为泛型类无关。<br>  　　定义泛型方法，只需要<strong>将泛型的参数列表放置在方法的返回值之前</strong>，如以下的代码所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    package fanxingTest;</div><div class="line"></div><div class="line">public class GenericMethod &#123;</div><div class="line">    public &lt;T&gt; void method(T x)&#123;</div><div class="line">    	System.out.println(x.getClass().getName());</div><div class="line">    &#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		GenericMethod gm = new GenericMethod();</div><div class="line">		gm.method(123);</div><div class="line">		gm.method(&quot;abc&quot;);</div><div class="line">		gm.method(gm);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java<span class="selector-class">.lang</span><span class="selector-class">.Integer</span></div><div class="line">java<span class="selector-class">.lang</span><span class="selector-class">.String</span></div><div class="line">fanxingTest.GenericMethod</div></pre></td></tr></table></figure>
<p>　　可以看出，类GenericMethod不是泛型类，但是它包含有泛型方法method()，使用泛型方法时，不必指明参数类型，因为编译器可以找出具体的类型，这一特性也被称为<strong>类型参数推断</strong>。另外，在调用method()方法过程中，传入的是基本数据类型，自动装箱机制发挥作用，将它包装为对应的对象。<br>  　　对于类型推断而言，它只对赋值操作有效，如果将泛型方法调用的结果作为参数传递给另外一个方法，这个时候编译器不会执行类型推断，因为在这种情况下，编译器认为调用泛型方法后，返回值付给了一个Object类型对象。要想进行使用，则必须在泛型方法中显式的指明参数类型。</p>
<h2 id="4-泛型在匿名内部类中的应用"><a href="#4-泛型在匿名内部类中的应用" class="headerlink" title="4. 泛型在匿名内部类中的应用"></a><strong>4. 泛型在匿名内部类中的应用</strong></h2><p>匿名内部类也可以指定泛型的参数类型，如下所示。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Class A&#123;</div><div class="line">private A()&#123;&#125;</div><div class="line">public static Generator&lt;A&gt; generator&#123;</div><div class="line">return new Generator&lt;A&gt;()&#123;</div><div class="line">public A next()&#123;return new A();&#125;</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>泛型的匿名内部类还有另外一种形式如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class B&#123;</div><div class="line">private B()&#123;&#125;</div><div class="line">public static Generator&lt;B&gt; generator = new Generator&lt;B&gt;()&#123;</div><div class="line">public B next()&#123;return new B()&#125;</div><div class="line">&#125;；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="5-泛型的擦除机制"><a href="#5-泛型的擦除机制" class="headerlink" title="5.泛型的擦除机制"></a><strong>5.泛型的擦除机制</strong></h2><p>　　在泛型代码内部，无法获得任何有关泛型参数类型的信息。这就意味着当我们在使用泛型时，所能知道的就是在使用一个对象。如以下的示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package fanxingTest;</div><div class="line"></div><div class="line">import java.util.*;</div><div class="line"></div><div class="line">public class cachu &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Class c1 = new ArrayList&lt;Integer&gt;().getClass();</div><div class="line">		Class c2 = new ArrayList&lt;String&gt;().getClass();</div><div class="line">		System.out.println(c1==c2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">true</div></pre></td></tr></table></figure>
<p>　　ArrayList<integer<integer>&gt;和ArrayList<string<string>&gt;在使用时是不同的类型。我们不能把整型数据放置在数组型容器中，也不能把数组型数据放置在整型容器中。<br>　　但是，它们在运行时事实上是相同的类型，zhe’liang这两种形式都被擦除成它们的原生类型ArrayList，所以上述程序的返回结果为true。<br>    　　Java泛型是Java SE5出现的，它的擦除机制实现非泛化代码向泛化代码转变，在不破坏现有类库的情况下，将泛型融入Java语言。<br>      　　泛型类型只有在静态类型检查时才出现，之后，程序中的泛型类型都将被擦除，替换成它们的非泛型上界，未指定情况下，上界为Object。<br>        由于擦出的存在，泛型不能够显式的引用运行时类型的操作之中，比如转型、instanceof和new等。<br>        如下;<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package fanxingTest;</div><div class="line">class cat&#123;</div><div class="line">	public static void method()&#123;System.out.println("method run");&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Foo &lt;T&gt;&#123;</div><div class="line">    //T var = new T() ;  会报错</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Foo&lt;cat&gt; c=new Foo&lt;cat&gt;();</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></string<string></integer<integer></p>
<h2 id="6-泛型边界（extends和super）与通配符"><a href="#6-泛型边界（extends和super）与通配符" class="headerlink" title="6.泛型边界（extends和super）与通配符"></a><strong>6.泛型边界（extends和super）与通配符</strong></h2><ul>
<li>？表示无界通配符</li>
<li>‘&lt;? extends T&gt;表示上界，即参数类型为T或者T的子类，协变</li>
<li><p>‘&lt;? super T&gt; 表示下界，即参数类型为T或者T的超类，逆变</p>
<p>比如，有这样的几个类：</p>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Fruit&#123;&#125;</div><div class="line">class Apple extends Fruit&#123;&#125;</div><div class="line">class Orange extends Fruit&#123;&#125;</div><div class="line">class HongFuShi extends Apple&#123;&#125;</div></pre></td></tr></table></figure>
<p>当我们想要创建一个Fruit容器来接收Apple对象时，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Fruit&gt; list = new ArrayList&lt;Apple&gt;();</div></pre></td></tr></table></figure>
<p>　　Apple是Fruit的子类，但是上述的程序会报错，原因是List<apple<apple>&gt;并不是List<fruit<apple>&gt;的子类。因为泛型容器不支持协变，在泛型容器中, List<apple<apple>&gt;和List<fruit<apple>&gt;是两种不同的List类型, 并不存在内在的继承关系。<br>  　　为了建立这两个容器类型中的继承关系，可以用通配符来解决协变问题。如下代码所示。</fruit<apple></apple<apple></fruit<apple></apple<apple></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    public class GenericsAndCovariance &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();</div><div class="line">        // 编译错误，不能添加任何对象，null除外</div><div class="line">        // flist.add(new Apple());</div><div class="line">        // flist.add(new Fruit());</div><div class="line">        // flist.add(new Object());</div><div class="line">        flist.add(null); // Legal but uninteresting</div><div class="line">        // We know that it returns at least Fruit:</div><div class="line">        Fruit f = flist.get(0); //ok，flist至少是Fruit的子类，可以读取元素</div><div class="line">        flist.contains(new Apple()); //ok</div><div class="line">        flist.indexOf(new Apple()); //ok</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　上述示例中， List&lt;? extends Fruit&gt;表示可以接收Fruit或Fruit的任意子类。但是不知道具体接收的是哪个子类，由于这种不确定性，为了保证类型安全，无法往list中加入任何对象。<br>  　　所以<strong>协变的作用是用于读取</strong>。因为协变是指定上界, 所以从容器中读出的任何对象都可以用上界来表示<br>　　可以用 List&lt;? super Apple&gt;来表示下界，也称为逆变通配符。它表示可以接受Apple及它的超类。如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class SuperTypeWildcards &#123;</div><div class="line">    static void writeTo(List&lt;? super Apple&gt; apples) &#123; //指定下界为Apple</div><div class="line">        apples.add(new Apple()); //ok, 可以写入Apple或子类</div><div class="line">         apples.add(new HongFuShi());</div><div class="line">        // apples.add(new Fruit()); // Error, 写入Fruit会导致向下转型, 不安全</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　所以<strong>逆变的作用是用于写入</strong>。因为逆变是指定下界，所以可以写入下界对象及其子类。</p>
<h4 id="存储原则和PECS法则："><a href="#存储原则和PECS法则：" class="headerlink" title="存储原则和PECS法则："></a><strong>存储原则和PECS法则：</strong></h4><ol>
<li>如果想从一个数据类型中获取数据，使用? extends T通配符</li>
<li>如果想把对象写入一个数据结构中，使用? super T通配符</li>
<li>如果既想存入又想读取，那就不使用通配符。</li>
</ol>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a><strong>7.总结</strong></h2><ul>
<li>泛型应用最广泛的位置是容器类，它能够运行时异常转移到编译期检查，有效的保证数据安全。</li>
<li>由于擦除的存在，不能通过泛型参数来区分重载方法</li>
<li>任何基本类型都不能作为类型参数</li>
<li>一个类不能实现同一泛型接口的两种变体，因为擦除会使这两个变体成为相同的接口，从而产生冲突。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          <section id="comment">  
  <!-- ��˵���ۿ� start -->
	<div class="ds-thread" data-thread-key="<%= page.path %>" data-title="<%= page.title %>" data-url="https://xuwei1991.github.io/<%= page.permalink %>"></div>
<!-- ��˵���ۿ� end -->
<!-- ��˵����JS���� start (һ����ҳֻ������һ��) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"xuwei1234"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- ��˵����JS���� end -->
 
</section>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="xuwei1991" />
          <p class="site-author-name" itemprop="name">xuwei1991</p>
          <p class="site-description motion-element" itemprop="description">The Best or Nothing</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">45</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuwei1991</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("PlM9fkBu5Xsbaz55LCTKph3O-gzGzoHsz", "Ro21MawN38aeHbNOxyQiQCOC");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
