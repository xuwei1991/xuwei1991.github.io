<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>《Java编程思想》学习笔记之内部类 | xuwei&#39;blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="可以将一个类的定义放在另一个类的定义内部，这就是内部类。  　　一个类的内部可以有成员变量和成员方法，根据内部类定义的位置以及用法不同，可以分为四种，即成员内部类，静态内部类，局部内部类以及匿名内部类。每一种内部类都有各自的特点并且在实际的用途。    本章要点：

成员内部类
静态内部类
局部内部类
匿名内部类
为什么要使用内部类
内部类的继承和覆盖问题1.成员内部类成员内部类的基本使用和方">
<meta property="og:type" content="article">
<meta property="og:title" content="《Java编程思想》学习笔记之内部类">
<meta property="og:url" content="http://yoursite.com/2016/12/16/《Java编程思想》之内部类/index.html">
<meta property="og:site_name" content="xuwei'blog">
<meta property="og:description" content="可以将一个类的定义放在另一个类的定义内部，这就是内部类。  　　一个类的内部可以有成员变量和成员方法，根据内部类定义的位置以及用法不同，可以分为四种，即成员内部类，静态内部类，局部内部类以及匿名内部类。每一种内部类都有各自的特点并且在实际的用途。    本章要点：

成员内部类
静态内部类
局部内部类
匿名内部类
为什么要使用内部类
内部类的继承和覆盖问题1.成员内部类成员内部类的基本使用和方">
<meta property="og:updated_time" content="2016-12-16T15:51:06.127Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Java编程思想》学习笔记之内部类">
<meta name="twitter:description" content="可以将一个类的定义放在另一个类的定义内部，这就是内部类。  　　一个类的内部可以有成员变量和成员方法，根据内部类定义的位置以及用法不同，可以分为四种，即成员内部类，静态内部类，局部内部类以及匿名内部类。每一种内部类都有各自的特点并且在实际的用途。    本章要点：

成员内部类
静态内部类
局部内部类
匿名内部类
为什么要使用内部类
内部类的继承和覆盖问题1.成员内部类成员内部类的基本使用和方">
  
    <link rel="alternate" href="/atom.xml" title="xuwei&#39;blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xuwei&#39;blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-《Java编程思想》之内部类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/16/《Java编程思想》之内部类/" class="article-date">
  <time datetime="2016-12-16T15:50:45.221Z" itemprop="datePublished">2016-12-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      《Java编程思想》学习笔记之内部类
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　<strong>可以将一个类的定义放在另一个类的定义内部，这就是内部类。</strong><br>  　　一个类的内部可以有成员变量和成员方法，根据内部类定义的位置以及用法不同，可以分为四种，即成员内部类，静态内部类，局部内部类以及匿名内部类。每一种内部类都有各自的特点并且在实际的用途。<br>    本章要点：</p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
<li>为什么要使用内部类</li>
<li>内部类的继承和覆盖问题<h2 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a><strong>1.成员内部类</strong></h2>成员内部类的基本使用和方法如下示例：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Outer&#123;</div><div class="line">	private int i =4;</div><div class="line">	class Inner&#123;</div><div class="line">		Inner()&#123;</div><div class="line">			System.out.println("值为"+(++i));</div><div class="line">		&#125;</div><div class="line">		void say()&#123;</div><div class="line">			System.out.println("Hello Word");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public Inner method()&#123;</div><div class="line">		return new Inner();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test_neibu &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">        Outer o = new Outer();</div><div class="line">        o.method().say();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">值为<span class="number">5</span></div><div class="line">Hello Word</div></pre></td></tr></table></figure>
<p>如上所示，在Outer类的内部定义了一个内部类Inner，并在外部类中建立了method方法返回内部类的对象实例，通过该对象完成了对内部类方法的调用。通过这个示例，可以看出来几点：</p>
<ol>
<li>i是Outer类的私有值，内部类可以直接进行访问。这是因为当我们创建内部类对象时，它就会自动捕获一个指向外围对象的引用。</li>
<li>当我们需要调用成员内部类Inner的内部方法时，<strong>首先需要创建外部类的对象，再通过外部类的对象来创建内部类的对象。</strong><br>上述主函数中调用语句也可以书写如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Outer.Inner oi = new Outer().new Inner();</div><div class="line">oi.say();</div></pre></td></tr></table></figure>
<p>得到的结果是一致的。<br>书写格式为：<strong>外部类.内部类  对象名 =  外部对象.内部对象</strong></p>
<p>另外，如果我们需要<strong>在内部类中生成对外部类对象的引用，则可以使用：外部类.this 格式。</strong></p>
<p>在上述示例中，可以将内部类用private修饰（一般的类只有包权限和public权限两种），因为不能访问其名字，那么可以隐藏实现的细节。通过在外部类中建立公共的访问方法，可以实现对私有化内部类的操作，如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Outer&#123;</div><div class="line">	private int i =4;</div><div class="line">	private class Inner&#123;</div><div class="line">		Inner()&#123;</div><div class="line">			System.out.println("值为"+(++i));</div><div class="line">		&#125;</div><div class="line">		void say()&#123;</div><div class="line">			System.out.println("Hello Word");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void method()&#123;</div><div class="line">		Inner in = new Inner();</div><div class="line">		in.say();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test_neibu &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">        Outer o = new Outer();</div><div class="line">        o.method();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2.静态内部类"></a><strong>2.静态内部类</strong></h2><p>静态内部类也是成员内部类的一种，只不过多了关键字static。在普通的成员内部类中，隐式的存在了一个指向外部类的引用。而当内部类为static时，就没有了该引用。静态内部类也就有了如下的两个特点：</p>
<ol>
<li><strong>创建静态内部类的对象，不需要首先创建外部类的对象</strong>。因为此时内部类对象和外部类对象没有联系。类似于类中的静态方法，静态方法属于类方法，调用时不需要创建类的对象来调用。</li>
<li><strong>不能从静态内部类的对象中访问非静态的外部类对象</strong>。这和加载机制有关，静态的加载总是早于实例对象的。<br>示例代码如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Outer&#123;</div><div class="line">	static int i =4;</div><div class="line">	static class Inner&#123;</div><div class="line">		Inner()&#123;</div><div class="line">			System.out.println("值为"+(++i));</div><div class="line">		&#125;</div><div class="line">		static void say()&#123;</div><div class="line">			System.out.println("Hello Word");</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void method()&#123;</div><div class="line">		Inner.say();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test_neibu &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">       Outer.method();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为;</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello Word</div></pre></td></tr></table></figure>
<p>可以看出，Method（）方法中是直接对内部类进行调用的，没有创建对象。另一个证明就是，构造方法并没有执行，直接执行的是静态方法。<br>静态内部类里面只允许调用外部类静态成员，尽管构造方法中的i没有被执行，但是如果不把i设置成静态，会有如下的错误提示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cannot make <span class="selector-tag">a</span> static reference to the non-static field i</div></pre></td></tr></table></figure>
<h2 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3. 局部内部类"></a><strong>3. 局部内部类</strong></h2><p>　　可以在方法里面或者任意的作用域里面定义内部类，这种就被称作局部内部类。<br>  如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//定义一个接口</div><div class="line">interface OI&#123;</div><div class="line">	void method();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Outer2&#123;</div><div class="line">	//创建一个方法，返回值为OI类型</div><div class="line">	public OI say()&#123;</div><div class="line">		 //定义一个实现了OI接口的内部类</div><div class="line">		 class Inner2 implements OI&#123;</div><div class="line">			public void method()&#123;System.out.println("Hello World");&#125;</div><div class="line">		&#125;</div><div class="line">	//返回内部类的实例	 </div><div class="line">	return new Inner2();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test_Inner &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Outer2 ot = new Outer2();</div><div class="line">		OI in = ot.say();</div><div class="line">		in.method();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>Inner2类是say()方法里面的一部分，其作用范围仅仅在方法类，在方法之外无法访问这个类。注意，在say()方法里面定义了内部类Inner2()，但是方法执行完毕之后，内部类仍旧可用。<br>内部类还可以嵌入在方法的任意地方，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Outer3&#123;</div><div class="line">	private void Track(boolean f)&#123;</div><div class="line">		if(f)&#123;</div><div class="line">			class Inner3&#123;</div><div class="line">				private String d;</div><div class="line">				Inner3(String s)&#123;</div><div class="line">					d = s;</div><div class="line">				&#125;</div><div class="line">				String getString()&#123;return d;&#125;</div><div class="line">			&#125;</div><div class="line">			Inner3 in = new Inner3("Hello");</div><div class="line">			String ss=in.getString();</div><div class="line">			System.out.println(ss);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void method()&#123;Track(true);&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestInner2 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Outer3 ot = new Outer3();</div><div class="line">		ot.method();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello</div></pre></td></tr></table></figure>
<p>示例中的内部类Inner3就是嵌入在Track（）方法的if语句中的，在这个语句之外，它是不可用的。</p>
<h2 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4.匿名内部类"></a><strong>4.匿名内部类</strong></h2><p>　　上述几个内部类都是有显式的名称的，而匿名内部类则是应用在方法内部，没有名称的内部类。它可以是对类的继承，也可以是对接口的实现。<br>　　当我们在类中定义普通的成员内部类时，我们一般这样写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Outer4&#123;</div><div class="line">	class Inner4 implements OI&#123;</div><div class="line">		private int i=3;</div><div class="line">		public void method()&#123;System.out.println("i="+i);&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public OI say()&#123;return new Inner4();&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestInner4 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	   Outer4 ot = new Outer4();</div><div class="line">	   OI oi =ot.say();</div><div class="line">	   oi.method();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们把say()方法中返回值的生成和表示返回值的内部类的定义结合在一起，就可以简化成如下的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">class Outer4&#123;</div><div class="line">	public OI say()&#123;</div><div class="line">		return new OI()&#123;</div><div class="line">			private int i=3;</div><div class="line">			public void method()&#123;System.out.println("i="+i);&#125;	</div><div class="line">		&#125;;	</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestInner4 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	   Outer4 ot = new Outer4();</div><div class="line">	   OI oi =ot.say();</div><div class="line">	   oi.method();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　上面两个代码的功能是一样的，简化之后，内部类的名称被省略了，所以也被称为匿名内部类，它是对OI接口的实现，通过new表达式返回的是向上转型后的IO的实现。<br>  <strong>匿名内部类的一般格式为：   new 普通类或抽象类或接口（）{ }；</strong><br>  　　由于匿名内部类没有名称，因此也就没有可用的构造方法，上述示例中是调用了默认的无参的构造方法。如果需要一个有参的构造方法，需要通过实例初始化的方式：如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">abstract class Base&#123;</div><div class="line">	public Base(int i)&#123;</div><div class="line">		System.out.println(&quot;Base Constructor,i=&quot;+i);</div><div class="line">	&#125;</div><div class="line">	abstract void method();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Outer5&#123;</div><div class="line">	public static Base getBase(int i)&#123;</div><div class="line">		return new Base(i)&#123;</div><div class="line">			&#123;System.out.println(&quot;Inner constractor&quot;);&#125;</div><div class="line">			void method()&#123;</div><div class="line">				System.out.println(&quot;Inside method&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class TestInner5 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	 Base bs = Outer5.getBase(23);</div><div class="line">	 bs.method();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Base Constructor,i=<span class="number">23</span></div><div class="line">Inner constractor</div><div class="line">Inside method</div></pre></td></tr></table></figure>
<p>在这个示例中，i不要求为final，因为它是被传递到了Base类的构造方法中。</p>
<h2 id="5-为什么要使用内部类"><a href="#5-为什么要使用内部类" class="headerlink" title="5.为什么要使用内部类"></a><strong>5.为什么要使用内部类</strong></h2><p>使用内部类能够有以下的一些好处：<br>1）<strong>实现“多重继承”。</strong><br>每个内部类都能独立的继承自一个类或者实现一个接口，所以无论外围内是否已经继承了某个类或者实现了某个接口，对内部类都没有影响。尤其是对抽象类或者具体的类而言，只有内部类才能实现多重继承，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class A&#123;&#125;</div><div class="line">abstract class B&#123;&#125;</div><div class="line">class C extends A&#123;</div><div class="line">B makeB()&#123;</div><div class="line">return new B()&#123;&#125;;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类C继承了A，再通过匿名内部类继承了抽象类B。<br>2）<strong>内部类可以有多个实例，</strong>每个实例都有自己的状态信息，并且与外围类的对象的状态信息相独立。<br>3）在单个外围类中，可以让多个内部类以不同的方式实现同一个接口或者实现一个类。<br>如下示例所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">interface Animal&#123;</div><div class="line">	void run();</div><div class="line">	void fly();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Outer6&#123;</div><div class="line">    class Dog implements Animal&#123;</div><div class="line">		public void run()&#123;System.out.println("用狗的方式跑步");&#125;</div><div class="line">		public void fly()&#123;System.out.println("用狗的方式飞行");&#125;</div><div class="line">	&#125;</div><div class="line">	class Pig implements Animal&#123;</div><div class="line">		public void run()&#123;System.out.println("用猪的方式跑步");&#125;</div><div class="line">		public void fly()&#123;System.out.println("用猪的方式飞行");&#125;</div><div class="line">	&#125;</div><div class="line">	public Animal makedog()&#123;</div><div class="line">		return new Dog();</div><div class="line">	&#125;</div><div class="line">	public Animal makepig()&#123;</div><div class="line">		return new Pig();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class TestInner6 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Outer6 ot = new Outer6();</div><div class="line">		Animal d = ot.makedog();</div><div class="line">		Animal p = ot.makepig();</div><div class="line">		d.run();</div><div class="line">		p.run();	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">用狗的方式跑步</div><div class="line">用猪的方式跑步</div></pre></td></tr></table></figure>
<p>上面的示例中，两个内部类采用不同的方式实现了同一个接口，如果不采用内部类，那么就只能用同一种方式实现接口，内部类有了更大的灵活性。<br>4）创建内部类对象的时刻并不依赖于外围内对象的创建，对于静态内部类而言是如此。</p>
<h2 id="6-内部类的继承和覆盖问题"><a href="#6-内部类的继承和覆盖问题" class="headerlink" title="6.内部类的继承和覆盖问题"></a><strong>6.内部类的继承和覆盖问题</strong></h2><p><strong>6.1 内部类的继承</strong><br>　　由于内部类的构造方法必须连接到指向其外部类的引用，所以在继承内部类的时候，指向外部类的引用必须被初始化，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Outer&#123;</div><div class="line">   class Inner&#123;&#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public class InheritInner extends Outer.Inner&#123;</div><div class="line">   InheritInner(Outer ot)&#123;</div><div class="line">   ot.super();</div><div class="line">   &#125;</div><div class="line">   public static void main (String[] args)&#123;</div><div class="line">   Outer ot = new Outer();</div><div class="line">   InheritInner ii = new InheritInner(ot);</div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="6-2-内部类的覆盖"><a href="#6-2-内部类的覆盖" class="headerlink" title="6.2 内部类的覆盖"></a><strong>6.2 内部类的覆盖</strong></h2><p>内部类是可以继承的，但是必须要明确的继承哪个内部类，即Outer.Inner。如果不明确的继承，是不能够覆盖原有内部类的方法的。因为那样内部类是两个完全独立的实体，各自在自己的命名空间类。</p>
<p><strong>总结：</strong></p>
<ol>
<li>接口和内部类解决了Java中“多重继承”的问题。</li>
<li>四种内部类有自己各自的用法，匿名内部类语法较为特殊，在设计模式中也有用到，需要重点掌握。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/16/《Java编程思想》之内部类/" data-id="ciwrz2eca0000lonsptvarznl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/12/15/《Java编程思想》学习笔记之接口/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">《java编程思想》学习笔记之接口</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/构造器-初始化/">构造器,初始化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合-继承/">组合,继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/访问权限-关键字/">访问权限,关键字</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/构造器-初始化/" style="font-size: 10px;">构造器,初始化</a> <a href="/tags/组合-继承/" style="font-size: 10px;">组合,继承</a> <a href="/tags/访问权限-关键字/" style="font-size: 10px;">访问权限,关键字</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/16/《Java编程思想》之内部类/">《Java编程思想》学习笔记之内部类</a>
          </li>
        
          <li>
            <a href="/2016/12/15/《Java编程思想》学习笔记之接口/">《java编程思想》学习笔记之接口</a>
          </li>
        
          <li>
            <a href="/2016/12/14/《Java编程思想》学习笔记之多态/">《Java编程思想》学习笔记之多态</a>
          </li>
        
          <li>
            <a href="/2016/12/14/《Java编程思想》学习笔记之final关键字概述/">《Java编程思想》学习笔记之final关键字概述</a>
          </li>
        
          <li>
            <a href="/2016/12/14/《java编程思想》学习笔记之复用类/">《Java编程思想》学习笔记之复用类</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 xuwei&#39;blog<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>